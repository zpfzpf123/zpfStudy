{
  "note": [
    {
      "id": 1,
      "name": "vuex",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "## Vuex\n\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。\n\n调试工具：vue devtools\n\n> Vuex就像眼镜：您自会知道什么时候需要它。\n\n### 1、state\n\n在store中定义数据，在组件中直接使用：\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    getters: {},\n    mutations: {},\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Home.vue`\n\n```html\n<template>\n  <div class=\"home\">\n    <h2>Home页面的数字：{{$store.state.num}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  \n}\n</script>\n```\n\n或者写为：\n\n```html\n<template>\n  <div class=\"about\">\n    <h2>About页面的数字：{{num}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    num(){\n      return this.$store.state.num\n    }\n  }\n}\n</script>\n```\n\n### 2、getters\n\n将组件中统一使用的computed都放到getters里面来操作\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    mutations: {},\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Home.vue`\n\n```html\n<template>\n  <div class=\"home\">\n    <h2>Home页面的数字：{{$store.getters.getNum}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  \n}\n</script>\n```\n\n### 3、mutations\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios）\n    mutations: {\n        // 让num累加\n        // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n        increase(state, payload){\n            state.num += payload ? payload : 1;\n        }\n    },\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Btn.vue`\n\n```html\n<template>\n    <div>\n        <button @click=\"$store.commit('increase', 2)\">点击加1</button>\n    </div>\n</template>\n<script>\nexport default {\n   methods: {\n       /* addFn(){\n           // 调用store中的mutations里的increase方法\n           // 传参的话，使用payload\n           this.$store.commit('increase', 2)\n       } */\n   }\n}\n</script>\n```\n\n### 4、actions\n\nactions是store中专门用来处理异步的，实际修改状态值的，还是mutations\n\n目录：`store/index.js`\n\n```js\n// 在store(仓库)下的index.js这份文件，就是用来做状态管理\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios）\n    mutations: {\n        // 让num累加\n        // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n        increase(state, payload){\n            state.num += payload ? payload : 1;\n        },\n        // 让num累减\n        decrease(state){\n            state.num--;\n        }\n    },\n    // actions专门用来处理异步，实际修改状态值的，依然是mutations\n    actions: {\n        // 点击了“减1”按钮后，放慢一秒再执行减法\n        decreaseAsync(context){\n            context.commit('decrease')\n        }\n    },\n    modules: {}\n})\n\n```\n\n目录：`Btn.vue`\n\n```html\n<template>\n    <div>\n        <button @click=\"$store.commit('increase', 2)\">点击加1</button>\n        <button @click=\"$store.dispatch('decreaseAsync')\">点击延迟减1</button>\n    </div>\n</template>\n<script>\nexport default {\n   methods: {\n       /* addFn(){\n           // 调用store中的mutations里的increase方法\n           // 传参的话，使用payload\n           this.$store.commit('increase', 2)\n       }\n       reduceFn(){\n           this.$store.dispatch('decreaseAsync')\n       } */\n   }\n}\n</script>\n```\n\n### 5、辅助函数\n\nmapState和mapGetters在组件中都是写在computed里面\n\n```html\n<template>\n\t<div>\n        <h2>Home页面的数字：{{num}}</h2>\n        <h2>About页面的数字：{{getNum}}</h2>\n    </div>\n</template>\n\n<script>\nimport { mapState, mapGetters } from 'vuex'\n\nexport default {\n  computed: {\n    ...mapState(['num'])\n    ...mapGetters(['getNum'])\n  }\n}\n</script>\n```\n\nmapMutations和mapActions在组件中都是写在methods里面\n\n```html\n<template>\n\t<div>\n        <button @click=\"increase(2)\">点击加1</button>\n        <button @click=\"decreaseAsync()\">点击延迟减1</button>\n    </div>\n</template>\n\n<script>\nimport { mapMutations, mapActions } from 'vuex'\n\nexport default {\n  methods: {\n       ...mapMutations(['increase']),\n       ...mapActions(['decreaseAsync'])\n   }\n}\n</script>\n```\n\n### 6、拆分写法\n\nstore中的所有属性，都可以拆分成单独的js文件来书写\n\n### 7、modules\n\n![](.\\1111.png)我们的store可以认为是一个主模块，它下边可以分解为很多子模块，子模块都可以单独领出来写，写完再导入到主模块中。下面以 `users` 子模块举例：\n\n将mutations中所有的方法，归纳起来。\n\n目录：`mutations_type.js`\n\n```js\nexport const MUTATIONS_TYPE = {\n    INCREASE: 'increase',\n    DECREASE: 'decrease'\n}\n\nexport default {\n    // 让num累加\n    // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n    [MUTATIONS_TYPE.INCREASE](state, payload){\n        state.num += payload ? payload : 1;\n    },\n    // 让num累减\n    [MUTATIONS_TYPE.DECREASE](state){\n        state.num--;\n    }\n}\n```\n\n目录：`store/index.js`\n\n```js\nimport mutations from './mutaions_type'\n\nexport default new Vuex.Store({\n    ...\n    mutations,\n    ...\n})\n```\n\n组件中：\n\n```html\n<template>\n  <div class=\"about\">\n    <h2>About页面的数字：{{getNum}}</h2>\n    <button @click=\"increase()\">About的按钮，点击加1</button>\n  </div>\n</template>\n<script>\nimport { mapGetters, mapMutations } from 'vuex'\nimport { MUTATIONS_TYPE } from '@/store/mutaions_type.js'\nexport default {\n  computed: {\n    ...mapGetters(['getNum'])\n  },\n  methods: {\n    // 方法一：\n    ...mapMutations([MUTATIONS_TYPE.INCREASE])\n      \n    // 方法二：\n    /* increase(){\n      this.$store.commit(MUTATIONS_TYPE.INCREASE)\n    } */\n  }\n}\n</script>\n\n```\n\n\n\n"
    },
    {
      "id": 2,
      "name": "vue大屏动态配置组件数量、每个组件的占比和位置代码示例",
      "type": "vue",
      "recommendationIndex": 4,
      "content": "以下是使用Vue.js创建一个大屏组件，并且可以通过传递props来配置组件数量、每个组件的占比和位置的代码示例：\n\n```js\n<template>\n  <div class=\"big-screen\">\n    <div v-for=\"(item, index) in screenList\" :key=\"index\" :style=\"getStyle(item)\">\n      <slot :name=\"item.name\"></slot>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'BigScreen',\n  props: {\n    screenList: {\n      type: Array,\n      required: true,\n      default: () => []\n    }\n  },\n  methods: {\n    getStyle(item) {\n      return {\n        position: 'absolute',\n        left: `${item.left}%`,\n        top: `${item.top}%`,\n        width: `${item.width}%`,\n        height: `${item.height}%`\n      }\n    }\n  }\n}\n</script>\n\n<style>\n.big-screen {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n</style>\n```\n\n在这个示例中，我们定义了一个名为`BigScreen`的组件，并且传递了一个名为`screenList`的props，它是一个数组，用来指定大屏组件的个数、占比和位置。\n\n在组件的模板中，我们使用了`v-for`来遍历`screenList`数组，并为每个大屏组件指定样式（位置和大小），然后使用插槽来插入具体的大屏组件内容。\n\n在组件的方法中，我们定义了一个名为`getStyle`的方法，它接受一个参数`item`，并返回一个包含位置和大小信息的样式对象，这个样式对象会被应用到每个大屏组件的容器元素上。\n\n现在让我们看一个如何使用这个`BigScreen`组件的示例：\n\n```js\n<template>\n  <div style=\"height:100%\">\n    <big-screen :screen-list=\"screenList\">\n      <template #screen1>\n        <div>第一个大屏内容</div>\n      </template>\n      <template #screen2>\n        <div>第二个大屏内容</div>\n      </template>\n    </big-screen>\n  </div>\n</template>\n\n<script>\nimport BigScreen from './BigScreen.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    BigScreen\n  },\n  data() {\n    return {\n      screenList: [\n        { name: 'screen1', left: 0, top: 0, width: 50, height: 100 },\n        { name: 'screen2', left: 50, top: 0, width: 50, height: 100 }\n      ]\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，我们在父组件中使用了`BigScreen`组件，并且传递了一个名为`screenList`的props，它包含了两个元素，分别代表了两个大屏组件的位置、大小和内容名称。\n\n我们也定义了两个插槽（`#screen1`和`#screen2`），它们分别对应了`screenList`数组中的两个元素，表示在第一个大屏和第二个大屏"
    },
    {
      "id": 3,
      "type": "vue",
      "recommendationIndex": 3,
      "name": "vue2+原生js实现上下无缝滚动，鼠标移入停止无缝滚动，可以鼠标滚轮控制滚动，鼠标移出可以继续上下无缝滚动",
      "content": "```js\n<template>\n  <div class=\"scroll-container\" @mouseenter=\"stopScroll\" @mouseleave=\"startScroll\" @wheel=\"onWheel\">\n    <div class=\"scroll-content\">\n      <div class=\"scroll-item\" v-for=\"item in scrollData\" :key=\"item\">{{ item }}</div>\n      <div class=\"scroll-item\" v-for=\"item in scrollData\" :key=\"item\">{{ item }}</div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'SeamlessScroll',\n  data() {\n    return {\n      scrollData: ['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5'],\n      scrollInterval: null,\n      scrollSpeed: 1,\n    }\n  },\n  mounted() {\n    this.startScroll();\n  },\n  beforeDestroy() {\n    clearInterval(this.scrollInterval);\n  },\n  methods: {\n    startScroll() {\n      this.scrollInterval = setInterval(() => {\n        if (this.$el.scrollTop >= this.$el.scrollHeight / 2) {\n          this.$el.scrollTop = 0;\n        } else {\n          this.$el.scrollTop += this.scrollSpeed;\n        }\n      }, 10);\n    },\n    stopScroll() {\n      clearInterval(this.scrollInterval);\n    },\n    onWheel(event) {\n      event.preventDefault();\n      this.$el.scrollTop += event.deltaY;\n    },\n  },\n}\n</script>\n\n<style scoped>\n.scroll-container {\n  height: 200px;\n  overflow: hidden;\n}\n.scroll-content {\n  display: flex;\n  flex-direction: column;\n}\n.scroll-item {\n  height: 50px;\n}\n</style>\n```\n\n"
    },
    {
      "id": 4,
      "type": "vue",
      "recommendationIndex": 4,
      "name": "vue2+Datav实现表格上下无缝滚动",
      "content": "1. 首先需要在vue引入DataV组件 \n   ```js\n   npm install @jiaminghi/data-view\n   ```\n\n   \n\n2. 在main.js注册为全局组件\n   ```js\n   // 将自动注册所有组件为全局组件\n   import dataV from '@jiaminghi/data-view'\n   \n   Vue.use(dataV)\n   ```\n\n3. 使用vue文件代码如下\n   ```vue\n   <template>\n     <div id=\"the-homework-table\">\n       <dv-scroll-board\n         :config=\"config\"\n         style=\"width: 100%; height: 100%\"\n       />\n     </div>\n   </template>\n   \n   <script>\n   export default {\n     data() {\n       return {\n         config: {\n           header: [\n             \"时间\",\n           ],\n           data: [\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n            [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n           ],\n           index: true,//增加序号显示\n           rowNum: 10,//超过10行启动无缝滚动\n         },\n       };\n     },\n   };\n   </script>\n   \n   <style lang=\"less\" scoped>\n   #the-homework-table {\n     width: 100%;\n     height: 100%;\n   }\n   /deep/ .dv-scroll-board .header {\n     font-size: 25px;\n   }\n   /deep/ .dv-scroll-board .rows .row-item {\n     font-size: 24px;\n   }\n   /deep/ .dv-scroll-board .rows .ceil {\n     text-align: center;\n   }\n   /deep/ .dv-scroll-board .header .header-item {\n     text-align: center;\n   }\n   </style>\n   ```\n\n   "
    },
    {
      "id": 5,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue2+echarts封装组件  饼图组件",
      "content": "```js\n<template>\n  <div ref=\"chart\" :style=\"{ height: '100%', width: '100%' }\"></div>\n</template>\n\n<script>\nimport echarts from \"echarts\";\n\nexport default {\n  props: {\n    // 接受数据作为 props\n    data: {\n      type: Array,\n      required: true,\n    },\n    // 接受颜色作为 props\n    colors: {\n      type: Array,\n      default() {\n        return [\"#00BFFF\", \"#FF6B00\"];\n      },\n    },\n    //标题\n    chartTitle: {\n      type: String,\n      default:''\n    },\n    // 是否显示标签\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    // 标签位置\n    labelPosition: {\n      type: String,\n      default: \"inside\",\n    },\n    // 标签字体大小\n    labelFontSize: {\n      type: Number,\n      default: 14,\n    },\n    // 是否自适应\n    responsive: {\n      type: Boolean,\n      default: true,\n    },\n    // series 名称\n    seriesName: {\n      type: String,\n      required: true,\n    },\n    // 是否显示图例\n    showLegend: {\n      type: Boolean,\n      default: false,\n    },\n    // 图例位置\n    legendPosition: {\n      type: String,\n      default: \"right\",\n    },\n  },\n  data() {\n    return {\n      // 设置初始高度\n      chartHeight: \"300px\",\n    };\n  },\n  mounted() {\n    // 渲染图表\n    this.renderChart();\n    // 如果需要自适应，则监听窗口大小变化\n    if (this.responsive) {\n      window.addEventListener(\"resize\", this.renderChart);\n    }\n  },\n  beforeDestroy() {\n    // 如果需要自适应，则在组件销毁前移除监听器\n    if (this.responsive) {\n      window.removeEventListener(\"resize\", this.renderChart);\n    }\n  },\n  methods: {\n    renderChart() {\n      // 初始化 echarts 实例\n      const chart = echarts.init(this.$refs.chart);\n      // 设置图表选项\n      chart.setOption({\n        title: {\n          text: this.chartTitle,\n          left: \"center\",\n          textStyle: {\n            fontSize: 20,\n            color:'white'\n          },\n        },\n        // 配置提示框\n        tooltip: {\n          trigger: \"item\",\n          formatter: \"{a} <br/>{b}: {c} ({d}%)\",\n        },\n        // 配置图例\n        legend: {\n          show: this.showLegend,\n          orient: this.legendPosition,\n        },\n        // 配置 series\n        series: [\n          {\n            // 设置 series 名称\n            name: this.seriesName,\n            // 设置 series 类型为饼状图\n            type: \"pie\",\n            // 设置饼状图半径\n            radius: [\"50%\", \"70%\"],\n            // 避免标签重叠\n            avoidLabelOverlap: false,\n            // 配置标签\n            label: {\n              show: this.showLabel,\n              position: this.labelPosition,\n              fontSize: this.labelFontSize,\n            },\n            // 配置标签强调样式\n            emphasis: {\n              label: {\n                show: true,\n                fontSize: this.labelFontSize + 2,\n                fontWeight: \"bold\",\n              },\n            },\n            // 配置标签线\n            labelLine: {\n              show: false,\n            },\n            // 配置数据\n            data: this.data.map((item, index) => ({\n              value: item.val,\n              name: item.name,\n              itemStyle: {\n                color: this.colors[index],\n              },\n            })),\n          },\n        ],\n      });\n      // 如果需要自适应，则在渲染后调整图表大小\n      if (this.responsive) {\n        chart.resize();\n      }\n    },\n  },\n};\n</script>\n\n<style>\n/* 可选的图表容器样式 */\n</style>\n```\n\n# 组件使用示例\n\n```js\n<pie-chart\n            :data=\"chartData\"\n            :colors=\"chartColors\"\n            :show-label=\"showLabel\"\n            :label-position=\"labelPosition\"\n            :label-font-size=\"labelFontSize\"\n            :responsive=\"true\"\n            series-name=\"作业统计\"\n            chartTitle=\"作业统计\"\n          />\n  \ndata() {\n    return {\n      chartData: [\n        {name:'已完成',val:10},\n        {name:'未完成',val:20},\n      ],\n      chartColors: ['#00BFFF','#FF6B00'],\n      showLabel: true,\n      labelPosition: 'inside',\n      labelFontSize: 25,\n    }\n  },\n```\n\n"
    },
    {
      "id": 6,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue2+echarts封装组件  柱状图组件",
      "content": "```js\n<template>\n  <div ref=\"chart\" style=\"width: 100%; height: 100%\"></div>\n</template>\n\n<script>\nimport echarts from \"echarts\";\n\nexport default {\n  props: {\n    //颜色\n    colorList: {\n      type: Array,\n      default: () => {\n        return [\"#00BFFF\", \"#FF6B00\"];\n      },\n    },\n    // 图表标题\n    title: {\n      type: String,\n      required: true,\n    },\n    // x 轴数据\n    xAxisData: {\n      type: Array,\n      required: true,\n    },\n    // 数据系列\n    seriesData: {\n      type: Array,\n      required: true,\n    },\n    // 图例数据\n    legendData: {\n      type: Array,\n      required: true,\n    },\n    // tooltip 的 crossStyle\n    crossStyle: {\n      type: Object,\n      default: () => {\n        return {\n          color: \"white\",\n        };\n      },\n    },\n    /**\n     * @description:  字体大小列表，依次为：\n    0. 标题字体大小\n     1. 图例字体大小\n    2. x 轴标签字体大小\n     3. y 轴标签字体大小\n     4. 数据标签字体大小\n     5. tooltip 字体大小\n     * @return {*}\n     */\n    fontSizeList: {\n      type: Array,\n      required: true,\n    },\n  },\n  data() {\n    return {\n      chart: null,\n    };\n  },\n  mounted() {\n    // 初始化 echarts 实例\n    this.chart = echarts.init(this.$refs.chart);\n    // 设置图表配置项\n    this.chart.setOption({\n      color:this.colorList,\n      // 图表标题\n      title: {\n        text: this.title,\n        textStyle: {\n          color: \"#fff\",\n          fontSize: this.fontSizeList[0],\n        },\n      },\n      // tooltip\n      tooltip: {\n        trigger: \"axis\",\n        axisPointer: {\n          type: \"cross\",\n          crossStyle: this.crossStyle,\n        },\n        textStyle: {\n          fontSize: this.fontSizeList[5],\n        },\n      },\n      // 图例\n      legend: {\n        data: this.legendData,\n        textStyle: {\n          color: \"#fff\",\n          fontSize: this.fontSizeList[1],\n        },\n      },\n      // x 轴\n      xAxis: [\n        {\n          type: \"category\",\n          data: this.xAxisData,\n          axisPointer: {\n            type: \"shadow\",\n          },\n          axisLabel: {\n            textStyle: {\n              color: \"#fff\",\n              fontSize: this.fontSizeList[2],\n            },\n          },\n          // 去掉 x 轴的分割线\n          splitLine: {\n            show: false,\n          },\n        },\n      ],\n      // y 轴\n      yAxis: [\n        {\n          type: \"value\",\n          axisLabel: {\n            textStyle: {\n              color: \"#fff\",\n              fontSize: this.fontSizeList[3],\n            },\n          },\n          // 去掉 y 轴的分割线\n          splitLine: {\n            show: false,\n          },\n        },\n      ],\n      // 数据系列\n      series: this.seriesData.map((item) => {\n        return {\n          name: item.name,\n          type: \"bar\",\n          data: item.data,\n          label: {\n            show: this.showLabel,\n            position: this.labelPosition,\n            fontSize: this.fontSizeList[4],\n          },\n        };\n      }),\n    });\n    // 监听窗口大小变化，自适应图表大小\n    window.addEventListener(\"resize\", () => {\n      this.chart.resize();\n    });\n  },\n};\n</script>\n```\n\n# 组件使用示例\n\n```js\n<bar-chart\n            :title=\"chartTitle\"\n            :x-axis-data=\"xAxisData\"\n            :series-data=\"seriesData\"\n            :legend-data=\"legendData\"\n            :cross-style=\"crossStyle\"\n            :font-size-list=\"fontSizeList\"\n          />\n  \ndata() {\n    return {\n      title: \"人员管理\",\n      chartTitle: \"人员统计\",\n      xAxisData: [\"A\", \"B\", \"C\", \"D\", \"E\"],\n      seriesData: [\n        {\n          name: \"员工数量\",\n          data: [10, 20, 30, 40, 50],\n        },\n        {\n          name: \"访客数量\",\n          data: [20, 30, 40, 50, 60],\n        },\n      ],\n      legendData: [\"员工数量\", \"访客数量\"],\n      crossStyle: {\n        color: \"white\",\n      },\n      fontSizeList: [18, 20, 20, 20, 20, 20],\n    };\n  },\n```\n\n"
    },
    {
      "name": "vue2播放flv视频流",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "# 下载flv.js\n\n```js\nnpm install --save flv.js\n```\n\n# 代码示例\n\n```js\n<template>\n  <div>\n\t<video id=\"videoElement\" controls autoplay muted width=\"300px\" height=\"200px\">    \n    </video>\n\t<button @click=\"play\">播放</button>\n  </div>\n</template>\n<script>\n    import flvjs from 'flv.js'\nexport default {\n  data () {\n    return {\n\t  flvPlayer:null\n    }\n  },\n   mounted() {\n      if (flvjs.isSupported()) {\n        var videoElement = document.getElementById('videoElement');\n        this.flvPlayer = flvjs.createPlayer({\n          type: 'flv',\n\t\t  isLive: true,\n\t\t  hasAudio: false,\n          url: 'http://1011.hlsplay.aodianyun.com/demo/game.flv'\n        });\n        this.flvPlayer.attachMediaElement(videoElement);\n        try {\n            this.flvPlayer.load()\n            this.flvPlayer.play()\n          } catch (e) {\n            console.log(e)\n          }\n      }\n    },\n    methods:{\n      play () {\n        this.flvPlayer.play();\n      }\n    },\n    beforeDestroy(){\n        this.flvPlayer && this.flvPlayer.destory()\n    }\n}\n</script>\n\n```\n\n",
      "id": 7
    },
    {
      "id": 8,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue+nginx部署",
      "content": "# vue\n\nvue.config.js配置如下\n\n```js\nconst {defineConfig} = require('@vue/cli-service')\nmodule.exports = defineConfig({\n    transpileDependencies: true,\n    //打包\n    publicPath: './',\n    devServer: {\n        host: '0.0.0.0',\n        port: 8080,\n        proxy: {\n            '/captures': {\n                target: 'http://192.168.1.150:18080', // 目标路径，别忘了加http和端口号 也就是接口的前面的ip地址端口号\n                changeOrigin: true, // 是否跨域\n            }\n        }\n    }\n})\n \n```\n\n# nginx\n\nnginx.conf配置如下\n\n```json\n\nuser  root;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n    \t# 服务器端口号\n        listen       80; \n    \t# 服务器名称\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n        location / {\n            root    /zckx/nginx/html/dist; #项目文件位置\n            index  index.html;\n            try_files $uri $uri/ /index.html;\n        }\n\t\t# 配置跨域 比如接口以/captures开头的配置如下\n        location /captures/ {\n            # 允许http://192.168.1.150:18080跨域 http://192.168.1.150:18080为接口地址\n            proxy_pass http://192.168.1.150:18080; \n        }\n\n        location /live{\n            add_header Access-Control-Allow-Origin *;\n            types {\n                application/vnd.apple.mpegurl m3u8;\n                video/mp2t ts;\n            }\n            # HLS切片文件目录\n            alias /tmp/hls;\n            expires -1;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n\nrtmp {\n        server {\n                listen 1935;\n                chunk_size 4096;\n                # vod path\n                application live {\n                        live on;\n                        hls on;\n                        ##HLS切片保存路径\n                        hls_path /tmp/hls;\n                        hls_fragment 4;\n                        hls_playlist_length 30;\n                        record off;\n                }\n        }\n}\n\n\n\n\n```\n\n"
    },
    {
      "name": "vue二次封装axios",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "## 代码\n在src创建request文件夹 新建axios.js\n\n```js\nimport axios from 'axios';\nimport {Message} from 'element-ui';\n// 统一请求路径前缀\nlet baseApi = \"/\";\n\n// 超时设定\naxios.defaults.timeout = 20000;\n\naxios.interceptors.request.use(config => {\n    return config;\n}, err => {\n    Message.error('请求超时');\n    return Promise.reject(err);\n});\n\n// http response 拦截器\naxios.interceptors.response.use(response => {\n    return response.data;\n}, (err) => {\n    // 返回状态码不为200时候的错误处理\n    Message.error(err.toString());\n    return Promise.reject(err);\n});\n\nexport const getRequest = (url, params) => {\n    return axios({\n        method: 'get',\n        url: `${baseApi}${url}`,\n        params: params,\n    });\n};\n\nexport const postRequest = (url, params) => {\n    return axios({\n        method: 'post',\n        url: `${baseApi}${url}`,\n        data: params,\n    });\n};\n\nexport const putRequest = (url, params) => {\n    return axios({\n        method: 'put',\n        url: `${baseApi}${url}`,\n        data: params,\n    });\n};\n```\n# Axios 请求模块使用说明\n\n这是一个基于 `axios` 的 HTTP 请求模块，提供了 `get`、`post` 和 `put` 方法的封装。\n\n## 配置\n\n- 请求超时时间：20000 毫秒\n- 请求路径前缀：`/`\n\n## 拦截器\n\n- 请求拦截器：在请求被发送之前进行拦截，如果请求超时，将显示错误消息 \"请求超时\"。\n- 响应拦截器：在响应被返回之前进行拦截，如果返回状态码不为 200，将显示错误消息。\n\n## 方法\n\n### getRequest(url, params)\n\n发送 GET 请求。\n\n参数：\n\n- `url`：请求的 URL\n- `params`：请求的参数\n\n### postRequest(url, params)\n\n发送 POST 请求。\n\n参数：\n\n- `url`：请求的 URL\n- `params`：请求的参数\n\n### putRequest(url, params)\n\n发送 PUT 请求。\n\n参数：\n\n- `url`：请求的 URL\n- `params`：请求的参数\n\n## 使用示例\n可以再封装一层，比如创建一个note.js,如下:\n```js\nimport { getRequest, postRequest, delRequest, putRequest } from '@/request/axios'\n\nexport default {\n  getNote: (params) => {\n    return getRequest('note', params)\n  },\n  postNote: (params) => {\n    return postRequest('note', params)\n  },\n  delNote: (params) => {\n    return delRequest(`note/${params}`)\n  },\n  putNote: (url1, params) => {\n    return putRequest(`note`, url1, params)\n  }\n}\n```\n接下来使用就很简单了，如下:\n先引入：\n```javascript\nimport Note from \"@/api/note\";\n```\n随便使用一个接口，如下：\n```js\nNote.getNote()\n        .then((list) => {\n          console.log(list);\n        })\n        .catch((_) => {\n        });\n```\n",
      "id": 9
    },
    {
      "name": "vue2+mqtt.js封装",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "这是一个使用 MQTT.js 的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 MQTT.js。\n\n## 安装\n\n首先，你需要在你的项目中安装 MQTT.js。你可以通过 npm 来安装：\n\n```bash\nnpm install mqtt --save\n```\n\n## 封装插件\n\n```js\n// 导入 mqtt 库\nimport * as mqtt from 'mqtt'\n\nexport default {\n  install(Vue) {\n    // 在 Vue 的原型上添加一个名为 $mqtt 的方法\n    Vue.prototype.$mqtt = (url, topics, option) => {\n      // 设置 MQTT 客户端的选项\n      const options = {\n        reconnectPeriod: 1000, // 如果连接断开，客户端将在1秒后尝试重新连接\n        ...option\n      }\n\n      // 创建一个新的 MQTT 客户端并连接到服务器\n      const client = mqtt.connect(url, options)\n\n      // 当客户端连接到服务器时，打印一条消息并订阅主题\n      client.on('connect', () => {\n        console.log('MQTT client connected')\n        // 订阅主题\n        topics && topics.forEach(topic => client.subscribe(topic))\n      })\n\n      // 当客户端遇到错误时，打印错误消息\n      client.on('error', (error) => {\n        console.error('MQTT client encountered an error:', error)\n      })\n\n      // 当客户端正在尝试重新连接时，打印一条消息\n      client.on('reconnect', () => {\n        console.log('MQTT client is attempting to reconnect')\n      })\n\n      // 返回一个对象，该对象包含一些方法，这些方法可以在 Vue 组件中使用\n      return {\n        // 收到消息时的回调函数\n        message: (callback) => {\n          client.on('message', (topic, message) => {\n            callback(topic, message.toString())\n          })\n        },\n        // 发送消息\n        publish: function(topic, message, callback) {\n          client.publish(topic, message)\n          callback()\n        },\n\n        // 关闭客户端\n        end: callback => {\n          client.end()\n          callback()\n        }\n      }\n    }\n  }\n}\n\n```\n\n\n\n然后，将上述代码保存为 `mqttPlugin.js` 文件，并将其放在你的项目的 `src/plugins` 目录下。\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `$mqtt` 方法来创建一个新的 MQTT 客户端。以下是 `$mqtt` 方法的参数：\n\n- `url`：MQTT 服务器的 URL。\n- `topics`：一个数组，包含你想要订阅的主题。\n- `option`：一个对象，包含 MQTT 客户端的选项。这个对象会和默认选项合并。默认选项包括 `reconnectPeriod: 1000`，表示如果连接断开，客户端将在1秒后尝试重新连接。\n\n`$mqtt` 方法返回一个对象，该对象包含以下方法：\n\n- `message(callback)`：设置一个回调函数，当收到任何主题的消息时，该回调函数会被调用。回调函数接受两个参数，即主题和消息的内容（字符串格式）。\n- `publish(topic, message, callback)`：向指定主题发送一个消息，然后调用回调函数。\n- `end(callback)`：关闭 MQTT 客户端，然后调用回调函数。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `mqttPlugin` 插件的示例：\n\n```javascript\n<template>\n  <div>\n    <button @click=\"connect\">Connect</button>\n    <button @click=\"sendMessage\">Send Message</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      mqttClient: null\n    }\n  },\n  methods: {\n    connect() {\n      this.mqttClient = this.$mqtt('mqtt://test.mosquitto.org', ['topic1', 'topic2'])\n\n      this.mqttClient.message((topic, message) => {\n        console.log(`Received message on ${topic}: ${message}`)\n      })\n    },\n    sendMessage() {\n      this.mqttClient.publish('topic1', 'Hello, MQTT!', () => {\n        console.log('Message sent')\n      })\n    },\n    disconnect() {\n      this.mqttClient.end(() => {\n        console.log('MQTT client disconnected')\n      })\n    }\n  },\n  beforeDestroy() {\n    // 在组件销毁时关闭 MQTT 客户端\n    this.disconnect()\n  },\n}\n</script>\n```\n\n在这个示例中，当你点击 “Connect” 按钮时，会创建一个新的 MQTT 客户端并连接到服务器。当你点击 “Send Message” 按钮时，会向 `topic1` 发送一个消息。当你离开当前页面路由，会断开 MQTT 客户端的连接。",
      "id": 10
    },
    {
      "name": "vue2+elementui二次封装",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "# 封装el-dialog\n\n这是一个使用 `Dialog` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `Dialog` 组件。\n\n## 代码\n\n```js\n<template>\n  <div id=\"Dialog\">\n    <el-dialog :title=\"title\" :fullscreen=\"fullscreen\" :center=\"center\" :visible=\"visible\" :width=\"width\"\n               :custom-class=\"customClass\" @open=\"openDialog\"\n               @close=\"closeDialog\"\n    >\n      <template v-slot:title>\n        <slot name=\"title\"/>\n      </template>\n      <template v-slot:default>\n        <slot name=\"content\"/>\n      </template>\n      <template v-slot:footer>\n        <slot name=\"footer\"/>\n      </template>\n    </el-dialog>\n  </div>\n</template>\n<script>\nexport default {\n  name: 'Dialog',\n  props: {\n    // 是否显示弹框\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    // 弹框标题\n    title: {\n      type: String,\n      default: ''\n    },\n    // 弹框宽度\n    width: {\n      type: String,\n      default: '50%'\n    },\n    // Dialog 的自定义类名\n    customClass: {\n      type: String,\n      default: ''\n    },\n    // 标题是否居中\n    center: {\n      type: Boolean,\n      default: true\n    },\n    // 弹框是否全屏显示\n    fullscreen: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    /**\n     * 打开弹窗回调\n     * */\n    openDialog() {\n      console.log('你打开了弹窗')\n      this.$emit('openDialog')\n    },\n    /**\n     * 关闭弹窗回调\n     * */\n    closeDialog() {\n      this.$emit('closeDialog', false)\n      console.log('你关闭了弹窗')\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"scss\">\n::v-deep .el-dialog__header{\n  height: 5vh;\n  box-sizing: border-box;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n</style>\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `Dialog` 组件来创建一个新的对话框。以下是 `Dialog` 组件的属性：\n\n- `visible`：是否显示对话框。默认值为 `false`。\n- `title`：对话框的标题。默认值为 `''`。\n- `width`：对话框的宽度。默认值为 `'50%'`。\n- `customClass`：对话框的自定义类名。默认值为 `''`。\n- `center`：标题是否居中。默认值为 `true`。\n- `fullscreen`：对话框是否全屏显示。默认值为 `false`。\n\n`Dialog` 组件还包含以下方法：\n\n- `openDialog`：打开对话框时的回调函数。你可以监听 `openDialog` 事件来执行自定义的逻辑。\n- `closeDialog`：关闭对话框时的回调函数。你可以监听 `closeDialog` 事件来执行自定义的逻辑。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `Dialog` 组件的示例：\n\n```js\n<template>\n  <div>\n    <button @click=\"visible = true\">Open Dialog</button>\n    <Dialog :visible=\"visible\" @closeDialog=\"visible = false\">\n      <template v-slot:title>\n        <h2>Dialog Title</h2>\n      </template>\n      <template v-slot:content>\n        <p>Dialog Content</p>\n      </template>\n      <template v-slot:footer>\n        <button @click=\"visible = false\">Close Dialog</button>\n      </template>\n    </Dialog>\n  </div>\n</template>\n\n<script>\nimport Dialog from './Dialog'\n\nexport default {\n  components: {\n    Dialog\n  },\n  data() {\n    return {\n      visible: false\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，当你点击 “Open Dialog” 按钮时，对话框会打开。当你点击 “Close Dialog” 按钮时，对话框会关闭。\n# 封装el-table表格组件+el-pagination分页组件\n## 代码\n\nTablePagination 是一个包含表格和分页功能的 Vue 组件。代码如下。\n```js\n<template>\n  <div>\n    <!-- 表格组件 -->\n    <el-table max-height=\"maxHeight\" height=\"auto\" :data=\"tableData\" :style=\"{ width: width }\">\n      <!-- 动态生成表格列 -->\n      <el-table-column\n        v-for=\"(item, index) in columns\"\n        :key=\"index\"\n        :prop=\"item.prop\"\n        :label=\"item.label\"\n      >\n      </el-table-column>\n    <!-- 自定义插槽用于表格内容 -->\n    <slot name=\"table\"></slot>\n    </el-table>\n    <!-- 分页组件 -->\n    <el-pagination\n      @size-change=\"handleSizeChange\"\n      @current-change=\"handleCurrentChange\"\n      :current-page=\"currentPage\"\n      :page-sizes=\"[10, 20, 30, 40]\"\n      :page-size=\"pageSize\"\n      layout=\"total, sizes, prev, pager, next, jumper\"\n      :total=\"total\"\n    >\n    </el-pagination>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"TablePagination\",\n  props: {\n    // 表格数据\n    tableData: {\n      type: Array,\n      default: () => [],\n    },\n    // 表格列配置\n    columns: {\n      type: Array,\n      default: () => [],\n    },\n    // 当前页码\n    currentPage: {\n      type: Number,\n      default: 1,\n    },\n    // 每页显示数量\n    pageSize: {\n      type: Number,\n      default: 10,\n    },\n    // 总数据量\n    total: {\n      type: Number,\n      default: 0,\n    },\n    // 表格宽度\n    width: {\n      type: Number,\n      default: 0,\n    },\n    // 表格最大高度\n    maxHeight: {\n      type: Number,\n      default: 0,\n    },\n  },\n  methods: {\n    // 处理每页显示数量变化\n    handleSizeChange(val) {\n      this.$emit(\"updatePageSize\", val);\n    },\n    // 处理当前页码变化\n    handleCurrentChange(val) {\n      this.$emit(\"updateCurrentPage\", val);\n    },\n  },\n};\n</script>\n<style lang=\"scss\">\n.el-pagination {\n  margin-top: 20px;\n  text-align: right;\n}\n</style>\n```\n\n## Props\n\n- `tableData` (Array): 表格数据，默认为空数组。\n- `columns` (Array): 表格列配置，默认为空数组。\n- `currentPage` (Number): 当前页码，默认为 1。\n- `pageSize` (Number): 每页显示数量，默认为 10。\n- `total` (Number): 总数据量，默认为 0。\n- `width` (Number): 表格宽度，默认为 0。\n- `maxHeight` (Number): 表格最大高度，默认为 0。\n\n## Events\n\n- `updatePageSize`: 当每页显示数量变化时触发，参数为新的每页显示数量。\n- `updateCurrentPage`: 当当前页码变化时触发，参数为新的当前页码。\n\n## 使用示例(模拟后端)\n\n```js\n<template>\n  <div>\n    <!-- 使用TablePagination组件 -->\n    <TablePagination\n      :table-data=\"tableData\"\n      :columns=\"tableColumns\"\n      :current-page=\"currentPage\"\n      :page-size=\"pageSize\"\n      :total=\"total\"\n      :width=\"800\"\n      :max-height=\"400\"\n      @update-page-size=\"handlePageSizeChange\"\n      @update-current-page=\"handleCurrentPageChange\"\n    >\n      <!-- 自定义表格内容插槽 -->\n     <template v-slot:table>\n      <el-table-column label=\"操作\" align=\"center\" width=\"170\">\n            <template slot-scope=\"scope\">\n              <el-button\n                type=\"primary\"\n                @click=\"handleEdit(scope.$index, scope.row)\"\n              >修改\n              </el-button>\n              <el-popconfirm\n                title=\"确定删除这一项吗？\"\n                style=\"margin-left: 10px\"\n                @onConfirm=\"handleDelete(scope.$index, scope.row)\"\n              >\n                <el-button\n                  slot=\"reference\"\n                  type=\"danger\"\n                >删除\n                </el-button>\n              </el-popconfirm>\n\n            </template>\n          </el-table-column>\n      </template>\n    </TablePagination>\n  </div>\n</template>\n\n<script>\n// 引入axios\nimport axios from 'axios';\nimport TablePagination from './TablePagination'; // 请根据实际文件路径修改\n\nexport default {\n  data() {\n    return {\n      tableData: [],       // 存储表格数据\n      tableColumns: [],    // 存储表格列配置\n      currentPage: 1,      // 当前页码\n      pageSize: 10,        // 每页显示数量\n      total: 0,            // 总数据量\n    };\n  },\n  created() {\n    // 在组件创建时调用获取表格数据的方法\n    this.fetchTableData();\n  },\n  methods: {\n    // 使用axios模拟后端获取表格数据\n    fetchTableData() {\n      // 模拟后端数据接口\n      const apiUrl = 'https://jsonplaceholder.typicode.com/posts'; // 请根据实际接口地址修改\n\n      // 使用axios发送GET请求\n      axios.get(apiUrl, {\n        params: {\n          _page: this.currentPage,   // 当前页码\n          _limit: this.pageSize,     // 每页显示数量\n        },\n      })\n      .then(response => {\n        // 成功获取数据后更新表格数据和总数据量\n        this.tableData = response.data;\n        this.total = parseInt(response.headers['x-total-count']);\n      })\n      .catch(error => {\n        console.error('获取表格数据失败', error);\n      });\n    },\n    // 处理每页显示数量变化\n    handlePageSizeChange(newPageSize) {\n      this.pageSize = newPageSize;\n      this.fetchTableData(); // 每页显示数量变化时重新获取数据\n    },\n    // 处理当前页码变化\n    handleCurrentPageChange(newCurrentPage) {\n      this.currentPage = newCurrentPage;\n      this.fetchTableData(); // 当前页码变化时重新获取数据\n    },\n    // 处理编辑操作\n    handleEdit(index, row) {\n      // 在这里可以添加编辑的逻辑，例如跳转到编辑页面或弹出编辑框\n      console.log('编辑操作', index, row);\n    },\n\n    // 处理删除操作\n    handleDelete(index, row) {\n      // 在这里可以添加删除的逻辑，例如弹出确认框后执行删除操作\n      console.log('删除操作', index, row);\n\n      // 模拟删除后更新表格数据\n      this.tableData.splice(index, 1);\n\n      // 如果需要通知后端执行删除操作，可以在此处添加相应的axios请求\n      // 例如，删除某项记录的接口为 '/api/deleteItem'\n      // axios.delete('/api/deleteItem', { data: { id: row.id } })\n      //   .then(response => {\n      //     console.log('删除成功', response);\n      //     // 成功后刷新表格数据等操作\n      //   })\n      //   .catch(error => {\n      //     console.error('删除失败', error);\n      //     // 失败后的处理\n      //   });\n    },\n  },\n  components: {\n    TablePagination,  // 注册TablePagination组件\n  },\n};\n</script>\n\n<style scoped>\n/* 可以添加组件内部的样式 */\n</style>\n```",
      "id": 11
    },
    {
      "name": "vue2+动态表单生成设计(根据后端返回显示对应表单)",
      "type": "vue",
      "recommendationIndex": 4,
      "content": "这是一个使用 `DynamicForms` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `DynamicForms` 组件。\n\n## 代码\n\n```js\n<template>\n  <div v-if=\"Object.keys(args).length\">\n    <div v-for=\"(item, index) in dynamicComponentParameters\" :key=\"index\">\n      <el-form-item v-if=\"item.type === 'el-input'\" :label=\"item.name\">\n        <el-input v-model=\"args[item.val]\" />\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-select'\" :label=\"item.name\">\n        <el-select v-model=\"args[item.val]\" :placeholder=\"item.placeholder\">\n          <el-option\n            v-for=\"selectVal of item.selectList\"\n            :key=\"selectVal.label\"\n            :label=\"selectVal.label\"\n            :value=\"selectVal.value\"\n          />\n        </el-select>\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-checkbox'\" :label=\"item.name\">\n        <el-checkbox-group v-model=\"args[item.val]\">\n          <el-checkbox\n            v-for=\"checkVal of item.checkList\"\n            :key=\"checkVal.label\"\n            :label=\"checkVal.label\"\n          />\n        </el-checkbox-group>\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-radio'\" :label=\"item.name\">\n        <el-radio-group v-model=\"args[item.val]\">\n          <el-radio\n            v-for=\"radioVal of item.radioList\"\n            :key=\"radioVal.label\"\n            :label=\"radioVal.label\"\n          />\n        </el-radio-group>\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-input-number'\" :label=\"item.name\">\n        <el-input-number v-model=\"args[item.val]\" :step=\"item.step\" :min=\"item.min\" :max=\"item.max\" />\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-switch'\" :label=\"item.name\">\n        <el-switch v-model=\"args[item.val]\" />\n      </el-form-item>\n    </div>\n  </div>\n</template>\n<script>\nimport { Loading } from 'element-ui'\n\nexport default {\n  name: 'DynamicForms',\n  props: {\n    // 动态组件列表\n    dynamicComponentParameters: {\n      type: Array,\n      default() {\n        return []\n      }\n    },\n    // 动态组件绑定后传值的参数\n    // eslint-disable-next-line vue/require-default-prop\n    args: {\n      type: Object,\n      default() {\n        return {}\n      }\n    }\n  },\n  data() {\n    return {\n      // 默认参数值\n      defaultValues: {\n        'string': '',\n        'number': 0,\n        'boolean': false,\n        'array': [],\n        'object': {},\n        'function': function() {\n        }\n      },\n      // 加载状态\n      loadingInstance: null\n    }\n  },\n  computed: {\n    // 参数默认值列表\n    argList() {\n      // eslint-disable-next-line vue/no-async-in-computed-properties\n      return new Promise((resolve, reject) => {\n        this.loadingInstance = Loading.service({\n          fullscreen: true,\n          text: '加载中,请稍等....'\n        })\n        // 模拟接口异步\n        setTimeout(() => {\n          const argList = this.dynamicComponentParameters.map(item => {\n            return {\n              name: item.val,\n              type: item.valType\n            }\n          })\n          resolve(argList)\n        }, 1000)\n      })\n    },\n    // 更新后的ages参数\n    newArgs() {\n      const args = this.args\n      // eslint-disable-next-line vue/no-async-in-computed-properties\n      this.argList.then(res => {\n        res.forEach(list => {\n          console.log(this.defaultValues[list.type])\n          this.$set(args, list.name, this.defaultValues[list.type])\n        })\n        this.loadingInstance.close()\n      })\n      return args\n    }\n  },\n  mounted() {\n    this.init()\n  },\n  methods: {\n    init() {\n      /**\n       * 初始化的时候给动态组件绑定后传值的参数赋默认值\n       * 可根据后端传值的类型和字段赋默认值\n       * */\n      this.$emit('update:args', this.newArgs)\n      console.log(this.args.length)\n    }\n  }\n}\n</script>\n<style scoped lang=\"scss\">\n\n</style>\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `DynamicForms` 组件来创建一个动态表单。以下是 `DynamicForms` 组件的属性：\n\n- `dynamicComponentParameters`：动态组件列表，数组类型，默认值为 `[]`。每个元素是一个对象，包含以下属性：\n  - `type`：组件类型，例如 `'el-input'`、`'el-select'` 等。\n  - `name`：组件的标签。\n  - `val`：组件的值，将绑定到 `args` 对象的对应属性上。\n  - `selectList`、`checkList`、`radioList`：当组件类型为 `'el-select'`、`'el-checkbox'` 或 `'el-radio'` 时，这些属性包含了选项列表。\n  - `step`、`min`、`max`：当组件类型为 `'el-input-number'` 时，这些属性用于设置数字输入框的步长、最小值和最大值。\n\n- `args`：动态组件绑定后传值的参数，对象类型，默认值为 `{}`。对象的每个属性对应一个动态组件，属性名为组件的 `val`，属性值为组件的值。\n\n`DynamicForms` 组件还包含以下方法：\n\n- `init`：初始化的时候给动态组件绑定后传值的参数赋默认值，可根据后端传值的类型和字段赋默认值。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `DynamicForms` 组件的示例：\n\n```js\n<template>\n  <div>\n    <dynamic-forms\n              :args.sync=\"algorithmInfo.args\"\n              :dynamic-component-parameters=\"dynamicComponentParameters\"\n            />\n  </div>\n</template>\n\n<script>\nimport DynamicForms from './DynamicForms'\n\nexport default {\n  components: {\n    DynamicForms\n  },\n  data() {\n    return {\n      // 动态组件参数\n      dynamicComponentParameters: [\n        {\n          type: 'el-input', // 表单类型\n          name: '名字', // 表单标题\n          val: 'name', // 表单传给后端值的参数名\n          valType: 'string'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-select', // 表单类型\n          name: '性别', // 表单标题\n          selectList: [\n            {\n              label: '男',\n              value: 'man'\n            },\n            {\n              label: '女',\n              value: 'woman'\n            }\n          ], // 若为选择框则需要提供selectList列表，表示下拉选项\n          val: 'gender', // 表单传给后端值的参数名\n          placeholder: '请选择性别',\n          valType: 'string'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-checkbox', // 表单类型\n          name: '兴趣', // 表单标题\n          checkList: [\n            {\n              label: '篮球'\n            },\n            {\n              label: '足球'\n            }\n          ], // 若为单选框则需要提供checklist列表，表示选项\n          val: 'interest', // 表单传给后端值的参数名\n          valType: 'array'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-radio', // 表单类型\n          name: '活动', // 表单标题\n          radioList: [\n            {\n              label: '活动1'\n            },\n            {\n              label: '活动2'\n            }\n          ], // 若为单选框则需要提供radioList列表，表示选项\n          val: 'activity', // 表单传给后端值的参数名\n          valType: 'string'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-input-number', // 表单类型\n          name: '年龄', // 表单标题\n          min: 1, // 最小值\n          max: 100, // 最大值\n          step: 0.1, // 按钮控制步数\n          val: 'age', // 表单传给后端值的参数名\n          valType: 'string'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-switch', // 表单类型\n          name: '参加', // 表单标题\n          val: 'attend', // 表单传给后端值的参数名\n          valType: 'boolean'// 表单传给后端值的参数类型\n        }\n      ],\n      // 算法信息\n      algorithmInfo: {\n        // 算法名称\n        name: '',\n        group: '',\n        type: '',\n        args: {}\n      },\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，你需要提供你的动态组件参数列表 `dynamicComponentParameters` 和动态组件绑定后传值的参数 `args`。",
      "id": 12
    },
    {
      "id": 13,
      "type": "vue",
      "recommendationIndex": 4,
      "name": "vue2播放hls视频流)",
      "content": "这是一个使用 `HLSPlay` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `HLSPlay` 组件。\n\n## 下载\n\n```js\nnpm install vue-video-player@5.0.2\nnpm install videojs-contrib-hls@5.14.1\n```\n\n## 代码\n\n```js\n<template>\n  <section class=\"HLSPlay-component\">\n    <video-player\n      ref=\"videoPlayer\"\n      class=\"video-player-box\"\n      :options=\"playerOptions\"\n      :playsinline=\"true\"\n      custom-event-name=\"customstatechangedeventname\"\n    />\n  </section>\n</template>\n<script>\nimport 'video.js/dist/video-js.css'\nimport 'videojs-contrib-hls'\nimport { videoPlayer } from 'vue-video-player'\n\nexport default {\n  name: 'HLSPlay',\n  components: {\n    videoPlayer\n  },\n  props: {\n    // eslint-disable-next-line vue/require-default-prop\n    src: {\n      type: String\n    },\n    // eslint-disable-next-line vue/prop-name-casing,vue/require-default-prop\n    cover_url: {\n      type: String\n    }\n  },\n  data() {\n    return {\n      playerOptions: {\n        autoplay: true,\n        muted: true,\n        preload: '63:25',\n        language: 'zh-CN',\n        fluid: true,\n        // playbackRates: [0.7, 1.0, 1.5, 2.0],\n        sources: [\n          {\n            type: 'application/x-mpegURL',\n            src: this.src // 路径\n            // src: 'https://cdn.theguardian.tv/webM/2015/07/20/150716YesMen_synd_768k_vp8.webm'\n          }\n        ],\n        poster: this.cover_url, // 你的封面地址\n        notSupportedMessage: '此视频暂无法播放，请稍后再试'\n        // controlBar: {\n        //   timeDivider: true,\n        //   durationDisplay: true,\n        //   remainingTimeDisplay: false,\n        //   fullscreenToggle: true, // 全屏按钮\n        //   currentTimeDisplay: true, // 当前时间\n        //   volumeControl: false, // 声音控制键\n        //   playToggle: false, // 暂停和播放键\n        //   // progressControl: true // 进度条\n        // }\n      }\n    }\n  },\n  computed: {\n    player() {\n      return this.$refs.videoPlayer.player\n    }\n  },\n  mounted() {\n    // this.play()\n    // console.log('this is current player instance object', this.player)\n  },\n  beforeDestroy() {\n    this.player && this.player.dispose()\n  },\n  methods: {\n    setSrc(src) {\n      this.player.src({ src: src, type: 'application/x-mpegURL' })\n    },\n    play() {\n      try {\n        this.$nextTick(() => {\n          this.player.play().then(res => {\n            this.$message('获取视频成功')\n          }).catch(e => {\n            console.log(e, '失败')\n          }) // 播放\n        })\n      } catch (e) {\n        console.log(e)\n      }\n      // 手动触发播放\n    }\n  }\n\n}\n</script>\n<style lang=\"scss\" scoped>\n.HLSPlay-component{\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  ::v-deep.video-player-box{\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    #vjs_video_1{\n      height: 100%;\n    }\n   #vjs_video_3 {\n      height: inherit;\n      padding-top: 36.25% !important;\n    }\n  }\n}\n::v-deep.video-player {\n  //.vjs_video_3-dimensions {\n  //  width: 100%;\n  //  height: 96%;\n  //}\n\n  // 初始化，暂停按钮居中\n  .vjs-big-play-button {\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n\n  .video-js .vjs-tech {\n    object-fit: fill;\n    height: 100%;\n  }\n  .vjs-fluid{\n    padding-top: 2vw !important;\n    height: inherit;\n  }\n}\n</style>\n\n\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `HLSPlay` 组件来创建一个 HLS 视频播放器。以下是 `HLSPlay` 组件的属性：\n\n- `src`：视频源的 URL，字符串类型。\n- `cover_url`：视频封面的 URL，字符串类型。\n\n`HLSPlay` 组件还包含以下方法：\n\n- `setSrc(src)`：设置新的视频源。\n- `play()`：播放视频。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `HLSPlay` 组件的示例：\n\n```vue\n<template>\n  <div>\n    <HLSPlay :src=\"videoSrc\" :cover_url=\"coverUrl\" ref=\"hlsPlayer\" />\n    <button @click=\"changeVideo\">Change Video</button>\n  </div>\n</template>\n\n<script>\nimport HLSPlay from './HLSPlay'\n\nexport default {\n  components: {\n    HLSPlay\n  },\n  data() {\n    return {\n      videoSrc: 'https://path/to/your/video.m3u8',\n      coverUrl: 'https://path/to/your/cover.jpg'\n    }\n  },\n  methods: {\n    changeVideo() {\n      this.videoSrc = 'https://path/to/another/video.m3u8'\n      this.$refs.hlsPlayer.setSrc(this.videoSrc)\n      this.$refs.hlsPlayer.play()\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，`HLSPlay` 组件用于播放一个 HLS 视频。当你点击 “Change Video” 按钮时，视频源会被更改，新的视频会开始播放。希望这个文档能对你有所帮助！"
    },
    {
      "name": "闭包",
      "id": 14,
      "type": "js",
      "recommendationIndex": 5,
      "content": "闭包 让私有变量变成全局变量 一般写法都是a函数里面return一个b函数 从而让a函数里面的变量变为全局变量 也就是每次调用a函数 里面的变量就不会初始化 而是继续保留上次的值 原理是一个函数只要在调用 那么它所在的环境不会被销毁 闭包正是因为返回一个b函数 当这个函数被调用 那么它所在的a函数里面的环境就不会被销毁 从而得就让私有变量变成全局变量"
    },
    {
      "name": "this",
      "type": "js",
      "recommendationIndex": 4,
      "content": "在JavaScript中，`this`关键字是一个特殊的变量，它在函数被调用时自动定义。`this`的值取决于函数如何被调用，而不是函数如何被定义或者在哪里被定义。\n\n以下是`this`在不同情况下的值：\n\n1. **全局作用域或函数外部**：在全局作用域或函数外部，`this`指向全局对象。在浏览器中，全局对象是`window`。\n\n```javascript\nconsole.log(this); // 输出: Window {...} (或者全局对象的其他表示)\n```\n\n2. **函数内部**：在函数内部，`this`的值取决于函数如何被调用。如果函数是普通函数调用，`this`通常指向全局对象（在严格模式下，`this`会是`undefined`）。\n\n```javascript\nfunction myFunction() {\n  console.log(this);\n}\nmyFunction(); // 输出: Window {...} (或者全局对象的其他表示)\n```\n\n3. **对象方法中**：当函数作为对象的方法被调用时，`this`指向调用该方法的对象。\n\n```javascript\nlet myObject = {\n  property: 'I am an object!',\n  myMethod: function() {\n    console.log(this);\n  }\n};\nmyObject.myMethod(); // 输出: myObject\n```\n\n4. **构造函数中**：在构造函数中，`this`指向新创建的对象实例。\n\n```javascript\nfunction MyConstructor() {\n  this.property = 'I am a new object!';\n}\nlet myObject = new MyConstructor();\nconsole.log(myObject.property); // 输出: 'I am a new object!'\n```\n\n5. **事件处理函数中**：在事件处理函数中，`this`通常指向触发事件的元素。\n\n```javascript\nbutton.addEventListener('click', function() {\n  console.log(this); // 输出: <button> element\n});\n```\n\n6. **箭头函数中**：箭头函数不绑定自己的`this`，它会捕获其所在（即定义的位置）上下文的`this`值。\n\n```javascript\nlet myObject = {\n  myMethod: function() {\n    console.log(this); // 输出: myObject\n    let arrowFunction = () => {\n      console.log(this); // 输出: myObject\n    };\n    arrowFunction();\n  }\n};\nmyObject.myMethod();\n```\n\n7. **使用call, apply, bind方法调用/绑定**：`call`，`apply`和`bind`方法可以用来改变函数调用时`this`的指向。\n\n```javascript\nfunction myFunction() {\n  console.log(this);\n}\nlet myObject = {property: 'I am an object!'};\nmyFunction.call(myObject); // 输出: myObject\n```\n`call`, `apply` 和 `bind` 是JavaScript中的函数方法，它们都可以改变函数的`this`指向。\n\n1. ***call方法***：`call`方法可以改变函数的`this`指向，并立即执行这个函数。`call`方法的第一个参数是`this`应该指向的对象，其余参数是传递给函数的参数。\n\n```javascript\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\n\nlet person = {name: 'Alice'};\ngreet.call(person, 'Hello', '!'); // 输出: 'Hello, Alice!'\n```\n\n2. ***apply方法***：`apply`方法和`call`方法非常相似，也可以改变函数的`this`指向，并立即执行这个函数。不同的是，`apply`方法的第二个参数是一个数组，这个数组的元素会作为参数传递给函数。\n\n```javascript\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\n\nlet person = {name: 'Alice'};\ngreet.apply(person, ['Hello', '!']); // 输出: 'Hello, Alice!'\n```\n\n3. ***bind方法***：`bind`方法可以改变函数的`this`指向，但不会立即执行这个函数，而是返回一个新的函数。这个新的函数在被调用时，`this`会指向`bind`方法的第一个参数。\n\n```javascript\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\n\nlet person = {name: 'Alice'};\nlet greetAlice = greet.bind(person, 'Hello', '!');\ngreetAlice(); // 输出: 'Hello, Alice!'\n```\n\n以上就是`call`, `apply`, `bind`方法的基本用法和行为。理解这些方法是理解JavaScript中函数调用和面向对象编程的关键。\n以上就是`this`在JavaScript中的一些基本用法和行为。理解`this`的行为是理解JavaScript中函数调用和面向对象编程的关键。",
      "id": 15
    },
    {
      "name": "js同步和异步执行机制",
      "id": 16,
      "type": "js",
      "recommendationIndex": 5,
      "content": "首先判断js代码是同步还是异步,同步就进入主进程,异步就进入event table\n异步任务在event table中注册函数,当满足触发条件后,被推入event queue\n同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中\n以上三步循环执行,这就是event loop\n\n既然js是单线程，那就像只有一个窗口的食堂，学生需要排队一个一个打饭，同理js任务也要一个一个顺序执行。这种模式执行简单，但随着日后的需求，事务，请求增多，这种单线程模式执行效率必定低下。只要有一个任务执行消耗了很长时间，在这个时间里后面的任务无法执行。\n\n常见的有新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？为了解决这个问题，**JavaScript语言将任务执行模式分成同步和异步：**\n\n- **同步模式：** 就是上面所说的一种执行模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。\n- **异步模式：** 就是每一个任务有一个或多个回调函数（`callback`），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\nhttps://img.jbzj.com/file_images/article/202109/2021924162932253.png?2021824162952\n\n**导图要表达的内容用文字来表述的话：**\n\n- \n\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入`Event Table`并注册函数。\n- 当指定的事情完成时，`Event Table`会将这个函数移入`Event Queue`。\n- 主线程内的任务执行完毕为空，会去`Event Queue`读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的`Event Loop`(事件循环)。\n\n **再配上代码表达：**\n```javascriptlet data = [];\n$.ajax({\n    url:blog.csdn.net,\n    data:data,\n    success:() => {\n        console.log('发送成功!');\n    }\n})\nconsole.log('代码执行结束');\n```\n**上面是一段简易的ajax请求代码：**\n\n- `ajax`进入`Event Table`，注册回调函数`success`。\n- 执行`console.log`('代码执行结束')。\n- ajax事件完成，回调函数`success`进入`Event Queue`。\n- 主线程从`Event Queue`读取回调函数`success`并执行。\n\n\n\n\n```javascript\nsetTimeout(()=>{\n\n  console.log(111);\n\n  },0)\n\n  new Promise((*resolve*, *reject*) => {\n\n  console.log(222);\n\n  setTimeout(() => {\n\n    console.log(333);\n\n  }, 0);\n\n  resolve(444);\n\n  }).then(*res*=>{\n\n  console.log(res);\n\n  })\n\n  console.log(555);\n```\n\n  /* js执行顺序是同步>微任务队列>宏任务队列，首先同步任务先执行222和555，\n\n  然后promise是微任务队列,这个时候js主线程任务已经执行完毕,开始把微任务队列中的\n\n  任务添加到主线程继续执行，所以输出555，最后定时器是宏任务队列，所以\n\n  最后执行111和333\n\n  js运行，代码刚开始就是定时器，我们首先把定时器加入event table中，注册好里面的回调函数，同时被推入入event queue(任务队列)，等待主线程执行完后，此时，就回去任务队列查找是否有可执行的异步任务，有就推到主线程执行，这个过程的循环执行，就是event loop[事件循环\n\n  */"
    },
    {
      "name": "js原型和原型链",
      "id": 17,
      "type": "js",
      "recommendationIndex": 5,
      "content": "所有对象和函数数组等都有__proto__属性，他指向了其构造函数的protoType对象属性,如对象的构造函数就是new Object(),一般我们会把公共方法存入原型之中，这样方便在实例化对象使用方法时指向同一个内存地址，不要要每实例化一个对象就新开辟一个内存空间用来存放方法，同时__proto__和protoType都有constructor属性，他就是指向构造函数本身，故而，点开constructor属性，里面也会有protoType属性和__proto__等。注意，Object已经是最高层级的构造函数了，原型链也在这为起点。"
    },
    {
      "name": "js代码运行过程以及函数运行过程以及闭包",
      "id": 18,
      "type": "js",
      "recommendationIndex": 5,
      "content": "全局代码执行顺序\n\n想要弄懂函数的执行过程，就必须知道全局代码是怎么执行的\n\n函数的执行过程与全局代码执行过程非常相似，这也是设计的js不同于其他语言地方之一\n\n代码执行之前\n\n当全局代码执行之前，v8引擎会在堆内存中开辟一块空间叫GO（看补充），GO中有很多默认的属性(环境属性)，比如Date、String、window等等，还有我们声明的函数和用var定义的变量，那么他们默认是什么值呢？这划分为简单数据类型和复杂数据类型：\n\n简单数据类型默认值是undefined\n\n复杂数据类型默认值是一块地址：如果发现是复杂数据类型，v8就会在堆中另开辟一块空间，GO中的相应变量指向该空间（所以复杂数据类型存在深浅拷贝问题）\n\n函数也会创建一块空间，暂且叫它函数空间\n\n2. v8又会帮我们在栈中创建一个GEC(看补充)，GEC又包含两部分：\n\nGEC部分一：VO(看补充)，VO是一个虚拟对象并且指向GO，VO中也包含很多属性(环境属性)，比如this、父级作用域等等\n\nGEC部分二：代码执行体，就是一行行的代码\n\n注意：这些都是在代码具体执行之前就完成的，就是说这些东西在执行之前就会被确定\n\n全局代码执行\n\n执行一行行代码，当执行到为变量初始化或赋值时，就对应将GO中属性的值覆盖掉......\n\n补充：执行用到的变量都是通过VO往GO里找并操作\n\n函数执行过程\n\n在全局代码执行过程中遇到函数加小括号调用，会发生什么呢？\n\n会分为函数的具体代码执行之前和代码具体执行和执行完毕三部分\n\n函数代码执行之前\n\n当执行到‘函数()’的时候，前面说过会在GO找到对应的属性，发现属性值是一块空间(函数空间)，v8就会在堆中另外开辟一块独属于本次引用的空间AO(看补充)，此AO与GO作用相似，也会在执行代码之前做本作用域中的预解析（为简单数据类型和复杂数据类型分别做不同初始化），另外在执行栈中创建FEC(看补充)，同样的 FEC和GEC作用也相似，也分为两部分：\n\nFEC部分一：VO，虚拟对象指向AO，包含父级作用域等等\n\nFEC部分二：代码执行体\n\n函数代码执行\n\n执行一行行代码，当执行到为变量初始化或赋值时，就对应将AO中属性的值覆盖掉......\n\nQ：但是，如果发现一个属性在AO中找不到怎么办？\n\nA：在上面说过，VO中包含父级作用域，父级作用域在代码执行之前就会被确定，所以自然而然往父级作用域里找，父级作用域指向的是父级的VO，这样一层一层直到GO，如果还是找不到，返回undefined\n\n函数执行完毕\n\n函数执行完毕会把本函数的FEC弹出执行栈\n\n如果发现没有变量再指向函数空间，也会在堆中销毁该函数空间\n\n闭包原理\n\n// 示例代码 /* 1 */ var function foo() { /* 2 */ var num = 10 /* 3 */ return function bar() { /* 4 */ console.log(num) // 10 /* 5 */ } /* 6 */ } /* 7 */ /* 8 */ var fn = foo() /* 9 */ fn() /*10 */ \n\n全局预解析（看全局代码执行顺序）......\n\n第8行，调用foo（看函数执行过程）......\n\n第5行，通过VO将foo的AO的num改成10\n\n第3行，返回一个函数bar，函数不能被‘直接返回’，返回的是foo的AO的属性bar存的地址\n\n第8行，给fn初始化，值是一块地址，此时GO里的fn指向的就是bar的函数地址\n\n第9行，调用fn，从GO里面找到fn，发现是一块函数地址，进行创建VO和AO等操作......\n\n第4行，打印num，发现num并不存在当前AO中，通过父级作用域找foo的AO，返回num\n\n原因原理：因为全局的fn指向bar，bar的父级作用域又指向foo的AO，所以不管fn、foo、bar都不会被销毁，尽管fn、foo、bar都执行完毕，这样就会造成内存泄漏\n\n补充\n\nGEC：Global Execution Context 全局执行上下文\n\n存在并一直存在执行栈中，直到script代码执行完毕，包含执行前和执行两部分：\n\n执行前，创建VO指向GO\n\n执行一行行代码\n\nFEC：Function Execution Content 函数执行上下文\n\n在函数被调用代码执行之前被创建，包含执行前和执行两部分：\n\n执行前，创建VO指向AO\n\n执行一行行代码\n\nGO：Globel Object 全局对象\n\n存在于最根层，由V8引擎在代码执行之前创建在堆空间中，默认存在一些属性：Date、Math等等，还包含个特殊属性window指向GO本身，默认属性还包含我们定义的函数和var声明的变量\n\n在创建的时候会根据数据类型决定默认值，并且为复杂类型开辟内存\n\nAO：Activation Object\n\n在函数调用代码执行之前被创建，里面默认存在一些属性：传递来的参数、var声明的变量、定义的函数\n\n创建的时候也会根据数据类型不同决定默认值，并且为复杂类型开辟内存\n\nVO：Variable Object\n\n像是AO或GO的傀儡，也是代码执行之前被创建在执行上下文中并指向创建它的那一块空间，或许是AO或许是GO。包含this，包含scoped chain(作用域链): scoped(当前作用域)、scoped parent(父级作用域)等等\n\n补充：\n\n看到好多的文章都把VO省略掉了，但其实在代码执行过程中不能直接访问AO或GO，只能通过VO间接访问，可以理解为VO==AO或VO==GO，但VO是切实存在的\n\n每个函数都有属于自己的AO、VO、FEC\n\nA回答：\n\n在全局代码执行之前，V8会创建GO，并会判断你声明的变量的数据类型，为其添加默认值或为其在内存中开辟空间，发现定义一个函数就会开辟一块空间。这块空间是在代码执行之前创建的，所以当执行函数时，就会从GO或AO里面找到那一块空间\n\nJS内存垃圾回收(GC)的机制是从根开始找，某块空间没有再被指向的时会被销毁。上段代码为例，GO的fn指向bar(函数空间)，bar的父级作用域指向GO的foo的AO\n\n引申：那怎么解决闭包引起的内存泄露呢？手动更改fn的值或直接指向null"
    },
    {
      "id": 19,
      "type": "js",
      "name": "Set和Map",
      "recommendationIndex": 5,
      "content": "# 1、什么是Set()\n\nSet是[es6](https://so.csdn.net/so/search?q=es6&spm=1001.2101.3001.7020)新增的数据结构，**似于数组**，但它的一大特性就是**所有元素都是唯一的**，没有重复的值，我们一般称为集合。\n\nSet本身是一个构造函数，用来生成 Set 数据结构\n\n# 2、增删改查方法\n\n###### 2.1 添加元素`add`\n\n添加某个值，返回 Set 结构本身，当添加实例中已经存在的元素，set不会进行处理添加\n\n```js\nlet list=new Set();\nlist.add(1)\nlist.add(2).add(3).add(3)   // 2只被添加了一次\n123\n```\n\n###### 2.2 删除元素 `delete`\n\n删除某个值，返回一个布尔值，表示删除是否成功\n\n```js\nlet list=new Set([1,20,30,40])\nlist.delete(30)      //删除值为30的元素，这里的30并非下标\n12\n```\n\n###### 2.3 判断某元素是否存在`has`\n\n返回一个布尔值，判断该值是否为Set的成员\n\n```js\nlet list=new Set([1,2,3,4])\nlist.has(2)//true\n12\n```\n\n###### 2.4 清除所有元素`clear`\n\n清除所有成员，没有返回值\n\n```js\nlet list=new Set([1,2,3,4])\nlist.clear()\n12\n```\n\n# 3、遍历方法\n\n###### 3.1 遍历 `keys()`\n\n返回键名的遍历器，相等于返回键值遍历器values()\n\n```js\nlet list2=new Set(['a','b','c'])\nfor(let key of list2.keys()){\n   console.log(key)//a,b,c\n}\n1234\n```\n\n###### 3.2 遍历 `values()`\n\n返回键值的遍历器\n\n```js\nlet list=new Set(['a','b','c'])\nfor(let value of list.values()){\nconsole.log(value)//a,b,c\n}\n1234\n```\n\n###### 3.3 遍历 `entries()`\n\n返回键值对的遍历器\n\n```js\nlet list=new Set(['4','5','hello'])\nfor (let item of list.entries()) {\n  console.log(item);\n}\n// ['4','4']   ['5','5']   ['hello','hello'] \n12345\n```\n\n###### 3.4 遍历 `forEach()`\n\n使用回调函数遍历每个成员\n\n```js\nlet list=new Set(['4','5','hello'])\nlist.forEach((value, key) => console.log(key + ' : ' + value))\n// 4:4    5:5   hello:hello\n123\n```\n\n# 4、使用情形\n\n###### 4.1 用于[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)去重\n\n```js\nlet arr = [3, 5, 2, 2, 5, 5];\nlet setArr = new Set(arr)     // 返回set数据结构  Set(3) {3, 5, 2}\n\n//方法一   es6的...解构\nlet unique1 =  [...setArr ];      //去重转数组后  [3,5,2]\n\n//方法二  Array.from()解析类数组为数组\nlet unique2 = Array.from(setArr )   //去重转数组后  [3,5,2]\n12345678\n```\n\n###### 4.2 用于字符串去重\n\n```js\nlet str = \"352255\";\nlet unique = [...new Set(str)].join(\"\");     // 352 \n12\n```\n\n###### 4.3 实现并集、交集、和差集\n\n```js\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// （a 相对于 b 的）差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n\n# 1、Map是什么\n\nMap类型是**键值对的有序列表**，而`键和值都可以是任意类型`\n\n#### Map与Set的区别\n\n- Set是一种叫做[集合](https://so.csdn.net/so/search?q=集合&spm=1001.2101.3001.7020)的数据结构，Map是一种叫做字典的数据结构\n\n  > 集合-----是由一堆无序的、相关联的，且不重复的[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)结构【数学中称为元素】组成的组合\n  > 字典-----是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同\n\n- Set集合是以[值，值]的形式存储元素，\n  Map字典是以[键，值]的形式存储\n\n# 2、增删改查\n\n###### 2.1 `size`\n\nsize属性返回 Map 结构的成员总数。\n\n```js\nconst map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n12345\n```\n\n###### 2.2 `set()`\n\n设置键名key对应的键值为value，然后返回整个 Map 结构\n\n如果key已经有值，则键值会被更新，否则就新生成该键\n\n同时返回的是当前Map对象，可采用链式写法\n\n```js\nconst m = new Map();\nlet fn = function(){}\n\nm.set('edition', 6)        // 键是字符串\nm.set(fn, 'standard')     // 键是函数\nm.set(undefined, 'nah')    // 键是 undefined\nm.set(1, 'a').set(2, 'b').set(3, 'c') // 链式操作\n1234567\n```\n\n###### 2.3 `get()`\n\nget方法读取key对应的键值，如果找不到key，返回undefined\n\n```js\nconst m = new Map();\n\nconst hello = function() {console.log('hello');};\nm.set(hello, 'Hello ES6!') // 键是函数\n\nm.get(hello)  // Hello ES6!\n123456\n```\n\n###### 2.4 `has()`\n\nhas方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\n\n```js\nconst m = new Map();\n\nm.set('edition', 6);\nm.set(262, 'standard');\nm.set(undefined, 'nah');\n\nm.has('edition')     // true\nm.has('years')       // false\nm.has(undefined)     // true\n123456789\n```\n\n###### 2.4 `delete()`\n\ndelete方法删除某个键，返回true。如果删除失败，返回false\n\n```js\nconst m = new Map();\nm.set(undefined, 'nah');\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n123456\n```\n\n###### 2.5 `clear()`\n\nclear方法清除所有成员，没有返回值\n\n```js\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n1234567\n```\n\n# 3、遍历\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回所有成员的遍历器\n- forEach()：遍历 Map 的所有成员\n\n```js\nconst map = new Map([\n  ['F', 'no'],\n  ['T',  'yes'],\n]);\n\n//keys()\nfor (let key of map.keys()) {\n  console.log(key);       // \"F\"  \"T\"\n}\n\n//values()\nfor (let value of map.values()) {\n  console.log(value);    // \"no\"  \"yes\"\n}\n\n// entries()\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"F\" \"no\"  、\"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"F\" \"no\" 、\"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"  、 \"T\" \"yes\"\n\nmap.forEach(function(value, key, map) {\n  console.log(key, value);    // \"F\" \"no\"  、 \"T\" \"yes\"\n});\n```"
    },
    {
      "id": 20,
      "type": "js",
      "name": "两个数组求交集，并集和差集",
      "recommendationIndex": 5,
      "content": "```js\n//数组普通值\nlet a = [1, 2, 3, 4, 5, 10]\nlet b = [2, 3, 4, 5]\n//求交集\nlet c = [...new Set(a.filter(item => new Set(b).has(item)))]\n// console.log(c);\n//求并集\nlet d = [...new Set([].concat(a).concat(b))]\n//求差集\nlet e = [...new Set(a.filter(item => !new Set(b).has(item)))]\nconsole.log(e);\n\n//数组对象值\n// 形如如下数组\nlet arr1 = [], arr2 = [];\narr1 = [\n  {\n    ID: 1,\n    Name: 1,\n    desc: 'Number'\n  },\n  {\n    ID: 2,\n    Name: 2,\n    desc: 'Number'\n  },\n  {\n    ID: 3,\n    Name: 3,\n    desc: 'Number'\n  },\n  {\n    ID: 4,\n    Name: 4,\n    desc: 'Number'\n  },\n  {\n    ID: 5,\n    Name: 5,\n    desc: 'Number'\n  }\n]\narr2 = [\n  {\n    ID: 5,\n    Name: 5,\n    desc: 'Number'\n  },\n  {\n    ID: 6,\n    Name: 6,\n    desc: 'Number'\n  },\n  {\n    ID: 7,\n    Name: 7,\n    desc: 'Number'\n  },\n  {\n    ID: 8,\n    Name: 8,\n    desc: 'Number'\n  },\n  {\n    ID: 9,\n    Name: 9,\n    desc: 'Number'\n  }\n]\n\n// 交集\nlet intersection = []\nfor (let i = 0, len = arr1.length; i < len; i++) {\n  for (let j = 0, length = arr2.length; j < length; j++) {\n    if (arr1[i].ID === arr2[j].ID) {\n      intersection.push(arr1[i])\n    }\n  }\n}\nconsole.log('交集', intersection)\n\n// 并集\nlet union = [...arr1, ...arr2]\nfor (let i = 0, len = arr1.length; i < len; i++) {\n  for (let j = 0, length = arr2.length; j < length; j++) {\n    if (arr1[i].ID === arr2[j].ID) {\n      union.splice(union.findIndex(item => item.ID === arr1[i].ID), 1)\n    }\n  }\n}\nconsole.log('并集', union)\n\n// 补集\nlet complement = [...arr1, ...arr2]\nfor (let i = 0, len = arr1.length; i < len; i++) {\n  for (let j = 0, length = arr2.length; j < length; j++) {\n    if (arr1[i].ID === arr2[j].ID) {\n      complement.splice(complement.findIndex(item => item.ID === arr1[i].ID), 1)\n      complement.splice(complement.findIndex(item => item.ID === arr2[j].ID), 1)\n    }\n  }\n}\nconsole.log('补集', complement)\n\n// 差集\nlet diff = [...arr1]\nfor (let i = 0, len = arr1.length; i < len; i++) {\n  let flag = false\n  for (let j = 0, length = arr2.length; j < length; j++) {\n    if (arr1[i].ID === arr2[j].ID) {\n      flag = true\n    }\n  }\n  if (flag) {\n    diff.splice(diff.findIndex(item => item.ID === arr1[i].ID), 1)\n  }\n}\nconsole.log('差集', diff)\n```"
    },
    {
      "id": 21,
      "type": "js",
      "name": "数组去重",
      "recommendationIndex": 5,
      "content": "```js\n//数组对象去重\nlet a = [{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }, { id: 4, name: 'd' }, { id: 1, name: 'a' }]\nlet map = new Map();\nfor (let item of a) {\nlet key=Object.values(item).reduce((pre, nex) => {\nreturn pre+nex\n})\nmap.set(key,item)\n}\n// console.log(map);\na = [...map.values()];\nconsole.log(a)\n//数组普通值去重\nlet e = [1, 1, 1, 2, 2]\nlet f = [...new Set(e)]\nconsole.log(f);\n```"
    },
    {
      "name": "部分数组方法",
      "type": "js",
      "recommendationIndex": 5,
      "content": "# 1 forEach遍历\n\nforEach(function(value,index,array))\n\nvalue:数组中的每一个值\n\nindex:数组中的每一个索引号\n\narray:数组本身\n\n```js\n    var arr = [1, 2, 3, 4, 5，6]\n    arr.forEach((value, index, array) => {\n      console.log(`数组中的每个值${value},对应的索引号${index},整个数组为${array}`);\n    })\n```\n\n\n# 2 filter 过滤筛选数组\n\nfilter(function(value,index,array))返回一个新数组\n\n```js\n    var arr = [1, 2, 3, 4, 5]\n    var newArr = arr.filter((value) => {\n      return value > 2\n    })\n    console.log(newArr);\n```\n\n\n# 3 some 有满足条件的元素返回true\n\nsome(function(value,index,array))返回值为布尔值，找到满足条件的就为true，(找到第一个满足条件的就终止循环)\n\n```js\n    var arr = [1, 2, 3, 4, 5]\n    var newArr = arr.some((value) => {\n      return value == 2\n    })\n    console.log(newArr);// true\n```\n\n\n\n# 4 every 所有元素满足条件返回true\n\nevery(function(value,index,array))返回值为布尔值，所有元素满足条件的就为true\n\n```js\n    var arr = [1, 2, 3, 4, 5]\n    var flag = arr.every((value) => {\n      return value > 0\n    })\n    var flags = arr.every((value) => {\n      return value > 1\n    })\n    console.log(flag);// true\n    console.log(flags);// false\n```\n\n# 5 map 返回一个新数组\n\nmap(function(value,index,array))返回值为新数组，数组中的元素为原始数组元素调用函数处理后的值\n\n```js\n    var arr = [1, 2, 3, 4, 5]\n    var newArr = arr.map((value) => {\n      return value * 2\n    })\n    console.log(newArr);//[2,4,6,8,10]\n```\n\n# 6 find 找出第一个符合条件的数组成员\n\nfind(function(value,index,array))返回值为满足条件的数组成员\n\n```js\n    const arr = [{\n      id: 1,\n      name: 'zpf'\n    }, {\n      id: 2,\n      name: 'zzz'\n    }]\n    const a = arr.find(value => value.id)\n    const b = arr.find(value => value.id == 11)\n    console.log(a);// {id:1,name:'zpf'}\n    console.log(b);// undefined\n```\n\n# 7 findIndex 找到第一个符合条件的数组成员的索引值\n\nfindIndex(function(value,index,array))返回值为满足条件的数组成员的索引值 找不到为-1\n\n```js\n    const arr = [{\n      id: 1,\n      name: 'zpf'\n    }, {\n      id: 2,\n      name: 'zzz'\n    }]\n    const a = arr.findIndex(value => value.id)\n    const b = arr.findIndex(value => value.id == 11)\n    console.log(a);// 0\n    console.log(b);// -1\n```\n\n# 8 includes() 数组中是否包含给定的值 包含返回true 不包含false\n\n```js\n    console.log([1, 2, 3].includes(3, -1));// 搜索值3 起始位置倒数第一个-1 true\n    console.log([1, 2, 3].includes(4));// false\n    console.log([1, 2, 3].includes(1, 2, 3, 4));//false\n    console.log([1, 2, 3].includes(1, 2, 4));//false\n```",
      "id": 22
    },
    {
      "id": 23,
      "type": "js",
      "name": "时间戳转化为年月日时分秒",
      "recommendationIndex": 4,
      "content": "```js\ntimestampToTime(time) {\n      if (!time) {\n        return\n      }\n      let date = new Date(time)\n      let len = time.toString().length;\n      if (len < 13) {\n        let sub = 13 - len;\n        sub = Math.pow(10, sub);\n        date = new Date(time * sub);\n      }\n      let y = date.getFullYear() + '-';\n      let M = date.getMonth() + 1;\n      M = (M < 10 ? '0' + M : M) + '-';\n      let d = date.getDate();\n      d = (d < 10 ? '0' + d : d) + ' ';\n      return y + M + d;\n    },\n```\n\n"
    },
    {
      "id": 24,
      "type": "js",
      "name": "标准时间转化为年月日时分秒",
      "recommendationIndex": 4,
      "content": "```js\nformatTime(time, fmt) {\n  if (!time) return '';\n  else {\n    const date = new Date(time);\n    const o = {\n      'M+': date.getMonth() + 1,\n      'd+': date.getDate(),\n      'H+': date.getHours(),\n      'm+': date.getMinutes(),\n      's+': date.getSeconds(),\n      'q+': Math.floor((date.getMonth() + 3) / 3),\n      S: date.getMilliseconds(),\n    };\n    if (/(y+)/.test(fmt))\n      fmt = fmt.replace(\n        RegExp.$1,\n        (date.getFullYear() + '').substr(4 - RegExp.$1.length)\n      );\n    for (const k in o) {\n      if (new RegExp('(' + k + ')').test(fmt)) {\n        fmt = fmt.replace(\n          RegExp.$1,\n          RegExp.$1.length === 1\n            ? o[k]\n            : ('00' + o[k]).substr(('' + o[k]).length)\n        );\n      }\n    }\n    return fmt;\n  }\n}\n//formatTime(new Date(), \"yyyyMMddHHmmss\")\n```"
    },
    {
      "id": 25,
      "type": "js",
      "name": "函数的节流与防抖",
      "recommendationIndex": 5,
      "content": "## 防抖函数：将多次触发变成最后一次触发；\n\n```js\nfunction debounce(fn,wait){\n  let timer = null;\n  return function (){\n    let arg = arguments;\n    if(timer){\n      clearTimeout(timer);\n      timer = null;\n    }\n    timer = setTimeout(()=>{\n       fn.apply(this,arg)\n    },wait)\n  }\n}\nfunction clg(){\n  console.log('clg')\n}\nwindow.addEventListener('resize',debounce(clg,1000))\n```\n\n ## 节流函数：将多次执行变成每隔一个时间节点去执行的函数\n\n```js\nfunction throttle(fn,time){\n  let lastTime = null;\n  return function(){\n    let nowTime = Date.now();\n    if(nowTime - lastTime > time || !lastTime){\n      fn();\n      last = nowTime\n    }\n  }\n}\nfunction sayHi(){\n  console.log('hi')\n}\nsetInterval(throttle(sayHi,1000),500)\n```"
    },
    {
      "id": 26,
      "type": "js",
      "name": "监听网页行为",
      "recommendationIndex": 4,
      "content": "监听网页行为（如是否调用某个接口）\n\n```js\nconst observer = new PerformanceObserver(_ => {\n\t\tif (performance.getEntriesByName(\"接口ip\")\n\t\t\t.length >\n\t\t\t0) {\n\t\t\tconsole.log('网页调用该接口')\n\t\t}\n\n\t});\n\tobserver.observe({\n\t\tentryTypes: [\"resource\"]\n\t})\n```"
    },
    {
      "name": "修改浏览器默认滚动条样式",
      "type": "css",
      "recommendationIndex": 5,
      "content": "```css\n// 滚动条整体部分\n&::-webkit-scrollbar {\n  width: 6px;\n  height: 6px;\n}\n// 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。\n&::-webkit-scrollbar-button {\n  display: none;\n}\n// 滚动条的轨道（里面装有Thumb）\n&::-webkit-scrollbar-track {\n  background: transparent;\n}\n// 滚动条的轨道（里面装有Thumb）\n&::-webkit-scrollbar-track-piece {\n  background-color: transparent;\n}\n// 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）\n&::-webkit-scrollbar-thumb {\n  background: #007cd6;\n  cursor: pointer;\n  border-radius: 4px;\n}\n// 边角，即两个滚动条的交汇处\n&::-webkit-scrollbar-corner {\n  display: none;\n}\n// 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件\n&::-webkit-resizer {\n  display: none;\n}\n```",
      "id": 27
    },
    {
      "name": "组件",
      "type": "component",
      "recommendationIndex": 5,
      "content": "# 1.前端实用组件\n\n## 1.1 [vue无缝滚动组件 vue2 ](https://chenxuan0000.github.io/vue-seamless-scroll/)  [vue3](https://doc.wssio.com/opensource/vue3-seamless-scroll/#%E5%BC%80%E5%A7%8B)\n\n要想让他实现无缝滚动，首先看你页面的滚动内容高度是多少，比如是500px,在不滚动的时候看多少行数据占满这个高度，假设需要10行数据显示在页面上，那么每行的高度需要设置为大于500/10=50px,这样才可以实现无缝滚动，一般就设置为50px,通过class-option中的属性limitMoveNum判断是否滚动，比如这里就可以设置为10，超出10行意味着滚动，小于等于就不滚动\n\n```vue\n<template>\n  <div id=\"jobStatistics\">\n    <el-row :gutter=\"10\" type=\"flex\" align=\"middle\" style=\"height: 75%\">\n      <el-col :span=\"18\" style=\"height: 100%;border:1px solid black\">\n        <table>\n          <!-- 设置列宽 -->\n          <colgroup>\n            <col v-for=\"item of 2\" width=\"10%\">\n            <col width=\"18%\">\n            <col width=\"10%\">\n            <col width=\"12%\">\n            <col v-for=\"item of 4\" width=\"10%\">\n          </colgroup>\n          <thead>\n          <th v-for=\"item in tableName\">{{item}}</th>\n          </thead>\n        </table>\n        <vue-seamless-scroll :data=\"testArray\" :class-option=\"optionHover\" class=\"seamless-warp\">\n          <ul>\n            <li v-for=\"(item,index) in testArray\" class=\"liStyle\" :class=\"{ bg: index%2===0 }\">\n              <span :title=\"index+1\" class=\"title1 text_align\">{{ index + 1 }}</span>\n              <span :title=\"item.name\" class=\"title1 text_align\">{{ item.name }}</span>\n              <span :title=\"item.age\" class=\"title2 text_align\">{{ item.age }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title3 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n            </li>\n          </ul>\n        </vue-seamless-scroll>\n      </el-col>\n    </el-row>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"jobStatistics\",\n  data() {\n    return {\n      //表格表头名称\n      tableName:['序号','作业区域','作业内容','就业人员','现场负责人','部门','进入时间','离开时间','现场图像'],\n      testArray: [\n        {name: '刘明明', age: 14, phone: '15876512321'},\n        {name: '王五五', age: 15, phone: '15876512321'},\n        {name: '张萌萌', age: 23, phone: '15876512321'},\n        {name: '刘浩', age: 20, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '1587651232313121'},\n      ],\n    };\n  },\n  computed: {\n    //滚动表格的配置项\n    optionHover() {\n      return {\n        limitMoveNum:10,//数据超出10行才滚动\n        hoverStop: true, // 是否开启鼠标悬停stop\n        direction: 1, // 0向下 1向上 2向左 3向右\n        step: .5,// 数值越大速度滚动越快\n        openWatch: true, // 开启数据实时监控刷新dom\n      }\n    }\n  },\n};\n</script>\n<style lang=\"less\">\n#jobStatistics{\n  height:100%;\n}\n* {\n  margin: 0;\n  padding: 0;\n}\n\nul {\n  list-style: none;\n}\n\ntable {\n  width: 100%;\n  text-align: center;\n}\n\nth {\n  height: 260%;\n  line-height: 260%;\n  font-size: 16px;\n  background-color: rgba(180, 181, 198, 0.1);\n}\n\n.seamless-warp {\n  height: 90%;\n  overflow: hidden;\n\n  .liStyle {\n    height: 45.5px;\n    line-height: 45.5px;\n    width: 100%;\n    display: flex;\n    overflow: hidden;\n\n    .title1 {\n      width: 10%;\n    }\n\n    .title2 {\n      width: 18%;\n    }\n\n    .title3 {\n      width: 12%;\n    }\n\n    .text_align {\n      text-align: center;\n      overflow: hidden;\n      white-space: nowrap;\n      text-overflow: ellipsis;\n    }\n\n  }\n}\n.bg{\n  background: gainsboro;\n}\n</style>\n```\n\n## 1.2 [vue-cropper裁剪图片插件](https://github.com/xyxiao001/vue-cropper)\n## 1.3 [自定义表格](https://vxetable.cn/#/table/start/install)\n## 1.4 [Vue 字符串实现JSON格式显示 ](https://github.com/chenfengjw163/vue-json-viewer/blob/master/README_CN.md)\n+ 请注意 复制功能按钮显示不出请添加如下样式代码\n以scss为例子\n```js\n::v-deep .jv-button{\n  &::after{\n    width: 20px;\n    height: 20px;\n    content: '复制';\n    display: inline-block;\n    position: fixed;\n  }\n}\n```\n## 1.5 [移动端vue手势库](https://github.com/gggso/vue-finger)\n## 1.6 [搭建虚拟服务器调用接口](https://github.com/typicode/json-server)\n### 简介\njson-server 是一款小巧的接口模拟工具，一分钟内就能搭建一套 Restful 风格的 API，尤其适合前端接口测试使用。🔥🔥🔥\n只需指定一个 json 文件作为 api 的数据源即可，使用起来非常方便，30 秒入门，基本上有手就行。👍\n进阶操作还支持分页，排序等操作，简直强大。💪\n\n### 开源地址\n主页地址：https://www.npmjs.com/package/json-server\nGithub项目地址：https://github.com/typicode/json-server\n\n### 30秒入门\n#### 环境依赖\n安装 Node.js 环境即可\n#### 操作步骤\n安装 JSON 服务器\n```js \nnpm install -g json-server\n```\n创建一个db.json包含一些数据的文件\n```js\n{\n  \"posts\": [\n    { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }\n  ],\n  \"comments\": [\n    { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\n  ],\n  \"profile\": { \"name\": \"typicode\" }\n}\n```\n启动 json-server 接口服务器\n#### 快速创建\njson-server db.json\n\n#### 配置参数\n```js \njson-server db.json --watch --port 3000\n```\n浏览器访问 http://localhost:3000/posts/1，你会得到\n```js\n{ \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }\n```\n🎉恭喜你，已经完成 json-server 快速搭建，熟练使用的话 30 秒即可完成服务器搭建⏰。\n#### 补充\n如果您发出 POST、PUT、PATCH 或 DELETE 请求，更改将自动安全地保存到 db.json 文件中。\n路由进阶\n根据之前的db.json文件，这里是所有的默认路由。\n\n##### 路由形式一\n```js\nGET    /posts\nGET    /posts/1\nPOST   /posts\nPUT    /posts/1\nPATCH  /posts/1\nDELETE /posts/1\n```\n##### 路由形式二\n```js\nGET    /profile\nPOST   /profile\nPUT    /profile\nPATCH  /profile\n```\n##### 筛选\n使用 . 访问筛选\n```js\nGET /posts?title=json-server&author=typicode\nGET /posts?id=1&id=2\nGET /comments?author.name=typicode\n```\n##### 分页\n使用_page和可选地_limit对返回的数据进行分页。\n\n在Link标题，你会得到first，prev，next和last链接。\n\n```js\nGET /posts?_page=7\nGET /posts?_page=7&_limit=20\n```\n默认返回10项\n\n##### 排序\n添加_sort和_order（默认升序）\n\n```js\nGET /posts?_sort=views&_order=asc\nGET /posts/1/comments?_sort=votes&_order=asc\n```\n对于多个字段，请使用以下格式：\n\n```js\nGET /posts?_sort=user,views&_order=desc,asc\n```\n##### 切片(分页)\n添加_start和_end或_limit\n\n```js\nGET /posts?_start=20&_end=30\nGET /posts/1/comments?_start=20&_end=30\nGET /posts/1/comments?_start=20&_limit=10\n```\n与Array.slice完全一样工作（即_start开始_end结束）\n\n##### 特殊符号\n添加_gte或_lte获取范围\n\n```js\nGET /posts?views_gte=10&views_lte=20\n```\n##### 添加_ne以排除值\n\n```js\nGET /posts?id_ne=1\n```\n##### 添加_like到过滤器（支持正则表达式）\n\n```js\nGET /posts?title_like=server\n```\n##### 全文搜索\n添加 q\n\n```\nGET /posts?q=internet\n```\n##### 关系\n要包含子资源，请添加 _embed\n\n```js\nGET /posts?_embed=comments\nGET /posts/1?_embed=comments\n```\n要包含父资源，请添加 _expand\n\n```js\nGET /comments?_expand=post\nGET /comments/1?_expand=post\n```\n##### 获取或创建嵌套资源（默认为一级）\n\n```js\nGET  /posts/1/comments\nPOST /posts/1/comments\n```\n##### 数据库\n```js\nGET /db\n```\n##### 主页\n返回默认索引文件或服务./public目录\n\n```js\nGET /\n```\n#### 附加功能\n##### 静态文件服务器\n您可以使用 JSON Server 为您的 HTML、JS 和 CSS 提供服务，只需创建一个./public目录或用于--static设置不同的静态文件目录。\n\n```js\nmkdir public\necho 'hello world' > public/index.html\njson-server db.json\njson-server db.json --static ./some-other-dir\n```\n##### 替换端口\n您可以使用以下--port标志在其他端口上启动 JSON Server ：\n```js\n$ json-server --watch db.json --port 3004\n```\n##### 支持跨域\n您可以使用 CORS 和 JSONP 从任何地方访问您模拟的 API 接口。\n\n##### 远程模式\n您可以加载远程模式。\n```js\n$ json-server http://example.com/file.json\n$ json-server http://jsonplaceholder.typicode.com/db\n```\n##### 生成随机数据\n使用 JS 而不是 JSON 文件，您可以通过编程方式创建数据。\n```js\n// index.js\nmodule.exports = () => {\n  const data = { users: [] }\n  // 创建 1000 个用户信息\n  for (let i = 0; i < 1000; i++) {\n    data.users.push({ id: i, name: `user${i}` })\n  }\n  return data\n}\n```\n```js\n$ json-server index.js\n```\n提示：使用Faker、Casual、Chance或JSON Schema Faker 等模块。\n\n#### 添加自定义路由\n创建一个routes.json文件。注意每条路线都以/.\n```js\n{\n  \"/api/*\": \"/$1\",\n  \"/:resource/:id/show\": \"/:resource/:id\",\n  \"/posts/:category\": \"/posts?category=:category\",\n  \"/articles\\\\?id=:id\": \"/posts/:id\"\n}\n```\n使用--routes选项启动 JSON 服务器。\n\njson-server db.json --routes routes.json\n现在您可以使用其他路线访问资源。\n```js\n/api/posts # → /posts\n/api/posts/1  # → /posts/1\n/posts/1/show # → /posts/1\n/posts/javascript # → /posts?category=javascript\n/articles?id=1 # → /posts/1\n```\n##### 添加中间件\n您可以使用以下--middlewares选项从 CLI 添加中间件：\n```js\n// hello.js\nmodule.exports = (req, res, next) => {\n  res.header('X-Hello', 'World')\n  next()\n}\n```\n```js\njson-server db.json --middlewares ./hello.js\njson-server db.json --middlewares ./first.js ./second.js\n```\n##### 命令行使用\n```js\njson-server [options] <source>\n\nOptions:\n  --config, -c       Path to config file           [default: \"json-server.json\"]\n  --port, -p         Set port                                    [default: 3000]\n  --host, -H         Set host                             [default: \"localhost\"]\n  --watch, -w        Watch file(s)                                     [boolean]\n  --routes, -r       Path to routes file\n  --middlewares, -m  Paths to middleware files                           [array]\n  --static, -s       Set static files directory\n  --read-only, --ro  Allow only GET requests                           [boolean]\n  --no-cors, --nc    Disable Cross-Origin Resource Sharing             [boolean]\n  --no-gzip, --ng    Disable GZIP Content-Encoding                     [boolean]\n  --snapshots, -S    Set snapshots directory                      [default: \".\"]\n  --delay, -d        Add delay to responses (ms)\n  --id, -i           Set database id property (e.g. _id)         [default: \"id\"]\n  --foreignKeySuffix, --fks  Set foreign key suffix, (e.g. _id as in post_id)\n                                                                 [default: \"Id\"]\n  --quiet, -q        Suppress log messages from output                 [boolean]\n  --help, -h         Show help                                         [boolean]\n  --version, -v      Show version number                               [boolean]\n\nExamples:\n  json-server db.json\n  json-server file.js\n  json-server http://example.com/db.json\n```\nhttps://github.com/typicode/json-server\n您还可以在json-server.json配置文件中设置选项。\n```js\n{\n  \"port\": 3000\n}\n```\n#### 模块\n如果您需要添加身份验证、验证或任何行为，您可以将项目作为模块与其他 Express 中间件结合使用。\n\n简单的例子\n```js\n$ npm install json-server --save-dev\n```\n```js\n// server.js\nconst jsonServer = require('json-server')\nconst server = jsonServer.create()\nconst router = jsonServer.router('db.json')\nconst middlewares = jsonServer.defaults()\n\nserver.use(middlewares)\nserver.use(router)\nserver.listen(3000, () => {\n  console.log('JSON Server is running')\n})\n```\n```js\n$ node server.js\n```\n您提供给jsonServer.router函数的路径是相对于您启动节点进程的目录的。如果从另一个目录运行上述代码，最好使用绝对路径：\n```js\nconst path = require('path')\nconst router = jsonServer.router(path.join(__dirname, 'db.json'))\n```\n对于内存数据库，只需将对象传递给jsonServer.router().\n\n另请注意，jsonServer.router()它可用于现有的 Express 项目。\n\n##### 自定义路由示例\n假设您想要一个回显查询参数的路由和另一个在创建的每个资源上设置时间戳的路由。\n```js\nconst jsonServer = require('json-server')\nconst server = jsonServer.create()\nconst router = jsonServer.router('db.json')\nconst middlewares = jsonServer.defaults()\n// 设置默认中间件（记录器、静态、cors 和无缓存）\nserver.use(middlewares)\n\n// 写在自定义路由之前\nserver.get('/echo', (req, res) => {\n  res.jsonp(req.query)\n})\n\n// 要处理 POST、PUT 和 PATCH，您需要使用 body-parser\n// 您可以使用 JSON Server\nserver.use(jsonServer.bodyParser)\nserver.use((req, res, next) => {\n  if (req.method === 'POST') {\n    req.body.createdAt = Date.now()\n  }\n  // 继续到 JSON Server 路由器\n  next()\n})\n\n// 使用默认路由器\nserver.use(router)\nserver.listen(3000, () => {\n  console.log('JSON Server is running')\n})\n访问控制示例\nconst jsonServer = require('json-server')\nconst server = jsonServer.create()\nconst router = jsonServer.router('db.json')\nconst middlewares = jsonServer.defaults()\n\nserver.use(middlewares)\nserver.use((req, res, next) => {\n if (isAuthorized(req)) { // 在此处添加您的授权逻辑\n   next() // 继续到 JSON Server 路由器\n } else {\n   res.sendStatus(401)\n }\n})\nserver.use(router)\nserver.listen(3000, () => {\n  console.log('JSON Server is running')\n})\n```\n##### 自定义输出示例\n要修改响应，请覆盖router.render方法：\n```js\n// 在这个例子中，返回的资源将被包装在一个 body 属性\nrouter.render = (req, res) => {\n  res.jsonp({\n    body: res.locals.data\n  })\n}\n```\n您可以为响应设置自己的状态代码：\n```js\n// 在这个例子中，我们模拟了一个服务器端错误响应\nrouter.render = (req, res) => {\n  res.status(500).jsonp({\n    error: \"error message here\"\n  })\n}\n```\n##### 重写器示例\n要添加重写规则，请使用jsonServer.rewriter()：\n```js\n// 写在 server.use(router) 之前\nserver.use(jsonServer.rewriter({\n  '/api/*': '/$1',\n  '/blog/:resource/:id/show': '/:resource/:id'\n}))\n```\n在另一个端点上挂载 JSON 服务器示例\n或者，您也可以将路由器安装在/api.\n```js\nserver.use('/api', router)\n```\nAPI\n```js\njsonServer.create()\n```\n\n返回一个 Express 服务器。\n```js\njsonServer.defaults([options])\n```\n\n返回 JSON 服务器使用的中间件。\n\n##### 选项\n```js\nstatic 静态文件的路径\nlogger 启用记录器中间件（默认值：true）\nbodyParser 启用 body-parser 中间件（默认值：true）\nnoCors 禁用 CORS（默认值：false）\nreadOnly 只接受 GET 请求（默认值：false）\njsonServer.router([path|object])\n```\n返回 JSON 服务器路由器。\n## 1.7 [vue大屏自适应组件](https://github.com/Alfred-Skyblue/v-scale-screen)\n## 1.8 [下载文件组件](https://github.com/kennethjiang/js-file-download)\n## 1.9 [vue编辑预览md组件](https://code-farmer-i.github.io/vue-markdown-editor/zh/)",
      "id": 28
    },
    {
      "id": 29,
      "type": "uniapp",
      "name": "uniapp存储文件和读取文件",
      "recommendationIndex": 3,
      "content": "# 一、读取本地文件\n\n```js\n        // 读取本地文件的方法 参数1为文件名称，参数2为回调方法用于处理获取到的文件数据\n\t\tfetchFileData(fileName,callback) {\n\t\t\tplus.io.requestFileSystem(\n\t\t\t\tplus.io.PUBLIC_DOWNLOADS, // 文件系统中的根目录\n\t\t\t\tfs => {\n\t\t\t\t\t// 创建或打开文件, fs.root是根目录操作对象,直接fs表示当前操作对象\n\t\t\t\t\tfs.root.getFile(fileName, {\n\t\t\t\t\t\tcreate: true // 文件不存在则创建\n\t\t\t\t\t}, fileEntry => {\n\t\t\t\t\t\t// 文件在手机中的路径\n\t\t\t\t\t\tconsole.log('文件在手机中的路径', fileEntry.fullPath)\n\t\t\t\t\t\tfileEntry.file(function(file) {\n\t\t\t\t\t\t\tvar fileReader = new plus.io.FileReader();\n\t\t\t\t\t\t\tconsole.log(\"getFile:\" + JSON.stringify(file));\n\t\t\t\t\t\t\tfileReader.readAsText(file, \"utf-8\")\n\t\t\t\t\t\t\tfileReader.onloadend = function(res) { //读取文件内容成功后的回调事件\n\t\t\t\t\t\t\t\t//res.target.result读取到的文件内容信息\n\t\t\t\t\t\t\t\tconsole.log('最后读取文件内容是=======', res.target.result)\n\t\t\t\t\t\t\t\tcallback(res.target.result)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}, e => {\n\t\t\t\t\t\tconsole.log('报错111', \"getFile failed: \" + e.message);\n\t\t\t\t\t});\n\t\t\t\t},\n \n\t\t\t\te => {\n\t\t\t\t\tconsole.log('报错222', e.message);\n\t\t\t\t}\n\t\t\t);\n\t\t},\n```\n\n# 二、存储数据到本地文件\n\n```js\n// 参数1为文件名称 参数2是文件内容 参数3是回调参数\t\t\nsaveFile(fileName,fileInfo,callback) {\n\t\t\t// 请求本地文件系统对象\n\t\t\tplus.io.requestFileSystem(\n\t\t\t\tplus.io.PUBLIC_DOWNLOADS, // 文件系统中的根目录\n\t\t\t\tfs => {\n\t\t\t\t\t// 创建或打开文件, fs.root是根目录操作对象,直接fs表示当前操作对象\n\t\t\t\t\tfs.root.getFile(fileName, {\n\t\t\t\t\t\tcreate: true // 文件不存在则创建\n\t\t\t\t\t}, fileEntry => {\n\t\t\t\t\t\t// 文件在手机中的路径\n\t\t\t\t\t\tconsole.log('最后文件在手机中的路径========', fileEntry.fullPath)\n\t\t\t\t\t\tfileEntry.createWriter(writer => {\n\t\t\t\t\t\t\t// 写入文件成功完成的回调函数\n\t\t\t\t\t\t\twriter.onwrite = e => {\n\t\t\t\t\t\t\t\tconsole.log(\"写入数据成功\");\n\t\t\t\t\t\t\t\tcallback(true)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// 写入数据\n\t\t\t\t\t\t\twriter.write(JSON.stringify(fileInfo));\n\t\t\t\t\t\t})\n\t\t\t\t\t}, e => {\n\t\t\t\t\t\tcallback(false)\n\t\t\t\t\t\tconsole.log('报错111', \"getFile failed: \" + e.message);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\tconsole.log('报错222', e.message);\n\t\t\t\t\tcallback(false)\n\t\t\t\t}\n\t\t\t);\n\t\t},\n```\n\n "
    },
    {
      "id": 30,
      "type": "ai",
      "name": "ai工具合集",
      "recommendationIndex": 5,
      "content": "# [chatgpt](https://chat.openai.com/chat):人工智能ai聊天工具\n\n# [newbing](https://www.bing.com/search?q=Bing+AI&showconv=1&FORM=hpcodx):结合chatgpt+微软搜索引擎的新一代智能对话\n\n# [cursor](https://www.cursor.so/):结合chatgpt+编程工具的最新智能IDE\n\n# [闪击ppt](https://ppt.sankki.com/#/works):结合chatgpt生成文本，然后快速生成ppt的工具\n\n```\n我的名字叫做周鹏飞，帮我制作一篇内容为《xxxx》PPT，要求如下： 第一、一定要使用中文。 第二、页面形式有3种，封面、目录、列表、总结。 第三、目录页要列出内容大纲。 第四、根据内容大纲，生成对应的PPT列表页，每一页PPT列表页使用=====列表=====开头。 第五、封面页格式如下： =====封面===== # 主标题 ## 副标题 演讲人：我的名字 第六、目录页格式如下： =====目录===== # 目录 ## CONTENT 1、内容 2、内容 第七、列表页格式如下： =====列表===== # 页面主标题 1、要点1 要点描述内容 第八、列表页里的要点描述内容是对要点的详细描述，10个字以上，50个字以内。第九、最后一个列表为全文总结。第十、至少要求十个列表。 最后，一定要使用代码块回复你生成的内容，切记切记。\n```\n\n\n\n# [discord](https://discord.com/)：全球聊天频道，可在里面和ai绘画智能机器人对话，生成对应图片，还有很多其他功能等待发现\n\n# [未来百科](https://www.futurepedia.io/):ai工具合集\n\n\n\n"
    },
    {
      "name": "vue 自定义弹出菜单",
      "type": "component",
      "recommendationIndex": 5,
      "content": "# 安装\n```js\nnpm install vue-contextmenujs\n```\n# 使用\n```js\nimport Contextmenu from \"vue-contextmenujs\"\nVue.use(Contextmenu);\n```\n# 代码实现\n以element-ui图标为例实现右键菜单，图标会为被渲染为<i class=\"icon\"></i>，代码如下：\n```js\n<template>\n  <div style=\"width:100vw;height:100vh\" @contextmenu.prevent=\"onContextmenu\"></div>\n</template>\n\n<script>\nimport Vue from 'vue'\nimport Contextmenu from \"vue-contextmenujs\"\nVue.use(Contextmenu);\nexport default {\n  methods: {\n    onContextmenu(event) {\n      this.$contextmenu({\n        items: [\n          {\n            label: \"返回(B)\",\n            onClick: () => {\n              this.message = \"返回(B)\";\n              console.log(\"返回(B)\");\n            }\n          },\n          { label: \"前进(F)\", disabled: true },\n          { label: \"重新加载(R)\", divided: true, icon: \"el-icon-refresh\" },\n          { label: \"另存为(A)...\" },\n          { label: \"打印(P)...\", icon: \"el-icon-printer\" },\n          { label: \"投射(C)...\", divided: true },\n          {\n            label: \"使用网页翻译(T)\",\n            divided: true,\n            minWidth: 0,\n            children: [{ label: \"翻译成简体中文\" }, { label: \"翻译成繁体中文\" }]\n          },\n          {\n            label: \"截取网页(R)\",\n            minWidth: 0,\n            children: [\n              {\n                label: \"截取可视化区域\",\n                onClick: () => {\n                  this.message = \"截取可视化区域\";\n                  console.log(\"截取可视化区域\");\n                }\n              },\n              { label: \"截取全屏\" }\n            ]\n          },\n          { label: \"查看网页源代码(V)\", icon: \"el-icon-view\" },\n          { label: \"检查(N)\" }\n        ],\n        event, // 鼠标事件信息\n        customClass: \"custom-class\", // 自定义菜单 class\n        zIndex: 3, // 菜单样式 z-index\n        minWidth: 230 // 主菜单最小宽度\n      });\n      return false;\n    }\n  }\n};\n</script>\n```\n# 自定义样式\n打开控制台，查看元素即可查看到菜单的各个 class 名称。最外层的 class 为上面的customClass属性设置的值，样式可根据需求自行调整。\n```js\n<style>\n.custom-class .menu_item__available:hover,\n.custom-class .menu_item_expand {\n  background: #ffecf2 !important;\n  color: #ff4050 !important;\n}\n</style>\n```\n# 总结\n以上就基本使用方法，是不是比自己封装节省了大把时间。注意菜单会在点击左键或者滚轮滚动时自动销毁，同时也可调用this.$contextmenu.destroy()在其他场景自行销毁 。以下是插件的参数配置：\n## MenuOptions 菜单属性\n![Description](https://github.com/zpfzpf123/images/blob/master/1700101354909.jpg?raw=true)\n## MenuItemOptions 选项属性\n![Description](https://github.com/zpfzpf123/images/blob/master/1700101706614.jpg?raw=true)\n\n",
      "id": 31
    },
    {
      "name": "github api+axios 接口上传github图片",
      "type": "js",
      "recommendationIndex": 5,
      "content": "# 作用\n可在前端实现通过接口把图片上传到对应github仓库\n# 创建token\n1. 访问：https://github.com/settings/tokens ，点击 Generate new token 按钮，创建一个新 Token：\n2. 设置一下过期时间，这里我们选择“不会过期”，然后勾选一下 repo 所有权限：\n3. 接着滚到底下点击生成按钮，会看到 Token 生成完毕：\n# 创建github.js\n```js\nimport axios from 'axios'\nimport { Message } from 'element-ui'\naxios.defaults.timeout = 10000\naxios.interceptors.response.use(response => {\n  return response\n}, (err) => {\n  // 返回状态码不为200时候的错误处理\n  Message.error(err.toString())\n  return Promise.reject(err)\n})\nconst repo = 'zpfzpf123/images' // 填你的仓库 repo\nconst cutToken = 'ghp_lUbD67XeagTCo' // 填你的 Token\nconst tailToken = 'kcXfLOOXA01XYysbz0hGN73'\nconst uploader = async(content, files) => {\n  const path = `${files.name}`\n  // const path = `${content.name}`\n  const imageUrl = 'https://api.github.com/repos/' + repo + '/contents/' + path\n  const body = { message: 'upload', content }\n  const headers = {\n    Authorization: `token ${cutToken}${tailToken}`,\n    // 'Content-Type': 'application/json; charset=utf-8',\n    Accept: 'application/vnd.github.v3+json'\n  }\n  const res = await axios.put(imageUrl, body, { headers })\n  // 直接取得返回的图片地址\n  return res?.content?.download_url\n}\nexport default {\n  uploader\n}\n```\n# 使用示例\n```js\nasync handleUploadImage(event, insertImage, files) {\n      const reader = new FileReader()\n\n      function getBase64(file) {\n        return new Promise((resolve) => {\n          reader.onload = function(event) {\n            const fileContent = event.target.result\n            resolve(fileContent.split(',')[1])\n          }\n          reader.readAsDataURL(file)\n        })\n      }\n\n      const content = await getBase64(files[0])// 目前上传接口支持上传base64格式图片，所以先将不是base6格式的文件流转化成base64,如果是base64格式忽略这一步\n      const loadingInstance = Loading.service({ fullscreen: true, text: '图片上传中...' })\n      const imgUrl = await github.uploader(content, files[0])\n      if (imgUrl) {\n        this.$message.success('上传github成功！！回显由于网络延迟，显示不出来或显示较缓慢属于正常现象')\n        this.$nextTick(() => { // 以服务的方式调用的 Loading 需要异步关闭\n          loadingInstance.close()\n        })\n      }\n      // 此处只做示例\n      insertImage({\n        url: `https://github.com/zpfzpf123/images/blob/master/${files[0].name}?raw=true`,\n        desc: 'files.name'\n        // width: 'auto',\n        // height: 'auto',\n      })\n    },\n```",
      "id": 32
    },
    {
      "name": "检测棚摄像机配置",
      "type": "公司",
      "recommendationIndex": 5,
      "content": "# 1 打开配置工具（批量配置工具）\n# 2 显示未激活页面\n![files.name](https://github.com/zpfzpf123/images/blob/master/image.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n",
      "id": 33
    }
  ],
  "vue": [
    {
      "name": "vue",
      "svg": "vue",
      "id": 0,
      "urlList": [
        {
          "name": "vue2",
          "svg": "vue",
          "id": 0,
          "url": "https://v2.cn.vuejs.org/v2/guide/"
        },
        {
          "name": "router2",
          "svg": "router",
          "url": "https://v3.router.vuejs.org/zh/installation.html"
        },
        {
          "name": "vuex2",
          "svg": "vuex",
          "url": "https://v3.vuex.vuejs.org/zh/"
        },
        {
          "name": "vue3",
          "svg": "vue3",
          "url": "https://pinia.vuejs.org/zh/introduction.html"
        },
        {
          "name": "router3",
          "svg": "router3",
          "url": "https://v3.router.vuejs.org/zh/installation.html"
        },
        {
          "name": "vuex3",
          "svg": "vuex3",
          "url": "https://v3.vuex.vuejs.org/zh/"
        }
      ]
    }
  ],
  "ui": [
    {
      "name": "ui",
      "svg": "UI",
      "id": 1,
      "urlList": [
        {
          "name": "ElementUI",
          "svg": "elementui",
          "url": "https://element.eleme.cn/#/zh-CN/component/installation"
        },
        {
          "name": "iView",
          "svg": "iview",
          "url": "http://v4.iviewui.com/docs/introduce"
        },
        {
          "name": "Ant Design Vue",
          "svg": "antd",
          "url": "https://www.antdv.com/components/overview-cn"
        },
        {
          "name": "DataV",
          "svg": "datav",
          "url": "http://datav.jiaminghi.com/guide/"
        }
      ]
    }
  ],
  "time": [
    {
      "name": "时间",
      "svg": "times",
      "id": 2,
      "urlList": [
        {
          "name": "moment",
          "svg": "moment",
          "url": "http://momentjs.cn/docs/"
        },
        {
          "name": "dayjs",
          "svg": "dayjs",
          "url": "https://dayjs.gitee.io/docs/zh-CN/installation/installation"
        }
      ]
    }
  ],
  "js": [
    {
      "name": "js",
      "svg": "js",
      "id": 3,
      "urlList": [
        {
          "name": "ES6",
          "svg": "ES6",
          "url": "https://es6.ruanyifeng.com/"
        },
        {
          "name": "lodash",
          "svg": "lodash",
          "url": "https://www.lodashjs.com/"
        }
      ]
    }
  ],
  "img": [
    {
      "name": "图标网站",
      "svg": "icon",
      "id": 4,
      "urlList": [
        {
          "name": "阿里巴巴图标库",
          "svg": "alibaba",
          "url": "https://www.iconfont.cn/"
        }
      ]
    }
  ],
  "http": [
    {
      "name": "http",
      "svg": "http",
      "id": 5,
      "urlList": [
        {
          "name": "axios",
          "svg": "axios",
          "url": "https://www.axios-http.cn/docs/intro"
        }
      ]
    }
  ],
  "echarts": [
    {
      "name": "可视化组件库",
      "svg": "可视化",
      "id": 6,
      "urlList": [
        {
          "name": "echart官网",
          "svg": "echart",
          "url": "https://echarts.apache.org/zh/index.html"
        },
        {
          "name": "MCChart",
          "svg": "MCChart",
          "url": "http://echarts.zhangmuchen.top/#/index"
        },
        {
          "name": "chartLib",
          "svg": "chartLib",
          "url": "http://chartlib.datains.cn"
        },
        {
          "name": "ppchart",
          "svg": "ppchart",
          "url": "https://ppchart.com/#/"
        }
      ]
    }
  ],
  "other": [
    {
      "name": "框架",
      "svg": "框架",
      "urlList": [
        {
          "name": "若依",
          "svg": "ruoyi",
          "url": "https://doc.ruoyi.vip/ruoyi/"
        }
      ]
    },
    {
      "name": "人工智能",
      "svg": "ai",
      "id": 7,
      "urlList": [
        {
          "name": "chatgpt",
          "svg": "chatgpt",
          "url": "https://chat.openai.com/"
        },
        {
          "name": "bingChat",
          "svg": "bingChat",
          "url": "https://www.bing.com/search?q=Bing+AI&showconv=1&FORM=hpcodx"
        },
        {
          "name": "bard",
          "svg": "bard",
          "url": "https://bard.google.com/chat"
        }
      ]
    },
    {
      "name": "实用网站",
      "svg": "usefulURLs",
      "urlList": [
        {
          "name": "奶牛快传",
          "svg": "nnkc",
          "url": "https://cowtransfer.com/"
        },
        {
          "name": "百度翻译",
          "svg": "bdfy",
          "url": "http://fanyi.baidu.com/"
        },
        {
          "name": "GitHub",
          "svg": "Github",
          "url": "https://github.com/"
        },
        {
          "name": "Vue example",
          "svg": "vueEx",
          "url": "https://vuejsexamples.com/"
        },
        {
          "name": "elementui生成器",
          "svg": "createElementui",
          "url": "https://mrhj.gitee.io/form-generator/#/"
        },
        {
          "name": "vue-element-admin",
          "svg": "vue-element-admin",
          "url": "https://panjiachen.github.io/vue-element-admin-site/zh/guide/"
        }
      ]
    },
    {
      "name": "vpn",
      "svg": "vpn",
      "urlList": [
        {
          "name": "iKun",
          "svg": "ikun",
          "url": "https://ikuuu.me/user#"
        },
        {
          "name": "一元机场",
          "svg": "一元机场",
          "url": "https://xn--4gq62f52gdss.com/#/dashboard"
        }
      ]
    }
  ]
}

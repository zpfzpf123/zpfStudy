{
  "note": [
    {
      "id": 1,
      "name": "vuex",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "## Vuex\n\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。\n\n调试工具：vue devtools\n\n> Vuex就像眼镜：您自会知道什么时候需要它。\n\n### 1、state\n\n在store中定义数据，在组件中直接使用：\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    getters: {},\n    mutations: {},\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Home.vue`\n\n```html\n<template>\n  <div class=\"home\">\n    <h2>Home页面的数字：{{$store.state.num}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  \n}\n</script>\n```\n\n或者写为：\n\n```html\n<template>\n  <div class=\"about\">\n    <h2>About页面的数字：{{num}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    num(){\n      return this.$store.state.num\n    }\n  }\n}\n</script>\n```\n\n### 2、getters\n\n将组件中统一使用的computed都放到getters里面来操作\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    mutations: {},\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Home.vue`\n\n```html\n<template>\n  <div class=\"home\">\n    <h2>Home页面的数字：{{$store.getters.getNum}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  \n}\n</script>\n```\n\n### 3、mutations\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios）\n    mutations: {\n        // 让num累加\n        // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n        increase(state, payload){\n            state.num += payload ? payload : 1;\n        }\n    },\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Btn.vue`\n\n```html\n<template>\n    <div>\n        <button @click=\"$store.commit('increase', 2)\">点击加1</button>\n    </div>\n</template>\n<script>\nexport default {\n   methods: {\n       /* addFn(){\n           // 调用store中的mutations里的increase方法\n           // 传参的话，使用payload\n           this.$store.commit('increase', 2)\n       } */\n   }\n}\n</script>\n```\n\n### 4、actions\n\nactions是store中专门用来处理异步的，实际修改状态值的，还是mutations\n\n目录：`store/index.js`\n\n```js\n// 在store(仓库)下的index.js这份文件，就是用来做状态管理\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios）\n    mutations: {\n        // 让num累加\n        // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n        increase(state, payload){\n            state.num += payload ? payload : 1;\n        },\n        // 让num累减\n        decrease(state){\n            state.num--;\n        }\n    },\n    // actions专门用来处理异步，实际修改状态值的，依然是mutations\n    actions: {\n        // 点击了“减1”按钮后，放慢一秒再执行减法\n        decreaseAsync(context){\n            context.commit('decrease')\n        }\n    },\n    modules: {}\n})\n\n```\n\n目录：`Btn.vue`\n\n```html\n<template>\n    <div>\n        <button @click=\"$store.commit('increase', 2)\">点击加1</button>\n        <button @click=\"$store.dispatch('decreaseAsync')\">点击延迟减1</button>\n    </div>\n</template>\n<script>\nexport default {\n   methods: {\n       /* addFn(){\n           // 调用store中的mutations里的increase方法\n           // 传参的话，使用payload\n           this.$store.commit('increase', 2)\n       }\n       reduceFn(){\n           this.$store.dispatch('decreaseAsync')\n       } */\n   }\n}\n</script>\n```\n\n### 5、辅助函数\n\nmapState和mapGetters在组件中都是写在computed里面\n\n```html\n<template>\n\t<div>\n        <h2>Home页面的数字：{{num}}</h2>\n        <h2>About页面的数字：{{getNum}}</h2>\n    </div>\n</template>\n\n<script>\nimport { mapState, mapGetters } from 'vuex'\n\nexport default {\n  computed: {\n    ...mapState(['num'])\n    ...mapGetters(['getNum'])\n  }\n}\n</script>\n```\n\nmapMutations和mapActions在组件中都是写在methods里面\n\n```html\n<template>\n\t<div>\n        <button @click=\"increase(2)\">点击加1</button>\n        <button @click=\"decreaseAsync()\">点击延迟减1</button>\n    </div>\n</template>\n\n<script>\nimport { mapMutations, mapActions } from 'vuex'\n\nexport default {\n  methods: {\n       ...mapMutations(['increase']),\n       ...mapActions(['decreaseAsync'])\n   }\n}\n</script>\n```\n\n### 6、拆分写法\n\nstore中的所有属性，都可以拆分成单独的js文件来书写\n\n### 7、modules\n\n![](.\\1111.png)我们的store可以认为是一个主模块，它下边可以分解为很多子模块，子模块都可以单独领出来写，写完再导入到主模块中。下面以 `users` 子模块举例：\n\n将mutations中所有的方法，归纳起来。\n\n目录：`mutations_type.js`\n\n```js\nexport const MUTATIONS_TYPE = {\n    INCREASE: 'increase',\n    DECREASE: 'decrease'\n}\n\nexport default {\n    // 让num累加\n    // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n    [MUTATIONS_TYPE.INCREASE](state, payload){\n        state.num += payload ? payload : 1;\n    },\n    // 让num累减\n    [MUTATIONS_TYPE.DECREASE](state){\n        state.num--;\n    }\n}\n```\n\n目录：`store/index.js`\n\n```js\nimport mutations from './mutaions_type'\n\nexport default new Vuex.Store({\n    ...\n    mutations,\n    ...\n})\n```\n\n组件中：\n\n```html\n<template>\n  <div class=\"about\">\n    <h2>About页面的数字：{{getNum}}</h2>\n    <button @click=\"increase()\">About的按钮，点击加1</button>\n  </div>\n</template>\n<script>\nimport { mapGetters, mapMutations } from 'vuex'\nimport { MUTATIONS_TYPE } from '@/store/mutaions_type.js'\nexport default {\n  computed: {\n    ...mapGetters(['getNum'])\n  },\n  methods: {\n    // 方法一：\n    ...mapMutations([MUTATIONS_TYPE.INCREASE])\n      \n    // 方法二：\n    /* increase(){\n      this.$store.commit(MUTATIONS_TYPE.INCREASE)\n    } */\n  }\n}\n</script>\n\n```\n\n\n\n"
    },
    {
      "id": 2,
      "name": "vue大屏动态配置组件数量、每个组件的占比和位置代码示例",
      "type": "vue",
      "recommendationIndex": 4,
      "content": "以下是使用Vue.js创建一个大屏组件，并且可以通过传递props来配置组件数量、每个组件的占比和位置的代码示例：\n\n```js\n<template>\n  <div class=\"big-screen\">\n    <div v-for=\"(item, index) in screenList\" :key=\"index\" :style=\"getStyle(item)\">\n      <slot :name=\"item.name\"></slot>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'BigScreen',\n  props: {\n    screenList: {\n      type: Array,\n      required: true,\n      default: () => []\n    }\n  },\n  methods: {\n    getStyle(item) {\n      return {\n        position: 'absolute',\n        left: `${item.left}%`,\n        top: `${item.top}%`,\n        width: `${item.width}%`,\n        height: `${item.height}%`\n      }\n    }\n  }\n}\n</script>\n\n<style>\n.big-screen {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n</style>\n```\n\n在这个示例中，我们定义了一个名为`BigScreen`的组件，并且传递了一个名为`screenList`的props，它是一个数组，用来指定大屏组件的个数、占比和位置。\n\n在组件的模板中，我们使用了`v-for`来遍历`screenList`数组，并为每个大屏组件指定样式（位置和大小），然后使用插槽来插入具体的大屏组件内容。\n\n在组件的方法中，我们定义了一个名为`getStyle`的方法，它接受一个参数`item`，并返回一个包含位置和大小信息的样式对象，这个样式对象会被应用到每个大屏组件的容器元素上。\n\n现在让我们看一个如何使用这个`BigScreen`组件的示例：\n\n```js\n<template>\n  <div style=\"height:100%\">\n    <big-screen :screen-list=\"screenList\">\n      <template #screen1>\n        <div>第一个大屏内容</div>\n      </template>\n      <template #screen2>\n        <div>第二个大屏内容</div>\n      </template>\n    </big-screen>\n  </div>\n</template>\n\n<script>\nimport BigScreen from './BigScreen.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    BigScreen\n  },\n  data() {\n    return {\n      screenList: [\n        { name: 'screen1', left: 0, top: 0, width: 50, height: 100 },\n        { name: 'screen2', left: 50, top: 0, width: 50, height: 100 }\n      ]\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，我们在父组件中使用了`BigScreen`组件，并且传递了一个名为`screenList`的props，它包含了两个元素，分别代表了两个大屏组件的位置、大小和内容名称。\n\n我们也定义了两个插槽（`#screen1`和`#screen2`），它们分别对应了`screenList`数组中的两个元素，表示在第一个大屏和第二个大屏"
    },
    {
      "id": 3,
      "type": "vue",
      "recommendationIndex": 3,
      "name": "vue2+原生js实现上下无缝滚动，鼠标移入停止无缝滚动，可以鼠标滚轮控制滚动，鼠标移出可以继续上下无缝滚动",
      "content": "```js\n<template>\n  <div class=\"scroll-container\" @mouseenter=\"stopScroll\" @mouseleave=\"startScroll\" @wheel=\"onWheel\">\n    <div class=\"scroll-content\">\n      <div class=\"scroll-item\" v-for=\"item in scrollData\" :key=\"item\">{{ item }}</div>\n      <div class=\"scroll-item\" v-for=\"item in scrollData\" :key=\"item\">{{ item }}</div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'SeamlessScroll',\n  data() {\n    return {\n      scrollData: ['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5'],\n      scrollInterval: null,\n      scrollSpeed: 1,\n    }\n  },\n  mounted() {\n    this.startScroll();\n  },\n  beforeDestroy() {\n    clearInterval(this.scrollInterval);\n  },\n  methods: {\n    startScroll() {\n      this.scrollInterval = setInterval(() => {\n        if (this.$el.scrollTop >= this.$el.scrollHeight / 2) {\n          this.$el.scrollTop = 0;\n        } else {\n          this.$el.scrollTop += this.scrollSpeed;\n        }\n      }, 10);\n    },\n    stopScroll() {\n      clearInterval(this.scrollInterval);\n    },\n    onWheel(event) {\n      event.preventDefault();\n      this.$el.scrollTop += event.deltaY;\n    },\n  },\n}\n</script>\n\n<style scoped>\n.scroll-container {\n  height: 200px;\n  overflow: hidden;\n}\n.scroll-content {\n  display: flex;\n  flex-direction: column;\n}\n.scroll-item {\n  height: 50px;\n}\n</style>\n```\n\n"
    },
    {
      "id": 4,
      "type": "vue",
      "recommendationIndex": 4,
      "name": "vue2+Datav实现表格上下无缝滚动",
      "content": "1. 首先需要在vue引入DataV组件 \n   ```js\n   npm install @jiaminghi/data-view\n   ```\n\n   \n\n2. 在main.js注册为全局组件\n   ```js\n   // 将自动注册所有组件为全局组件\n   import dataV from '@jiaminghi/data-view'\n   \n   Vue.use(dataV)\n   ```\n\n3. 使用vue文件代码如下\n   ```vue\n   <template>\n     <div id=\"the-homework-table\">\n       <dv-scroll-board\n         :config=\"config\"\n         style=\"width: 100%; height: 100%\"\n       />\n     </div>\n   </template>\n   \n   <script>\n   export default {\n     data() {\n       return {\n         config: {\n           header: [\n             \"时间\",\n           ],\n           data: [\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n            [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n           ],\n           index: true,//增加序号显示\n           rowNum: 10,//超过10行启动无缝滚动\n         },\n       };\n     },\n   };\n   </script>\n   \n   <style lang=\"less\" scoped>\n   #the-homework-table {\n     width: 100%;\n     height: 100%;\n   }\n   /deep/ .dv-scroll-board .header {\n     font-size: 25px;\n   }\n   /deep/ .dv-scroll-board .rows .row-item {\n     font-size: 24px;\n   }\n   /deep/ .dv-scroll-board .rows .ceil {\n     text-align: center;\n   }\n   /deep/ .dv-scroll-board .header .header-item {\n     text-align: center;\n   }\n   </style>\n   ```\n\n   "
    },
    {
      "id": 5,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue2+echarts封装组件  饼图组件",
      "content": "```js\n<template>\n  <div ref=\"chart\" :style=\"{ height: '100%', width: '100%' }\"></div>\n</template>\n\n<script>\nimport echarts from \"echarts\";\n\nexport default {\n  props: {\n    // 接受数据作为 props\n    data: {\n      type: Array,\n      required: true,\n    },\n    // 接受颜色作为 props\n    colors: {\n      type: Array,\n      default() {\n        return [\"#00BFFF\", \"#FF6B00\"];\n      },\n    },\n    //标题\n    chartTitle: {\n      type: String,\n      default:''\n    },\n    // 是否显示标签\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    // 标签位置\n    labelPosition: {\n      type: String,\n      default: \"inside\",\n    },\n    // 标签字体大小\n    labelFontSize: {\n      type: Number,\n      default: 14,\n    },\n    // 是否自适应\n    responsive: {\n      type: Boolean,\n      default: true,\n    },\n    // series 名称\n    seriesName: {\n      type: String,\n      required: true,\n    },\n    // 是否显示图例\n    showLegend: {\n      type: Boolean,\n      default: false,\n    },\n    // 图例位置\n    legendPosition: {\n      type: String,\n      default: \"right\",\n    },\n  },\n  data() {\n    return {\n      // 设置初始高度\n      chartHeight: \"300px\",\n    };\n  },\n  mounted() {\n    // 渲染图表\n    this.renderChart();\n    // 如果需要自适应，则监听窗口大小变化\n    if (this.responsive) {\n      window.addEventListener(\"resize\", this.renderChart);\n    }\n  },\n  beforeDestroy() {\n    // 如果需要自适应，则在组件销毁前移除监听器\n    if (this.responsive) {\n      window.removeEventListener(\"resize\", this.renderChart);\n    }\n  },\n  methods: {\n    renderChart() {\n      // 初始化 echarts 实例\n      const chart = echarts.init(this.$refs.chart);\n      // 设置图表选项\n      chart.setOption({\n        title: {\n          text: this.chartTitle,\n          left: \"center\",\n          textStyle: {\n            fontSize: 20,\n            color:'white'\n          },\n        },\n        // 配置提示框\n        tooltip: {\n          trigger: \"item\",\n          formatter: \"{a} <br/>{b}: {c} ({d}%)\",\n        },\n        // 配置图例\n        legend: {\n          show: this.showLegend,\n          orient: this.legendPosition,\n        },\n        // 配置 series\n        series: [\n          {\n            // 设置 series 名称\n            name: this.seriesName,\n            // 设置 series 类型为饼状图\n            type: \"pie\",\n            // 设置饼状图半径\n            radius: [\"50%\", \"70%\"],\n            // 避免标签重叠\n            avoidLabelOverlap: false,\n            // 配置标签\n            label: {\n              show: this.showLabel,\n              position: this.labelPosition,\n              fontSize: this.labelFontSize,\n            },\n            // 配置标签强调样式\n            emphasis: {\n              label: {\n                show: true,\n                fontSize: this.labelFontSize + 2,\n                fontWeight: \"bold\",\n              },\n            },\n            // 配置标签线\n            labelLine: {\n              show: false,\n            },\n            // 配置数据\n            data: this.data.map((item, index) => ({\n              value: item.val,\n              name: item.name,\n              itemStyle: {\n                color: this.colors[index],\n              },\n            })),\n          },\n        ],\n      });\n      // 如果需要自适应，则在渲染后调整图表大小\n      if (this.responsive) {\n        chart.resize();\n      }\n    },\n  },\n};\n</script>\n\n<style>\n/* 可选的图表容器样式 */\n</style>\n```\n\n# 组件使用示例\n\n```js\n<pie-chart\n            :data=\"chartData\"\n            :colors=\"chartColors\"\n            :show-label=\"showLabel\"\n            :label-position=\"labelPosition\"\n            :label-font-size=\"labelFontSize\"\n            :responsive=\"true\"\n            series-name=\"作业统计\"\n            chartTitle=\"作业统计\"\n          />\n  \ndata() {\n    return {\n      chartData: [\n        {name:'已完成',val:10},\n        {name:'未完成',val:20},\n      ],\n      chartColors: ['#00BFFF','#FF6B00'],\n      showLabel: true,\n      labelPosition: 'inside',\n      labelFontSize: 25,\n    }\n  },\n```\n\n"
    },
    {
      "id": 6,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue2+echarts封装组件  柱状图组件",
      "content": "```js\n<template>\n  <div ref=\"chart\" style=\"width: 100%; height: 100%\"></div>\n</template>\n\n<script>\nimport echarts from \"echarts\";\n\nexport default {\n  props: {\n    //颜色\n    colorList: {\n      type: Array,\n      default: () => {\n        return [\"#00BFFF\", \"#FF6B00\"];\n      },\n    },\n    // 图表标题\n    title: {\n      type: String,\n      required: true,\n    },\n    // x 轴数据\n    xAxisData: {\n      type: Array,\n      required: true,\n    },\n    // 数据系列\n    seriesData: {\n      type: Array,\n      required: true,\n    },\n    // 图例数据\n    legendData: {\n      type: Array,\n      required: true,\n    },\n    // tooltip 的 crossStyle\n    crossStyle: {\n      type: Object,\n      default: () => {\n        return {\n          color: \"white\",\n        };\n      },\n    },\n    /**\n     * @description:  字体大小列表，依次为：\n    0. 标题字体大小\n     1. 图例字体大小\n    2. x 轴标签字体大小\n     3. y 轴标签字体大小\n     4. 数据标签字体大小\n     5. tooltip 字体大小\n     * @return {*}\n     */\n    fontSizeList: {\n      type: Array,\n      required: true,\n    },\n  },\n  data() {\n    return {\n      chart: null,\n    };\n  },\n  mounted() {\n    // 初始化 echarts 实例\n    this.chart = echarts.init(this.$refs.chart);\n    // 设置图表配置项\n    this.chart.setOption({\n      color:this.colorList,\n      // 图表标题\n      title: {\n        text: this.title,\n        textStyle: {\n          color: \"#fff\",\n          fontSize: this.fontSizeList[0],\n        },\n      },\n      // tooltip\n      tooltip: {\n        trigger: \"axis\",\n        axisPointer: {\n          type: \"cross\",\n          crossStyle: this.crossStyle,\n        },\n        textStyle: {\n          fontSize: this.fontSizeList[5],\n        },\n      },\n      // 图例\n      legend: {\n        data: this.legendData,\n        textStyle: {\n          color: \"#fff\",\n          fontSize: this.fontSizeList[1],\n        },\n      },\n      // x 轴\n      xAxis: [\n        {\n          type: \"category\",\n          data: this.xAxisData,\n          axisPointer: {\n            type: \"shadow\",\n          },\n          axisLabel: {\n            textStyle: {\n              color: \"#fff\",\n              fontSize: this.fontSizeList[2],\n            },\n          },\n          // 去掉 x 轴的分割线\n          splitLine: {\n            show: false,\n          },\n        },\n      ],\n      // y 轴\n      yAxis: [\n        {\n          type: \"value\",\n          axisLabel: {\n            textStyle: {\n              color: \"#fff\",\n              fontSize: this.fontSizeList[3],\n            },\n          },\n          // 去掉 y 轴的分割线\n          splitLine: {\n            show: false,\n          },\n        },\n      ],\n      // 数据系列\n      series: this.seriesData.map((item) => {\n        return {\n          name: item.name,\n          type: \"bar\",\n          data: item.data,\n          label: {\n            show: this.showLabel,\n            position: this.labelPosition,\n            fontSize: this.fontSizeList[4],\n          },\n        };\n      }),\n    });\n    // 监听窗口大小变化，自适应图表大小\n    window.addEventListener(\"resize\", () => {\n      this.chart.resize();\n    });\n  },\n};\n</script>\n```\n\n# 组件使用示例\n\n```js\n<bar-chart\n            :title=\"chartTitle\"\n            :x-axis-data=\"xAxisData\"\n            :series-data=\"seriesData\"\n            :legend-data=\"legendData\"\n            :cross-style=\"crossStyle\"\n            :font-size-list=\"fontSizeList\"\n          />\n  \ndata() {\n    return {\n      title: \"人员管理\",\n      chartTitle: \"人员统计\",\n      xAxisData: [\"A\", \"B\", \"C\", \"D\", \"E\"],\n      seriesData: [\n        {\n          name: \"员工数量\",\n          data: [10, 20, 30, 40, 50],\n        },\n        {\n          name: \"访客数量\",\n          data: [20, 30, 40, 50, 60],\n        },\n      ],\n      legendData: [\"员工数量\", \"访客数量\"],\n      crossStyle: {\n        color: \"white\",\n      },\n      fontSizeList: [18, 20, 20, 20, 20, 20],\n    };\n  },\n```\n\n"
    },
    {
      "id": 7,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue2播放flv视频流",
      "content": "# 下载flv.js\n\n```js\nnpm install --save flv.js\n```\n\n# 代码示例\n\n```js\n<template>\n  <div>\n\t<video id=\"videoElement\" controls autoplay muted width=\"300px\" height=\"200px\">    \n    </video>\n\t<button @click=\"play\">播放</button>\n  </div>\n</template>\n<script>\n    import flvjs from 'flv.js'\nexport default {\n  data () {\n    return {\n\t  flvPlayer:null\n    }\n  },\n   mounted() {\n      if (flvjs.isSupported()) {\n        var videoElement = document.getElementById('videoElement');\n        this.flvPlayer = flvjs.createPlayer({\n          type: 'flv',\n\t\t  isLive: true,\n\t\t  hasAudio: false,\n          url: 'http://1011.hlsplay.aodianyun.com/demo/game.flv'\n        });\n        this.flvPlayer.attachMediaElement(videoElement);\n        this.flvPlayer.load();\n\t\tthis.flvPlayer.play();\n      }\n    },\n    methods:{\n      play () {\n        this.flvPlayer.play();\n      }\n    }\n}\n</script>\n\n```\n\n"
    },
    {
      "id": 8,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue+nginx部署",
      "content": "# vue\n\nvue.config.js配置如下\n\n```js\nconst {defineConfig} = require('@vue/cli-service')\nmodule.exports = defineConfig({\n    transpileDependencies: true,\n    //打包\n    publicPath: './',\n    devServer: {\n        host: '0.0.0.0',\n        port: 8080,\n        proxy: {\n            '/captures': {\n                target: 'http://192.168.1.150:18080', // 目标路径，别忘了加http和端口号 也就是接口的前面的ip地址端口号\n                changeOrigin: true, // 是否跨域\n            }\n        }\n    }\n})\n \n```\n\n# nginx\n\nnginx.conf配置如下\n\n```json\n\nuser  root;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n    \t# 服务器端口号\n        listen       80; \n    \t# 服务器名称\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n        location / {\n            root    /zckx/nginx/html/dist; #项目文件位置\n            index  index.html;\n            try_files $uri $uri/ /index.html;\n        }\n\t\t# 配置跨域 比如接口以/captures开头的配置如下\n        location /captures/ {\n            # 允许http://192.168.1.150:18080跨域 http://192.168.1.150:18080为接口地址\n            proxy_pass http://192.168.1.150:18080; \n        }\n\n        location /live{\n            add_header Access-Control-Allow-Origin *;\n            types {\n                application/vnd.apple.mpegurl m3u8;\n                video/mp2t ts;\n            }\n            # HLS切片文件目录\n            alias /tmp/hls;\n            expires -1;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n\nrtmp {\n        server {\n                listen 1935;\n                chunk_size 4096;\n                # vod path\n                application live {\n                        live on;\n                        hls on;\n                        ##HLS切片保存路径\n                        hls_path /tmp/hls;\n                        hls_fragment 4;\n                        hls_playlist_length 30;\n                        record off;\n                }\n        }\n}\n\n\n\n\n```\n\n"
    },
    {
      "id": 9,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue二次封装axios",
      "content": "在src创建request文件夹 新建axios.js\n\n```js\nimport axios from 'axios';\nimport {Message} from 'element-ui';\n// 统一请求路径前缀\nlet baseApi = \"/\";\n\n// 超时设定\naxios.defaults.timeout = 20000;\n\naxios.interceptors.request.use(config => {\n    return config;\n}, err => {\n    Message.error('请求超时');\n    return Promise.reject(err);\n});\n\n// http response 拦截器\naxios.interceptors.response.use(response => {\n    return response.data;\n}, (err) => {\n    // 返回状态码不为200时候的错误处理\n    Message.error(err.toString());\n    return Promise.reject(err);\n});\n\nexport const getRequest = (url, params) => {\n    return axios({\n        method: 'get',\n        url: `${baseApi}${url}`,\n        params: params,\n    });\n};\n\nexport const postRequest = (url, params) => {\n    return axios({\n        method: 'post',\n        url: `${baseApi}${url}`,\n        data: params,\n    });\n};\n\nexport const putRequest = (url, params) => {\n    return axios({\n        method: 'put',\n        url: `${baseApi}${url}`,\n        data: params,\n    });\n};\n```\n\n"
    },
    {
      "id": 10,
      "type": "vue",
      "recommendationIndex": 4,
      "name": "vue2+mqtt.js封装",
      "content": "这是一个使用 MQTT.js 的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 MQTT.js。\n\n## 安装\n\n首先，你需要在你的项目中安装 MQTT.js。你可以通过 npm 来安装：\n\n```bash\nnpm install mqtt --save\n```\n\n## 封装插件\n\n```js\n// 导入 mqtt 库\nimport * as mqtt from 'mqtt'\n\nexport default {\n  install(Vue) {\n    // 在 Vue 的原型上添加一个名为 $mqtt 的方法\n    Vue.prototype.$mqtt = (url, topics, option) => {\n      // 设置 MQTT 客户端的选项\n      const options = {\n        reconnectPeriod: 1000, // 如果连接断开，客户端将在1秒后尝试重新连接\n        ...option\n      }\n\n      // 创建一个新的 MQTT 客户端并连接到服务器\n      const client = mqtt.connect(url, options)\n\n      // 当客户端连接到服务器时，打印一条消息并订阅主题\n      client.on('connect', () => {\n        console.log('MQTT client connected')\n        // 订阅主题\n        topics && topics.forEach(topic => client.subscribe(topic))\n      })\n\n      // 当客户端遇到错误时，打印错误消息\n      client.on('error', (error) => {\n        console.error('MQTT client encountered an error:', error)\n      })\n\n      // 当客户端正在尝试重新连接时，打印一条消息\n      client.on('reconnect', () => {\n        console.log('MQTT client is attempting to reconnect')\n      })\n\n      // 返回一个对象，该对象包含一些方法，这些方法可以在 Vue 组件中使用\n      return {\n        // 收到消息时的回调函数\n        message: (callback) => {\n          client.on('message', (topic, message) => {\n            callback(topic, message.toString())\n          })\n        },\n        // 发送消息\n        publish: function(topic, message, callback) {\n          client.publish(topic, message)\n          callback()\n        },\n\n        // 关闭客户端\n        end: callback => {\n          client.end()\n          callback()\n        }\n      }\n    }\n  }\n}\n\n```\n\n\n\n然后，将上述代码保存为 `mqttPlugin.js` 文件，并将其放在你的项目的 `src/plugins` 目录下。\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `$mqtt` 方法来创建一个新的 MQTT 客户端。以下是 `$mqtt` 方法的参数：\n\n- `url`：MQTT 服务器的 URL。\n- `topics`：一个数组，包含你想要订阅的主题。\n- `option`：一个对象，包含 MQTT 客户端的选项。这个对象会和默认选项合并。默认选项包括 `reconnectPeriod: 1000`，表示如果连接断开，客户端将在1秒后尝试重新连接。\n\n`$mqtt` 方法返回一个对象，该对象包含以下方法：\n\n- `message(callback)`：设置一个回调函数，当收到任何主题的消息时，该回调函数会被调用。回调函数接受两个参数，即主题和消息的内容（字符串格式）。\n- `publish(topic, message, callback)`：向指定主题发送一个消息，然后调用回调函数。\n- `end(callback)`：关闭 MQTT 客户端，然后调用回调函数。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `mqttPlugin` 插件的示例：\n\n```javascript\n<template>\n  <div>\n    <button @click=\"connect\">Connect</button>\n    <button @click=\"sendMessage\">Send Message</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      mqttClient: null\n    }\n  },\n  methods: {\n    connect() {\n      this.mqttClient = this.$mqtt('mqtt://test.mosquitto.org', ['topic1', 'topic2'])\n\n      this.mqttClient.message((topic, message) => {\n        console.log(`Received message on ${topic}: ${message}`)\n      })\n    },\n    sendMessage() {\n      this.mqttClient.publish('topic1', 'Hello, MQTT!', () => {\n        console.log('Message sent')\n      })\n    },\n    disconnect() {\n      this.mqttClient.end(() => {\n        console.log('MQTT client disconnected')\n      })\n    }\n  },\n  beforeDestroy() {\n    // 在组件销毁时关闭 MQTT 客户端\n    this.disconnect()\n  },\n}\n</script>\n```\n\n在这个示例中，当你点击 “Connect” 按钮时，会创建一个新的 MQTT 客户端并连接到服务器。当你点击 “Send Message” 按钮时，会向 `topic1` 发送一个消息。当你离开当前页面路由，会断开 MQTT 客户端的连接。"
    },
    {
      "id": 11,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue2+elementui二次封装",
      "content": "# 封装el-dialog\n\n这是一个使用 `Dialog` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `Dialog` 组件。\n\n## 代码\n\n```js\n<template>\n  <div id=\"Dialog\">\n    <el-dialog :fullscreen=\"fullscreen\" :center=\"center\" :visible=\"visible\" :width=\"width\" :custom-class=\"customClass\" @open=\"openDialog\"\n               @close=\"closeDialog\"\n    >\n      <template v-slot:title>\n        <slot name=\"title\"/>\n      </template>\n      <template v-slot:default>\n        <slot name=\"content\"/>\n      </template>\n      <template v-slot:footer>\n        <slot name=\"footer\"/>\n      </template>\n    </el-dialog>\n  </div>\n</template>\n<script>\nexport default {\n  name: 'Dialog',\n  props: {\n    // 是否显示弹框\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    // 弹框标题\n    title: {\n      type: String,\n      default: ''\n    },\n    // 弹框宽度\n    width: {\n      type: String,\n      default: '50%'\n    },\n    // Dialog 的自定义类名\n    customClass: {\n      type: String,\n      default: ''\n    },\n    // 标题是否居中\n    center: {\n      type: Boolean,\n      default: true\n    },\n    // 弹框是否全屏显示\n    fullscreen: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    /**\n     * 打开弹窗回调\n     * */\n    openDialog() {\n      console.log('你打开了弹窗')\n      this.$emit('openDialog')\n    },\n    /**\n     * 关闭弹窗回调\n     * */\n    closeDialog() {\n      this.$emit('closeDialog', false)\n      console.log('你关闭了弹窗')\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"scss\">\n\n</style>\n\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `Dialog` 组件来创建一个新的对话框。以下是 `Dialog` 组件的属性：\n\n- `visible`：是否显示对话框。默认值为 `false`。\n- `title`：对话框的标题。默认值为 `''`。\n- `width`：对话框的宽度。默认值为 `'50%'`。\n- `customClass`：对话框的自定义类名。默认值为 `''`。\n- `center`：标题是否居中。默认值为 `true`。\n- `fullscreen`：对话框是否全屏显示。默认值为 `false`。\n\n`Dialog` 组件还包含以下方法：\n\n- `openDialog`：打开对话框时的回调函数。你可以监听 `openDialog` 事件来执行自定义的逻辑。\n- `closeDialog`：关闭对话框时的回调函数。你可以监听 `closeDialog` 事件来执行自定义的逻辑。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `Dialog` 组件的示例：\n\n```js\n<template>\n  <div>\n    <button @click=\"visible = true\">Open Dialog</button>\n    <Dialog :visible=\"visible\" @closeDialog=\"visible = false\">\n      <template v-slot:title>\n        <h2>Dialog Title</h2>\n      </template>\n      <template v-slot:content>\n        <p>Dialog Content</p>\n      </template>\n      <template v-slot:footer>\n        <button @click=\"visible = false\">Close Dialog</button>\n      </template>\n    </Dialog>\n  </div>\n</template>\n\n<script>\nimport Dialog from './Dialog'\n\nexport default {\n  components: {\n    Dialog\n  },\n  data() {\n    return {\n      visible: false\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，当你点击 “Open Dialog” 按钮时，对话框会打开。当你点击 “Close Dialog” 按钮时，对话框会关闭。"
    },
    {
      "id": 12,
      "type": "vue",
      "recommendationIndex": 4,
      "name": "vue2+动态表单生成设计(根据后端返回显示对应表单)",
      "content": "这是一个使用 `DynamicForms` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `DynamicForms` 组件。\n\n## 代码\n\n```js\n<template>\n  <div v-if=\"Object.keys(args).length\">\n    <div v-for=\"(item, index) in dynamicComponentParameters\" :key=\"index\">\n      <el-form-item v-if=\"item.type === 'el-input'\" :label=\"item.name\">\n        <el-input v-model=\"args[item.val]\" />\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-select'\" :label=\"item.name\">\n        <el-select v-model=\"args[item.val]\" placeholder=\"请选择算法类型\">\n          <el-option\n            v-for=\"selectVal of item.selectList\"\n            :key=\"selectVal.label\"\n            :label=\"selectVal.label\"\n            :value=\"selectVal.value\"\n          />\n        </el-select>\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-checkbox'\" :label=\"item.name\">\n        <el-checkbox-group v-model=\"args[item.val]\">\n          <el-checkbox\n            v-for=\"checkVal of item.checkList\"\n            :key=\"checkVal.label\"\n            :label=\"checkVal.label\"\n          />\n        </el-checkbox-group>\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-radio'\" :label=\"item.name\">\n        <el-radio-group v-model=\"args[item.val]\">\n          <el-radio\n            v-for=\"radioVal of item.radioList\"\n            :key=\"radioVal.label\"\n            :label=\"radioVal.label\"\n          />\n        </el-radio-group>\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-input-number'\" :label=\"item.name\">\n        <el-input-number v-model=\"args[item.val]\" :step=\"item.step\" :min=\"item.min\" :max=\"item.max\" />\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-switch'\" :label=\"item.name\">\n        <el-switch v-model=\"args[item.val]\" />\n      </el-form-item>\n    </div>\n  </div>\n</template>\n<script>\nimport { Loading } from 'element-ui'\n\nexport default {\n  name: 'DynamicForms',\n  props: {\n    // 动态组件列表\n    dynamicComponentParameters: {\n      type: Array,\n      default() {\n        return []\n      }\n    },\n    // 动态组件绑定后传值的参数\n    // eslint-disable-next-line vue/require-default-prop\n    args: {\n      type: Object,\n      default() {\n        return {}\n      }\n    }\n  },\n  data() {\n    return {\n      // 默认参数值\n      defaultValues: {\n        'string': '',\n        'number': 0,\n        'boolean': false,\n        'array': [],\n        'object': {},\n        'function': function() {\n        }\n      },\n      // 加载状态\n      loadingInstance: null\n    }\n  },\n  computed: {\n    // 参数默认值列表\n    argList() {\n      // eslint-disable-next-line vue/no-async-in-computed-properties\n      return new Promise((resolve, reject) => {\n        this.loadingInstance = Loading.service({\n          fullscreen: true,\n          text: '加载中,请稍等....'\n        })\n        // 模拟接口异步\n        setTimeout(() => {\n          const argList = this.dynamicComponentParameters.map(item => {\n            return {\n              name: item.val,\n              type: item.valType\n            }\n          })\n          resolve(argList)\n        }, 1000)\n      })\n    },\n    // 更新后的ages参数\n    newArgs() {\n      const args = this.args\n      // eslint-disable-next-line vue/no-async-in-computed-properties\n      this.argList.then(res => {\n        res.forEach(list => {\n          console.log(this.defaultValues[list.type])\n          this.$set(args, list.name, this.defaultValues[list.type])\n        })\n        this.loadingInstance.close()\n      })\n      return args\n    }\n  },\n  mounted() {\n    this.init()\n  },\n  methods: {\n    init() {\n      /**\n       * 初始化的时候给动态组件绑定后传值的参数赋默认值\n       * 可根据后端传值的类型和字段赋默认值\n       * */\n      this.$emit('update:args', this.newArgs)\n      console.log(this.args.length)\n    }\n  }\n}\n</script>\n<style scoped lang=\"scss\">\n\n</style>\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `DynamicForms` 组件来创建一个动态表单。以下是 `DynamicForms` 组件的属性：\n\n- `dynamicComponentParameters`：动态组件列表，数组类型，默认值为 `[]`。每个元素是一个对象，包含以下属性：\n  - `type`：组件类型，例如 `'el-input'`、`'el-select'` 等。\n  - `name`：组件的标签。\n  - `val`：组件的值，将绑定到 `args` 对象的对应属性上。\n  - `selectList`、`checkList`、`radioList`：当组件类型为 `'el-select'`、`'el-checkbox'` 或 `'el-radio'` 时，这些属性包含了选项列表。\n  - `step`、`min`、`max`：当组件类型为 `'el-input-number'` 时，这些属性用于设置数字输入框的步长、最小值和最大值。\n\n- `args`：动态组件绑定后传值的参数，对象类型，默认值为 `{}`。对象的每个属性对应一个动态组件，属性名为组件的 `val`，属性值为组件的值。\n\n`DynamicForms` 组件还包含以下方法：\n\n- `init`：初始化的时候给动态组件绑定后传值的参数赋默认值，可根据后端传值的类型和字段赋默认值。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `DynamicForms` 组件的示例：\n\n```js\n<template>\n  <div>\n    <DynamicForms :dynamicComponentParameters=\"dynamicComponentParameters\" :args.sync=\"args\" />\n  </div>\n</template>\n\n<script>\nimport DynamicForms from './DynamicForms'\n\nexport default {\n  components: {\n    DynamicForms\n  },\n  data() {\n    return {\n      dynamicComponentParameters: [\n        { type: 'el-input', name: 'Input', val: 'input' },\n        { type: 'el-select', name: 'Select', val: 'select', selectList: [{ label: 'Option1', value: 'option1' }, { label: 'Option2', value: 'option2' }] },\n        // 更多的动态组件参数...\n      ],\n      args: {\n        // 动态组件绑定后传值的参数\n      }\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，你需要提供你的动态组件参数列表 `dynamicComponentParameters` 和动态组件绑定后传值的参数 `args`。"
    },
    {
      "id": 13,
      "type": "vue",
      "recommendationIndex": 4,
      "name": "vue2播放hls视频流)",
      "content": "这是一个使用 `HLSPlay` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `HLSPlay` 组件。\n\n## 下载\n\n```js\nnpm install vue-video-player@5.0.2\nnpm install videojs-contrib-hls@5.14.1\n```\n\n## 代码\n\n```js\n<template>\n  <section class=\"HLSPlay-component\">\n    <video-player\n      ref=\"videoPlayer\"\n      class=\"video-player-box\"\n      :options=\"playerOptions\"\n      :playsinline=\"true\"\n      custom-event-name=\"customstatechangedeventname\"\n    />\n  </section>\n</template>\n<script>\nimport 'video.js/dist/video-js.css'\nimport 'videojs-contrib-hls'\nimport { videoPlayer } from 'vue-video-player'\n\nexport default {\n  name: 'HLSPlay',\n  components: {\n    videoPlayer\n  },\n  props: {\n    // eslint-disable-next-line vue/require-default-prop\n    src: {\n      type: String\n    },\n    // eslint-disable-next-line vue/prop-name-casing,vue/require-default-prop\n    cover_url: {\n      type: String\n    }\n  },\n  data() {\n    return {\n      playerOptions: {\n        autoplay: true,\n        muted: true,\n        preload: '63:25',\n        language: 'zh-CN',\n        fluid: true,\n        // playbackRates: [0.7, 1.0, 1.5, 2.0],\n        sources: [\n          {\n            type: 'application/x-mpegURL',\n            src: this.src // 路径\n            // src: 'https://cdn.theguardian.tv/webM/2015/07/20/150716YesMen_synd_768k_vp8.webm'\n          }\n        ],\n        poster: this.cover_url, // 你的封面地址\n        notSupportedMessage: '此视频暂无法播放，请稍后再试'\n        // controlBar: {\n        //   timeDivider: true,\n        //   durationDisplay: true,\n        //   remainingTimeDisplay: false,\n        //   fullscreenToggle: true, // 全屏按钮\n        //   currentTimeDisplay: true, // 当前时间\n        //   volumeControl: false, // 声音控制键\n        //   playToggle: false, // 暂停和播放键\n        //   // progressControl: true // 进度条\n        // }\n      }\n    }\n  },\n  computed: {\n    player() {\n      return this.$refs.videoPlayer.player\n    }\n  },\n  mounted() {\n    // this.play()\n    // console.log('this is current player instance object', this.player)\n  },\n  beforeDestroy() {\n    this.player && this.player.dispose()\n  },\n  methods: {\n    setSrc(src) {\n      this.player.src({ src: src, type: 'application/x-mpegURL' })\n    },\n    play() {\n      try {\n        this.$nextTick(() => {\n          this.player.play().then(res => {\n            this.$message('获取视频成功')\n          }).catch(e => {\n            console.log(e, '失败')\n          }) // 播放\n        })\n      } catch (e) {\n        console.log(e)\n      }\n      // 手动触发播放\n    }\n  }\n\n}\n</script>\n<style lang=\"scss\" scoped>\n.HLSPlay-component{\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  ::v-deep.video-player-box{\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    #vjs_video_1{\n      height: 100%;\n    }\n   #vjs_video_3 {\n      height: inherit;\n      padding-top: 36.25% !important;\n    }\n  }\n}\n::v-deep.video-player {\n  //.vjs_video_3-dimensions {\n  //  width: 100%;\n  //  height: 96%;\n  //}\n\n  // 初始化，暂停按钮居中\n  .vjs-big-play-button {\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n\n  .video-js .vjs-tech {\n    object-fit: fill;\n    height: 100%;\n  }\n  .vjs-fluid{\n    padding-top: 2vw !important;\n    height: inherit;\n  }\n}\n</style>\n\n\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `HLSPlay` 组件来创建一个 HLS 视频播放器。以下是 `HLSPlay` 组件的属性：\n\n- `src`：视频源的 URL，字符串类型。\n- `cover_url`：视频封面的 URL，字符串类型。\n\n`HLSPlay` 组件还包含以下方法：\n\n- `setSrc(src)`：设置新的视频源。\n- `play()`：播放视频。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `HLSPlay` 组件的示例：\n\n```vue\n<template>\n  <div>\n    <HLSPlay :src=\"videoSrc\" :cover_url=\"coverUrl\" ref=\"hlsPlayer\" />\n    <button @click=\"changeVideo\">Change Video</button>\n  </div>\n</template>\n\n<script>\nimport HLSPlay from './HLSPlay'\n\nexport default {\n  components: {\n    HLSPlay\n  },\n  data() {\n    return {\n      videoSrc: 'https://path/to/your/video.m3u8',\n      coverUrl: 'https://path/to/your/cover.jpg'\n    }\n  },\n  methods: {\n    changeVideo() {\n      this.videoSrc = 'https://path/to/another/video.m3u8'\n      this.$refs.hlsPlayer.setSrc(this.videoSrc)\n      this.$refs.hlsPlayer.play()\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，`HLSPlay` 组件用于播放一个 HLS 视频。当你点击 “Change Video” 按钮时，视频源会被更改，新的视频会开始播放。希望这个文档能对你有所帮助！"
    }
  ]
}

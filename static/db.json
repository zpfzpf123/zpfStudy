{
  "note": [
    {
      "id": 1,
      "name": "vuex",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "## Vuex\n\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。\n\n调试工具：vue devtools\n\n> Vuex就像眼镜：您自会知道什么时候需要它。\n\n### 1、state\n\n在store中定义数据，在组件中直接使用：\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    getters: {},\n    mutations: {},\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Home.vue`\n\n```html\n<template>\n  <div class=\"home\">\n    <h2>Home页面的数字：{{$store.state.num}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  \n}\n</script>\n```\n\n或者写为：\n\n```html\n<template>\n  <div class=\"about\">\n    <h2>About页面的数字：{{num}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    num(){\n      return this.$store.state.num\n    }\n  }\n}\n</script>\n```\n\n### 2、getters\n\n将组件中统一使用的computed都放到getters里面来操作\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    mutations: {},\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Home.vue`\n\n```html\n<template>\n  <div class=\"home\">\n    <h2>Home页面的数字：{{$store.getters.getNum}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  \n}\n</script>\n```\n\n### 3、mutations\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios）\n    mutations: {\n        // 让num累加\n        // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n        increase(state, payload){\n            state.num += payload ? payload : 1;\n        }\n    },\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Btn.vue`\n\n```html\n<template>\n    <div>\n        <button @click=\"$store.commit('increase', 2)\">点击加1</button>\n    </div>\n</template>\n<script>\nexport default {\n   methods: {\n       /* addFn(){\n           // 调用store中的mutations里的increase方法\n           // 传参的话，使用payload\n           this.$store.commit('increase', 2)\n       } */\n   }\n}\n</script>\n```\n\n### 4、actions\n\nactions是store中专门用来处理异步的，实际修改状态值的，还是mutations\n\n目录：`store/index.js`\n\n```js\n// 在store(仓库)下的index.js这份文件，就是用来做状态管理\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios）\n    mutations: {\n        // 让num累加\n        // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n        increase(state, payload){\n            state.num += payload ? payload : 1;\n        },\n        // 让num累减\n        decrease(state){\n            state.num--;\n        }\n    },\n    // actions专门用来处理异步，实际修改状态值的，依然是mutations\n    actions: {\n        // 点击了“减1”按钮后，放慢一秒再执行减法\n        decreaseAsync(context){\n            context.commit('decrease')\n        }\n    },\n    modules: {}\n})\n\n```\n\n目录：`Btn.vue`\n\n```html\n<template>\n    <div>\n        <button @click=\"$store.commit('increase', 2)\">点击加1</button>\n        <button @click=\"$store.dispatch('decreaseAsync')\">点击延迟减1</button>\n    </div>\n</template>\n<script>\nexport default {\n   methods: {\n       /* addFn(){\n           // 调用store中的mutations里的increase方法\n           // 传参的话，使用payload\n           this.$store.commit('increase', 2)\n       }\n       reduceFn(){\n           this.$store.dispatch('decreaseAsync')\n       } */\n   }\n}\n</script>\n```\n\n### 5、辅助函数\n\nmapState和mapGetters在组件中都是写在computed里面\n\n```html\n<template>\n\t<div>\n        <h2>Home页面的数字：{{num}}</h2>\n        <h2>About页面的数字：{{getNum}}</h2>\n    </div>\n</template>\n\n<script>\nimport { mapState, mapGetters } from 'vuex'\n\nexport default {\n  computed: {\n    ...mapState(['num'])\n    ...mapGetters(['getNum'])\n  }\n}\n</script>\n```\n\nmapMutations和mapActions在组件中都是写在methods里面\n\n```html\n<template>\n\t<div>\n        <button @click=\"increase(2)\">点击加1</button>\n        <button @click=\"decreaseAsync()\">点击延迟减1</button>\n    </div>\n</template>\n\n<script>\nimport { mapMutations, mapActions } from 'vuex'\n\nexport default {\n  methods: {\n       ...mapMutations(['increase']),\n       ...mapActions(['decreaseAsync'])\n   }\n}\n</script>\n```\n\n### 6、拆分写法\n\nstore中的所有属性，都可以拆分成单独的js文件来书写\n\n### 7、modules\n\n![](.\\1111.png)我们的store可以认为是一个主模块，它下边可以分解为很多子模块，子模块都可以单独领出来写，写完再导入到主模块中。下面以 `users` 子模块举例：\n\n将mutations中所有的方法，归纳起来。\n\n目录：`mutations_type.js`\n\n```js\nexport const MUTATIONS_TYPE = {\n    INCREASE: 'increase',\n    DECREASE: 'decrease'\n}\n\nexport default {\n    // 让num累加\n    // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n    [MUTATIONS_TYPE.INCREASE](state, payload){\n        state.num += payload ? payload : 1;\n    },\n    // 让num累减\n    [MUTATIONS_TYPE.DECREASE](state){\n        state.num--;\n    }\n}\n```\n\n目录：`store/index.js`\n\n```js\nimport mutations from './mutaions_type'\n\nexport default new Vuex.Store({\n    ...\n    mutations,\n    ...\n})\n```\n\n组件中：\n\n```html\n<template>\n  <div class=\"about\">\n    <h2>About页面的数字：{{getNum}}</h2>\n    <button @click=\"increase()\">About的按钮，点击加1</button>\n  </div>\n</template>\n<script>\nimport { mapGetters, mapMutations } from 'vuex'\nimport { MUTATIONS_TYPE } from '@/store/mutaions_type.js'\nexport default {\n  computed: {\n    ...mapGetters(['getNum'])\n  },\n  methods: {\n    // 方法一：\n    ...mapMutations([MUTATIONS_TYPE.INCREASE])\n      \n    // 方法二：\n    /* increase(){\n      this.$store.commit(MUTATIONS_TYPE.INCREASE)\n    } */\n  }\n}\n</script>\n\n```\n\n\n\n"
    },
    {
      "id": 2,
      "name": "vue大屏动态配置组件数量、每个组件的占比和位置代码示例",
      "type": "vue",
      "recommendationIndex": 4,
      "content": "以下是使用Vue.js创建一个大屏组件，并且可以通过传递props来配置组件数量、每个组件的占比和位置的代码示例：\n\n```js\n<template>\n  <div class=\"big-screen\">\n    <div v-for=\"(item, index) in screenList\" :key=\"index\" :style=\"getStyle(item)\">\n      <slot :name=\"item.name\"></slot>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'BigScreen',\n  props: {\n    screenList: {\n      type: Array,\n      required: true,\n      default: () => []\n    }\n  },\n  methods: {\n    getStyle(item) {\n      return {\n        position: 'absolute',\n        left: `${item.left}%`,\n        top: `${item.top}%`,\n        width: `${item.width}%`,\n        height: `${item.height}%`\n      }\n    }\n  }\n}\n</script>\n\n<style>\n.big-screen {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n</style>\n```\n\n在这个示例中，我们定义了一个名为`BigScreen`的组件，并且传递了一个名为`screenList`的props，它是一个数组，用来指定大屏组件的个数、占比和位置。\n\n在组件的模板中，我们使用了`v-for`来遍历`screenList`数组，并为每个大屏组件指定样式（位置和大小），然后使用插槽来插入具体的大屏组件内容。\n\n在组件的方法中，我们定义了一个名为`getStyle`的方法，它接受一个参数`item`，并返回一个包含位置和大小信息的样式对象，这个样式对象会被应用到每个大屏组件的容器元素上。\n\n现在让我们看一个如何使用这个`BigScreen`组件的示例：\n\n```js\n<template>\n  <div style=\"height:100%\">\n    <big-screen :screen-list=\"screenList\">\n      <template #screen1>\n        <div>第一个大屏内容</div>\n      </template>\n      <template #screen2>\n        <div>第二个大屏内容</div>\n      </template>\n    </big-screen>\n  </div>\n</template>\n\n<script>\nimport BigScreen from './BigScreen.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    BigScreen\n  },\n  data() {\n    return {\n      screenList: [\n        { name: 'screen1', left: 0, top: 0, width: 50, height: 100 },\n        { name: 'screen2', left: 50, top: 0, width: 50, height: 100 }\n      ]\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，我们在父组件中使用了`BigScreen`组件，并且传递了一个名为`screenList`的props，它包含了两个元素，分别代表了两个大屏组件的位置、大小和内容名称。\n\n我们也定义了两个插槽（`#screen1`和`#screen2`），它们分别对应了`screenList`数组中的两个元素，表示在第一个大屏和第二个大屏"
    },
    {
      "id": 3,
      "type": "vue",
      "recommendationIndex": 3,
      "name": "vue2+原生js实现上下无缝滚动，鼠标移入停止无缝滚动，可以鼠标滚轮控制滚动，鼠标移出可以继续上下无缝滚动",
      "content": "```js\n<template>\n  <div class=\"scroll-container\" @mouseenter=\"stopScroll\" @mouseleave=\"startScroll\" @wheel=\"onWheel\">\n    <div class=\"scroll-content\">\n      <div class=\"scroll-item\" v-for=\"item in scrollData\" :key=\"item\">{{ item }}</div>\n      <div class=\"scroll-item\" v-for=\"item in scrollData\" :key=\"item\">{{ item }}</div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'SeamlessScroll',\n  data() {\n    return {\n      scrollData: ['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5'],\n      scrollInterval: null,\n      scrollSpeed: 1,\n    }\n  },\n  mounted() {\n    this.startScroll();\n  },\n  beforeDestroy() {\n    clearInterval(this.scrollInterval);\n  },\n  methods: {\n    startScroll() {\n      this.scrollInterval = setInterval(() => {\n        if (this.$el.scrollTop >= this.$el.scrollHeight / 2) {\n          this.$el.scrollTop = 0;\n        } else {\n          this.$el.scrollTop += this.scrollSpeed;\n        }\n      }, 10);\n    },\n    stopScroll() {\n      clearInterval(this.scrollInterval);\n    },\n    onWheel(event) {\n      event.preventDefault();\n      this.$el.scrollTop += event.deltaY;\n    },\n  },\n}\n</script>\n\n<style scoped>\n.scroll-container {\n  height: 200px;\n  overflow: hidden;\n}\n.scroll-content {\n  display: flex;\n  flex-direction: column;\n}\n.scroll-item {\n  height: 50px;\n}\n</style>\n```\n\n"
    },
    {
      "id": 4,
      "type": "vue",
      "recommendationIndex": 4,
      "name": "vue2+Datav实现表格上下无缝滚动",
      "content": "1. 首先需要在vue引入DataV组件 \n   ```js\n   npm install @jiaminghi/data-view\n   ```\n\n   \n\n2. 在main.js注册为全局组件\n   ```js\n   // 将自动注册所有组件为全局组件\n   import dataV from '@jiaminghi/data-view'\n   \n   Vue.use(dataV)\n   ```\n\n3. 使用vue文件代码如下\n   ```vue\n   <template>\n     <div id=\"the-homework-table\">\n       <dv-scroll-board\n         :config=\"config\"\n         style=\"width: 100%; height: 100%\"\n       />\n     </div>\n   </template>\n   \n   <script>\n   export default {\n     data() {\n       return {\n         config: {\n           header: [\n             \"时间\",\n           ],\n           data: [\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n            [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n             [\n               \"2022/11/3 07:45:30\",\n             ],\n           ],\n           index: true,//增加序号显示\n           rowNum: 10,//超过10行启动无缝滚动\n         },\n       };\n     },\n   };\n   </script>\n   \n   <style lang=\"less\" scoped>\n   #the-homework-table {\n     width: 100%;\n     height: 100%;\n   }\n   /deep/ .dv-scroll-board .header {\n     font-size: 25px;\n   }\n   /deep/ .dv-scroll-board .rows .row-item {\n     font-size: 24px;\n   }\n   /deep/ .dv-scroll-board .rows .ceil {\n     text-align: center;\n   }\n   /deep/ .dv-scroll-board .header .header-item {\n     text-align: center;\n   }\n   </style>\n   ```\n\n   "
    },
    {
      "id": 5,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue2+echarts封装组件  饼图组件",
      "content": "```js\n<template>\n  <div ref=\"chart\" :style=\"{ height: '100%', width: '100%' }\"></div>\n</template>\n\n<script>\nimport echarts from \"echarts\";\n\nexport default {\n  props: {\n    // 接受数据作为 props\n    data: {\n      type: Array,\n      required: true,\n    },\n    // 接受颜色作为 props\n    colors: {\n      type: Array,\n      default() {\n        return [\"#00BFFF\", \"#FF6B00\"];\n      },\n    },\n    //标题\n    chartTitle: {\n      type: String,\n      default:''\n    },\n    // 是否显示标签\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    // 标签位置\n    labelPosition: {\n      type: String,\n      default: \"inside\",\n    },\n    // 标签字体大小\n    labelFontSize: {\n      type: Number,\n      default: 14,\n    },\n    // 是否自适应\n    responsive: {\n      type: Boolean,\n      default: true,\n    },\n    // series 名称\n    seriesName: {\n      type: String,\n      required: true,\n    },\n    // 是否显示图例\n    showLegend: {\n      type: Boolean,\n      default: false,\n    },\n    // 图例位置\n    legendPosition: {\n      type: String,\n      default: \"right\",\n    },\n  },\n  data() {\n    return {\n      // 设置初始高度\n      chartHeight: \"300px\",\n    };\n  },\n  mounted() {\n    // 渲染图表\n    this.renderChart();\n    // 如果需要自适应，则监听窗口大小变化\n    if (this.responsive) {\n      window.addEventListener(\"resize\", this.renderChart);\n    }\n  },\n  beforeDestroy() {\n    // 如果需要自适应，则在组件销毁前移除监听器\n    if (this.responsive) {\n      window.removeEventListener(\"resize\", this.renderChart);\n    }\n  },\n  methods: {\n    renderChart() {\n      // 初始化 echarts 实例\n      const chart = echarts.init(this.$refs.chart);\n      // 设置图表选项\n      chart.setOption({\n        title: {\n          text: this.chartTitle,\n          left: \"center\",\n          textStyle: {\n            fontSize: 20,\n            color:'white'\n          },\n        },\n        // 配置提示框\n        tooltip: {\n          trigger: \"item\",\n          formatter: \"{a} <br/>{b}: {c} ({d}%)\",\n        },\n        // 配置图例\n        legend: {\n          show: this.showLegend,\n          orient: this.legendPosition,\n        },\n        // 配置 series\n        series: [\n          {\n            // 设置 series 名称\n            name: this.seriesName,\n            // 设置 series 类型为饼状图\n            type: \"pie\",\n            // 设置饼状图半径\n            radius: [\"50%\", \"70%\"],\n            // 避免标签重叠\n            avoidLabelOverlap: false,\n            // 配置标签\n            label: {\n              show: this.showLabel,\n              position: this.labelPosition,\n              fontSize: this.labelFontSize,\n            },\n            // 配置标签强调样式\n            emphasis: {\n              label: {\n                show: true,\n                fontSize: this.labelFontSize + 2,\n                fontWeight: \"bold\",\n              },\n            },\n            // 配置标签线\n            labelLine: {\n              show: false,\n            },\n            // 配置数据\n            data: this.data.map((item, index) => ({\n              value: item.val,\n              name: item.name,\n              itemStyle: {\n                color: this.colors[index],\n              },\n            })),\n          },\n        ],\n      });\n      // 如果需要自适应，则在渲染后调整图表大小\n      if (this.responsive) {\n        chart.resize();\n      }\n    },\n  },\n};\n</script>\n\n<style>\n/* 可选的图表容器样式 */\n</style>\n```\n\n# 组件使用示例\n\n```js\n<pie-chart\n            :data=\"chartData\"\n            :colors=\"chartColors\"\n            :show-label=\"showLabel\"\n            :label-position=\"labelPosition\"\n            :label-font-size=\"labelFontSize\"\n            :responsive=\"true\"\n            series-name=\"作业统计\"\n            chartTitle=\"作业统计\"\n          />\n  \ndata() {\n    return {\n      chartData: [\n        {name:'已完成',val:10},\n        {name:'未完成',val:20},\n      ],\n      chartColors: ['#00BFFF','#FF6B00'],\n      showLabel: true,\n      labelPosition: 'inside',\n      labelFontSize: 25,\n    }\n  },\n```\n\n"
    },
    {
      "id": 6,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue2+echarts封装组件  柱状图组件",
      "content": "```js\n<template>\n  <div ref=\"chart\" style=\"width: 100%; height: 100%\"></div>\n</template>\n\n<script>\nimport echarts from \"echarts\";\n\nexport default {\n  props: {\n    //颜色\n    colorList: {\n      type: Array,\n      default: () => {\n        return [\"#00BFFF\", \"#FF6B00\"];\n      },\n    },\n    // 图表标题\n    title: {\n      type: String,\n      required: true,\n    },\n    // x 轴数据\n    xAxisData: {\n      type: Array,\n      required: true,\n    },\n    // 数据系列\n    seriesData: {\n      type: Array,\n      required: true,\n    },\n    // 图例数据\n    legendData: {\n      type: Array,\n      required: true,\n    },\n    // tooltip 的 crossStyle\n    crossStyle: {\n      type: Object,\n      default: () => {\n        return {\n          color: \"white\",\n        };\n      },\n    },\n    /**\n     * @description:  字体大小列表，依次为：\n    0. 标题字体大小\n     1. 图例字体大小\n    2. x 轴标签字体大小\n     3. y 轴标签字体大小\n     4. 数据标签字体大小\n     5. tooltip 字体大小\n     * @return {*}\n     */\n    fontSizeList: {\n      type: Array,\n      required: true,\n    },\n  },\n  data() {\n    return {\n      chart: null,\n    };\n  },\n  mounted() {\n    // 初始化 echarts 实例\n    this.chart = echarts.init(this.$refs.chart);\n    // 设置图表配置项\n    this.chart.setOption({\n      color:this.colorList,\n      // 图表标题\n      title: {\n        text: this.title,\n        textStyle: {\n          color: \"#fff\",\n          fontSize: this.fontSizeList[0],\n        },\n      },\n      // tooltip\n      tooltip: {\n        trigger: \"axis\",\n        axisPointer: {\n          type: \"cross\",\n          crossStyle: this.crossStyle,\n        },\n        textStyle: {\n          fontSize: this.fontSizeList[5],\n        },\n      },\n      // 图例\n      legend: {\n        data: this.legendData,\n        textStyle: {\n          color: \"#fff\",\n          fontSize: this.fontSizeList[1],\n        },\n      },\n      // x 轴\n      xAxis: [\n        {\n          type: \"category\",\n          data: this.xAxisData,\n          axisPointer: {\n            type: \"shadow\",\n          },\n          axisLabel: {\n            textStyle: {\n              color: \"#fff\",\n              fontSize: this.fontSizeList[2],\n            },\n          },\n          // 去掉 x 轴的分割线\n          splitLine: {\n            show: false,\n          },\n        },\n      ],\n      // y 轴\n      yAxis: [\n        {\n          type: \"value\",\n          axisLabel: {\n            textStyle: {\n              color: \"#fff\",\n              fontSize: this.fontSizeList[3],\n            },\n          },\n          // 去掉 y 轴的分割线\n          splitLine: {\n            show: false,\n          },\n        },\n      ],\n      // 数据系列\n      series: this.seriesData.map((item) => {\n        return {\n          name: item.name,\n          type: \"bar\",\n          data: item.data,\n          label: {\n            show: this.showLabel,\n            position: this.labelPosition,\n            fontSize: this.fontSizeList[4],\n          },\n        };\n      }),\n    });\n    // 监听窗口大小变化，自适应图表大小\n    window.addEventListener(\"resize\", () => {\n      this.chart.resize();\n    });\n  },\n};\n</script>\n```\n\n# 组件使用示例\n\n```js\n<bar-chart\n            :title=\"chartTitle\"\n            :x-axis-data=\"xAxisData\"\n            :series-data=\"seriesData\"\n            :legend-data=\"legendData\"\n            :cross-style=\"crossStyle\"\n            :font-size-list=\"fontSizeList\"\n          />\n  \ndata() {\n    return {\n      title: \"人员管理\",\n      chartTitle: \"人员统计\",\n      xAxisData: [\"A\", \"B\", \"C\", \"D\", \"E\"],\n      seriesData: [\n        {\n          name: \"员工数量\",\n          data: [10, 20, 30, 40, 50],\n        },\n        {\n          name: \"访客数量\",\n          data: [20, 30, 40, 50, 60],\n        },\n      ],\n      legendData: [\"员工数量\", \"访客数量\"],\n      crossStyle: {\n        color: \"white\",\n      },\n      fontSizeList: [18, 20, 20, 20, 20, 20],\n    };\n  },\n```\n\n"
    },
    {
      "name": "vue2播放flv视频流",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "# 下载flv.js\n\n```js\nnpm install --save flv.js\n```\n\n# 代码示例\n\n```js\n<template>\n  <div>\n\t<video id=\"videoElement\" controls autoplay muted width=\"300px\" height=\"200px\">    \n    </video>\n\t<button @click=\"play\">播放</button>\n  </div>\n</template>\n<script>\n    import flvjs from 'flv.js'\nexport default {\n  data () {\n    return {\n\t  flvPlayer:null\n    }\n  },\n   mounted() {\n      if (flvjs.isSupported()) {\n        var videoElement = document.getElementById('videoElement');\n        this.flvPlayer = flvjs.createPlayer({\n          type: 'flv',\n\t\t  isLive: true,\n\t\t  hasAudio: false,\n          url: 'http://1011.hlsplay.aodianyun.com/demo/game.flv'\n        });\n        this.flvPlayer.attachMediaElement(videoElement);\n        try {\n            this.flvPlayer.load()\n            this.flvPlayer.play()\n          } catch (e) {\n            console.log(e)\n          }\n      }\n    },\n    methods:{\n      play () {\n        this.flvPlayer.play();\n      }\n    },\n    beforeDestroy(){\n        this.flvPlayer && this.flvPlayer.destory()\n    }\n}\n</script>\n\n```\n\n",
      "id": 7
    },
    {
      "id": 8,
      "type": "vue",
      "recommendationIndex": 5,
      "name": "vue+nginx部署",
      "content": "# vue\n\nvue.config.js配置如下\n\n```js\nconst {defineConfig} = require('@vue/cli-service')\nmodule.exports = defineConfig({\n    transpileDependencies: true,\n    //打包\n    publicPath: './',\n    devServer: {\n        host: '0.0.0.0',\n        port: 8080,\n        proxy: {\n            '/captures': {\n                target: 'http://192.168.1.150:18080', // 目标路径，别忘了加http和端口号 也就是接口的前面的ip地址端口号\n                changeOrigin: true, // 是否跨域\n            }\n        }\n    }\n})\n \n```\n\n# nginx\n\nnginx.conf配置如下\n\n```json\n\nuser  root;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n    \t# 服务器端口号\n        listen       80; \n    \t# 服务器名称\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n        location / {\n            root    /zckx/nginx/html/dist; #项目文件位置\n            index  index.html;\n            try_files $uri $uri/ /index.html;\n        }\n\t\t# 配置跨域 比如接口以/captures开头的配置如下\n        location /captures/ {\n            # 允许http://192.168.1.150:18080跨域 http://192.168.1.150:18080为接口地址\n            proxy_pass http://192.168.1.150:18080; \n        }\n\n        location /live{\n            add_header Access-Control-Allow-Origin *;\n            types {\n                application/vnd.apple.mpegurl m3u8;\n                video/mp2t ts;\n            }\n            # HLS切片文件目录\n            alias /tmp/hls;\n            expires -1;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n\nrtmp {\n        server {\n                listen 1935;\n                chunk_size 4096;\n                # vod path\n                application live {\n                        live on;\n                        hls on;\n                        ##HLS切片保存路径\n                        hls_path /tmp/hls;\n                        hls_fragment 4;\n                        hls_playlist_length 30;\n                        record off;\n                }\n        }\n}\n\n\n\n\n```\n\n"
    },
    {
      "name": "vue二次封装axios",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "## 代码\n在src创建request文件夹 新建axios.js\n\n```js\nimport axios from 'axios';\nimport {Message} from 'element-ui';\n// 统一请求路径前缀\nlet baseApi = \"/\";\n\n// 超时设定\naxios.defaults.timeout = 20000;\n\naxios.interceptors.request.use(config => {\n    return config;\n}, err => {\n    Message.error('请求超时');\n    return Promise.reject(err);\n});\n\n// http response 拦截器\naxios.interceptors.response.use(response => {\n    return response.data;\n}, (err) => {\n    // 返回状态码不为200时候的错误处理\n    Message.error(err.toString());\n    return Promise.reject(err);\n});\n\nexport const getRequest = (url, params) => {\n    return axios({\n        method: 'get',\n        url: `${baseApi}${url}`,\n        params: params,\n    });\n};\n\nexport const postRequest = (url, params) => {\n    return axios({\n        method: 'post',\n        url: `${baseApi}${url}`,\n        data: params,\n    });\n};\n\nexport const putRequest = (url, params) => {\n    return axios({\n        method: 'put',\n        url: `${baseApi}${url}`,\n        data: params,\n    });\n};\n```\n# Axios 请求模块使用说明\n\n这是一个基于 `axios` 的 HTTP 请求模块，提供了 `get`、`post` 和 `put` 方法的封装。\n\n## 配置\n\n- 请求超时时间：20000 毫秒\n- 请求路径前缀：`/`\n\n## 拦截器\n\n- 请求拦截器：在请求被发送之前进行拦截，如果请求超时，将显示错误消息 \"请求超时\"。\n- 响应拦截器：在响应被返回之前进行拦截，如果返回状态码不为 200，将显示错误消息。\n\n## 方法\n\n### getRequest(url, params)\n\n发送 GET 请求。\n\n参数：\n\n- `url`：请求的 URL\n- `params`：请求的参数\n\n### postRequest(url, params)\n\n发送 POST 请求。\n\n参数：\n\n- `url`：请求的 URL\n- `params`：请求的参数\n\n### putRequest(url, params)\n\n发送 PUT 请求。\n\n参数：\n\n- `url`：请求的 URL\n- `params`：请求的参数\n\n## 使用示例\n可以再封装一层，比如创建一个note.js,如下:\n```js\nimport { getRequest, postRequest, delRequest, putRequest } from '@/request/axios'\n\nexport default {\n  getNote: (params) => {\n    return getRequest('note', params)\n  },\n  postNote: (params) => {\n    return postRequest('note', params)\n  },\n  delNote: (params) => {\n    return delRequest(`note/${params}`)\n  },\n  putNote: (url1, params) => {\n    return putRequest(`note`, url1, params)\n  }\n}\n```\n接下来使用就很简单了，如下:\n先引入：\n```javascript\nimport Note from \"@/api/note\";\n```\n随便使用一个接口，如下：\n```js\nNote.getNote()\n        .then((list) => {\n          console.log(list);\n        })\n        .catch((_) => {\n        });\n```\n",
      "id": 9
    },
    {
      "name": "vue2+mqtt.js封装",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "这是一个使用 MQTT.js 的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 MQTT.js。\n\n## 安装\n\n首先，你需要在你的项目中安装 MQTT.js。你可以通过 npm 来安装：\n\n```bash\nnpm install mqtt --save\n```\n\n## 封装插件\n\n```js\n// 导入 mqtt 库\nimport * as mqtt from 'mqtt'\n\nexport default {\n  install(Vue) {\n    // 在 Vue 的原型上添加一个名为 $mqtt 的方法\n    Vue.prototype.$mqtt = (url, topics, option) => {\n      // 设置 MQTT 客户端的选项\n      const options = {\n        reconnectPeriod: 1000, // 如果连接断开，客户端将在1秒后尝试重新连接\n        ...option\n      }\n\n      // 创建一个新的 MQTT 客户端并连接到服务器\n      const client = mqtt.connect(url, options)\n\n      // 当客户端连接到服务器时，打印一条消息并订阅主题\n      client.on('connect', () => {\n        console.log('MQTT client connected')\n        // 订阅主题\n        topics && topics.forEach(topic => client.subscribe(topic))\n      })\n\n      // 当客户端遇到错误时，打印错误消息\n      client.on('error', (error) => {\n        console.error('MQTT client encountered an error:', error)\n      })\n\n      // 当客户端正在尝试重新连接时，打印一条消息\n      client.on('reconnect', () => {\n        console.log('MQTT client is attempting to reconnect')\n      })\n\n      // 返回一个对象，该对象包含一些方法，这些方法可以在 Vue 组件中使用\n      return {\n        // 收到消息时的回调函数\n        message: (callback) => {\n          client.on('message', (topic, message) => {\n            callback(topic, message.toString())\n          })\n        },\n        // 发送消息\n        publish: function(topic, message, callback) {\n          client.publish(topic, message)\n          callback()\n        },\n\n        // 关闭客户端\n        end: callback => {\n          client.end()\n          callback()\n        }\n      }\n    }\n  }\n}\n\n```\n\n\n\n然后，将上述代码保存为 `mqttPlugin.js` 文件，并将其放在你的项目的 `src/plugins` 目录下。\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `$mqtt` 方法来创建一个新的 MQTT 客户端。以下是 `$mqtt` 方法的参数：\n\n- `url`：MQTT 服务器的 URL。\n- `topics`：一个数组，包含你想要订阅的主题。\n- `option`：一个对象，包含 MQTT 客户端的选项。这个对象会和默认选项合并。默认选项包括 `reconnectPeriod: 1000`，表示如果连接断开，客户端将在1秒后尝试重新连接。\n\n`$mqtt` 方法返回一个对象，该对象包含以下方法：\n\n- `message(callback)`：设置一个回调函数，当收到任何主题的消息时，该回调函数会被调用。回调函数接受两个参数，即主题和消息的内容（字符串格式）。\n- `publish(topic, message, callback)`：向指定主题发送一个消息，然后调用回调函数。\n- `end(callback)`：关闭 MQTT 客户端，然后调用回调函数。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `mqttPlugin` 插件的示例：\n\n```javascript\n<template>\n  <div>\n    <button @click=\"connect\">Connect</button>\n    <button @click=\"sendMessage\">Send Message</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      mqttClient: null\n    }\n  },\n  methods: {\n    connect() {\n      this.mqttClient = this.$mqtt('mqtt://test.mosquitto.org', ['topic1', 'topic2'])\n\n      this.mqttClient.message((topic, message) => {\n        console.log(`Received message on ${topic}: ${message}`)\n      })\n    },\n    sendMessage() {\n      this.mqttClient.publish('topic1', 'Hello, MQTT!', () => {\n        console.log('Message sent')\n      })\n    },\n    disconnect() {\n      this.mqttClient.end(() => {\n        console.log('MQTT client disconnected')\n      })\n    }\n  },\n  beforeDestroy() {\n    // 在组件销毁时关闭 MQTT 客户端\n    this.disconnect()\n  },\n}\n</script>\n```\n\n在这个示例中，当你点击 “Connect” 按钮时，会创建一个新的 MQTT 客户端并连接到服务器。当你点击 “Send Message” 按钮时，会向 `topic1` 发送一个消息。当你离开当前页面路由，会断开 MQTT 客户端的连接。",
      "id": 10
    },
    {
      "name": "vue2+elementui二次封装",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "# 封装el-dialog\n\n这是一个使用 `Dialog` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `Dialog` 组件。\n\n## 代码\n\n```js\n<template>\n  <div id=\"Dialog\">\n    <el-dialog :title=\"title\" :fullscreen=\"fullscreen\" :center=\"center\" :visible=\"visible\" :width=\"width\"\n               :custom-class=\"customClass\" @open=\"openDialog\"\n               @close=\"closeDialog\"\n    >\n      <template v-slot:title>\n        <slot name=\"title\"/>\n      </template>\n      <template v-slot:default>\n        <slot name=\"content\"/>\n      </template>\n      <template v-slot:footer>\n        <slot name=\"footer\"/>\n      </template>\n    </el-dialog>\n  </div>\n</template>\n<script>\nexport default {\n  name: 'Dialog',\n  props: {\n    // 是否显示弹框\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    // 弹框标题\n    title: {\n      type: String,\n      default: ''\n    },\n    // 弹框宽度\n    width: {\n      type: String,\n      default: '50%'\n    },\n    // Dialog 的自定义类名\n    customClass: {\n      type: String,\n      default: ''\n    },\n    // 标题是否居中\n    center: {\n      type: Boolean,\n      default: true\n    },\n    // 弹框是否全屏显示\n    fullscreen: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    /**\n     * 打开弹窗回调\n     * */\n    openDialog() {\n      console.log('你打开了弹窗')\n      this.$emit('openDialog')\n    },\n    /**\n     * 关闭弹窗回调\n     * */\n    closeDialog() {\n      this.$emit('closeDialog', false)\n      console.log('你关闭了弹窗')\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"scss\">\n::v-deep .el-dialog__header{\n  height: 5vh;\n  box-sizing: border-box;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n</style>\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `Dialog` 组件来创建一个新的对话框。以下是 `Dialog` 组件的属性：\n\n- `visible`：是否显示对话框。默认值为 `false`。\n- `title`：对话框的标题。默认值为 `''`。\n- `width`：对话框的宽度。默认值为 `'50%'`。\n- `customClass`：对话框的自定义类名。默认值为 `''`。\n- `center`：标题是否居中。默认值为 `true`。\n- `fullscreen`：对话框是否全屏显示。默认值为 `false`。\n\n`Dialog` 组件还包含以下方法：\n\n- `openDialog`：打开对话框时的回调函数。你可以监听 `openDialog` 事件来执行自定义的逻辑。\n- `closeDialog`：关闭对话框时的回调函数。你可以监听 `closeDialog` 事件来执行自定义的逻辑。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `Dialog` 组件的示例：\n\n```js\n<template>\n  <div>\n    <button @click=\"visible = true\">Open Dialog</button>\n    <Dialog :visible=\"visible\" @closeDialog=\"visible = false\">\n      <template v-slot:title>\n        <h2>Dialog Title</h2>\n      </template>\n      <template v-slot:content>\n        <p>Dialog Content</p>\n      </template>\n      <template v-slot:footer>\n        <button @click=\"visible = false\">Close Dialog</button>\n      </template>\n    </Dialog>\n  </div>\n</template>\n\n<script>\nimport Dialog from './Dialog'\n\nexport default {\n  components: {\n    Dialog\n  },\n  data() {\n    return {\n      visible: false\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，当你点击 “Open Dialog” 按钮时，对话框会打开。当你点击 “Close Dialog” 按钮时，对话框会关闭。\n# 封装el-table表格组件+el-pagination分页组件\n## 代码\n\nTablePagination 是一个包含表格和分页功能的 Vue 组件。代码如下。\n```js\n<template>\n  <div>\n    <!-- 表格组件 -->\n    <el-table max-height=\"maxHeight\" height=\"auto\" :data=\"tableData\" :style=\"{ width: width }\">\n      <!-- 动态生成表格列 -->\n      <el-table-column\n        v-for=\"(item, index) in columns\"\n        :key=\"index\"\n        :prop=\"item.prop\"\n        :label=\"item.label\"\n      >\n      </el-table-column>\n    <!-- 自定义插槽用于表格内容 -->\n    <slot name=\"table\"></slot>\n    </el-table>\n    <!-- 分页组件 -->\n    <el-pagination\n      @size-change=\"handleSizeChange\"\n      @current-change=\"handleCurrentChange\"\n      :current-page=\"currentPage\"\n      :page-sizes=\"[10, 20, 30, 40]\"\n      :page-size=\"pageSize\"\n      layout=\"total, sizes, prev, pager, next, jumper\"\n      :total=\"total\"\n    >\n    </el-pagination>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"TablePagination\",\n  props: {\n    // 表格数据\n    tableData: {\n      type: Array,\n      default: () => [],\n    },\n    // 表格列配置\n    columns: {\n      type: Array,\n      default: () => [],\n    },\n    // 当前页码\n    currentPage: {\n      type: Number,\n      default: 1,\n    },\n    // 每页显示数量\n    pageSize: {\n      type: Number,\n      default: 10,\n    },\n    // 总数据量\n    total: {\n      type: Number,\n      default: 0,\n    },\n    // 表格宽度\n    width: {\n      type: Number,\n      default: 0,\n    },\n    // 表格最大高度\n    maxHeight: {\n      type: Number,\n      default: 0,\n    },\n  },\n  methods: {\n    // 处理每页显示数量变化\n    handleSizeChange(val) {\n      this.$emit(\"updatePageSize\", val);\n    },\n    // 处理当前页码变化\n    handleCurrentChange(val) {\n      this.$emit(\"updateCurrentPage\", val);\n    },\n  },\n};\n</script>\n<style lang=\"scss\">\n.el-pagination {\n  margin-top: 20px;\n  text-align: right;\n}\n</style>\n```\n\n## Props\n\n- `tableData` (Array): 表格数据，默认为空数组。\n- `columns` (Array): 表格列配置，默认为空数组。\n- `currentPage` (Number): 当前页码，默认为 1。\n- `pageSize` (Number): 每页显示数量，默认为 10。\n- `total` (Number): 总数据量，默认为 0。\n- `width` (Number): 表格宽度，默认为 0。\n- `maxHeight` (Number): 表格最大高度，默认为 0。\n\n## Events\n\n- `updatePageSize`: 当每页显示数量变化时触发，参数为新的每页显示数量。\n- `updateCurrentPage`: 当当前页码变化时触发，参数为新的当前页码。\n\n## 使用示例(模拟后端)\n\n```js\n<template>\n  <div>\n    <!-- 使用TablePagination组件 -->\n    <TablePagination\n      :table-data=\"tableData\"\n      :columns=\"tableColumns\"\n      :current-page=\"currentPage\"\n      :page-size=\"pageSize\"\n      :total=\"total\"\n      :width=\"800\"\n      :max-height=\"400\"\n      @update-page-size=\"handlePageSizeChange\"\n      @update-current-page=\"handleCurrentPageChange\"\n    >\n      <!-- 自定义表格内容插槽 -->\n     <template v-slot:table>\n      <el-table-column label=\"操作\" align=\"center\" width=\"170\">\n            <template slot-scope=\"scope\">\n              <el-button\n                type=\"primary\"\n                @click=\"handleEdit(scope.$index, scope.row)\"\n              >修改\n              </el-button>\n              <el-popconfirm\n                title=\"确定删除这一项吗？\"\n                style=\"margin-left: 10px\"\n                @onConfirm=\"handleDelete(scope.$index, scope.row)\"\n              >\n                <el-button\n                  slot=\"reference\"\n                  type=\"danger\"\n                >删除\n                </el-button>\n              </el-popconfirm>\n\n            </template>\n          </el-table-column>\n      </template>\n    </TablePagination>\n  </div>\n</template>\n\n<script>\n// 引入axios\nimport axios from 'axios';\nimport TablePagination from './TablePagination'; // 请根据实际文件路径修改\n\nexport default {\n  data() {\n    return {\n      tableData: [],       // 存储表格数据\n      tableColumns: [],    // 存储表格列配置\n      currentPage: 1,      // 当前页码\n      pageSize: 10,        // 每页显示数量\n      total: 0,            // 总数据量\n    };\n  },\n  created() {\n    // 在组件创建时调用获取表格数据的方法\n    this.fetchTableData();\n  },\n  methods: {\n    // 使用axios模拟后端获取表格数据\n    fetchTableData() {\n      // 模拟后端数据接口\n      const apiUrl = 'https://jsonplaceholder.typicode.com/posts'; // 请根据实际接口地址修改\n\n      // 使用axios发送GET请求\n      axios.get(apiUrl, {\n        params: {\n          _page: this.currentPage,   // 当前页码\n          _limit: this.pageSize,     // 每页显示数量\n        },\n      })\n      .then(response => {\n        // 成功获取数据后更新表格数据和总数据量\n        this.tableData = response.data;\n        this.total = parseInt(response.headers['x-total-count']);\n      })\n      .catch(error => {\n        console.error('获取表格数据失败', error);\n      });\n    },\n    // 处理每页显示数量变化\n    handlePageSizeChange(newPageSize) {\n      this.pageSize = newPageSize;\n      this.fetchTableData(); // 每页显示数量变化时重新获取数据\n    },\n    // 处理当前页码变化\n    handleCurrentPageChange(newCurrentPage) {\n      this.currentPage = newCurrentPage;\n      this.fetchTableData(); // 当前页码变化时重新获取数据\n    },\n    // 处理编辑操作\n    handleEdit(index, row) {\n      // 在这里可以添加编辑的逻辑，例如跳转到编辑页面或弹出编辑框\n      console.log('编辑操作', index, row);\n    },\n\n    // 处理删除操作\n    handleDelete(index, row) {\n      // 在这里可以添加删除的逻辑，例如弹出确认框后执行删除操作\n      console.log('删除操作', index, row);\n\n      // 模拟删除后更新表格数据\n      this.tableData.splice(index, 1);\n\n      // 如果需要通知后端执行删除操作，可以在此处添加相应的axios请求\n      // 例如，删除某项记录的接口为 '/api/deleteItem'\n      // axios.delete('/api/deleteItem', { data: { id: row.id } })\n      //   .then(response => {\n      //     console.log('删除成功', response);\n      //     // 成功后刷新表格数据等操作\n      //   })\n      //   .catch(error => {\n      //     console.error('删除失败', error);\n      //     // 失败后的处理\n      //   });\n    },\n  },\n  components: {\n    TablePagination,  // 注册TablePagination组件\n  },\n};\n</script>\n\n<style scoped>\n/* 可以添加组件内部的样式 */\n</style>\n```",
      "id": 11
    },
    {
      "name": "vue2+动态表单生成设计(根据后端返回显示对应表单)",
      "type": "vue",
      "recommendationIndex": 4,
      "content": "这是一个使用 `DynamicForms` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `DynamicForms` 组件。\n\n## 代码\n\n```js\n<template>\n  <div v-if=\"Object.keys(args).length\">\n    <div v-for=\"(item, index) in dynamicComponentParameters\" :key=\"index\">\n      <el-form-item v-if=\"item.type === 'el-input'\" :label=\"item.name\">\n        <el-input v-model=\"args[item.val]\" />\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-select'\" :label=\"item.name\">\n        <el-select v-model=\"args[item.val]\" :placeholder=\"item.placeholder\">\n          <el-option\n            v-for=\"selectVal of item.selectList\"\n            :key=\"selectVal.label\"\n            :label=\"selectVal.label\"\n            :value=\"selectVal.value\"\n          />\n        </el-select>\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-checkbox'\" :label=\"item.name\">\n        <el-checkbox-group v-model=\"args[item.val]\">\n          <el-checkbox\n            v-for=\"checkVal of item.checkList\"\n            :key=\"checkVal.label\"\n            :label=\"checkVal.label\"\n          />\n        </el-checkbox-group>\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-radio'\" :label=\"item.name\">\n        <el-radio-group v-model=\"args[item.val]\">\n          <el-radio\n            v-for=\"radioVal of item.radioList\"\n            :key=\"radioVal.label\"\n            :label=\"radioVal.label\"\n          />\n        </el-radio-group>\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-input-number'\" :label=\"item.name\">\n        <el-input-number v-model=\"args[item.val]\" :step=\"item.step\" :min=\"item.min\" :max=\"item.max\" />\n      </el-form-item>\n      <el-form-item v-if=\"item.type === 'el-switch'\" :label=\"item.name\">\n        <el-switch v-model=\"args[item.val]\" />\n      </el-form-item>\n    </div>\n  </div>\n</template>\n<script>\nimport { Loading } from 'element-ui'\n\nexport default {\n  name: 'DynamicForms',\n  props: {\n    // 动态组件列表\n    dynamicComponentParameters: {\n      type: Array,\n      default() {\n        return []\n      }\n    },\n    // 动态组件绑定后传值的参数\n    // eslint-disable-next-line vue/require-default-prop\n    args: {\n      type: Object,\n      default() {\n        return {}\n      }\n    }\n  },\n  data() {\n    return {\n      // 默认参数值\n      defaultValues: {\n        'string': '',\n        'number': 0,\n        'boolean': false,\n        'array': [],\n        'object': {},\n        'function': function() {\n        }\n      },\n      // 加载状态\n      loadingInstance: null\n    }\n  },\n  computed: {\n    // 参数默认值列表\n    argList() {\n      // eslint-disable-next-line vue/no-async-in-computed-properties\n      return new Promise((resolve, reject) => {\n        this.loadingInstance = Loading.service({\n          fullscreen: true,\n          text: '加载中,请稍等....'\n        })\n        // 模拟接口异步\n        setTimeout(() => {\n          const argList = this.dynamicComponentParameters.map(item => {\n            return {\n              name: item.val,\n              type: item.valType\n            }\n          })\n          resolve(argList)\n        }, 1000)\n      })\n    },\n    // 更新后的ages参数\n    newArgs() {\n      const args = this.args\n      // eslint-disable-next-line vue/no-async-in-computed-properties\n      this.argList.then(res => {\n        res.forEach(list => {\n          console.log(this.defaultValues[list.type])\n          this.$set(args, list.name, this.defaultValues[list.type])\n        })\n        this.loadingInstance.close()\n      })\n      return args\n    }\n  },\n  mounted() {\n    this.init()\n  },\n  methods: {\n    init() {\n      /**\n       * 初始化的时候给动态组件绑定后传值的参数赋默认值\n       * 可根据后端传值的类型和字段赋默认值\n       * */\n      this.$emit('update:args', this.newArgs)\n      console.log(this.args.length)\n    }\n  }\n}\n</script>\n<style scoped lang=\"scss\">\n\n</style>\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `DynamicForms` 组件来创建一个动态表单。以下是 `DynamicForms` 组件的属性：\n\n- `dynamicComponentParameters`：动态组件列表，数组类型，默认值为 `[]`。每个元素是一个对象，包含以下属性：\n  - `type`：组件类型，例如 `'el-input'`、`'el-select'` 等。\n  - `name`：组件的标签。\n  - `val`：组件的值，将绑定到 `args` 对象的对应属性上。\n  - `selectList`、`checkList`、`radioList`：当组件类型为 `'el-select'`、`'el-checkbox'` 或 `'el-radio'` 时，这些属性包含了选项列表。\n  - `step`、`min`、`max`：当组件类型为 `'el-input-number'` 时，这些属性用于设置数字输入框的步长、最小值和最大值。\n\n- `args`：动态组件绑定后传值的参数，对象类型，默认值为 `{}`。对象的每个属性对应一个动态组件，属性名为组件的 `val`，属性值为组件的值。\n\n`DynamicForms` 组件还包含以下方法：\n\n- `init`：初始化的时候给动态组件绑定后传值的参数赋默认值，可根据后端传值的类型和字段赋默认值。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `DynamicForms` 组件的示例：\n\n```js\n<template>\n  <div>\n    <dynamic-forms\n              :args.sync=\"algorithmInfo.args\"\n              :dynamic-component-parameters=\"dynamicComponentParameters\"\n            />\n  </div>\n</template>\n\n<script>\nimport DynamicForms from './DynamicForms'\n\nexport default {\n  components: {\n    DynamicForms\n  },\n  data() {\n    return {\n      // 动态组件参数\n      dynamicComponentParameters: [\n        {\n          type: 'el-input', // 表单类型\n          name: '名字', // 表单标题\n          val: 'name', // 表单传给后端值的参数名\n          valType: 'string'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-select', // 表单类型\n          name: '性别', // 表单标题\n          selectList: [\n            {\n              label: '男',\n              value: 'man'\n            },\n            {\n              label: '女',\n              value: 'woman'\n            }\n          ], // 若为选择框则需要提供selectList列表，表示下拉选项\n          val: 'gender', // 表单传给后端值的参数名\n          placeholder: '请选择性别',\n          valType: 'string'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-checkbox', // 表单类型\n          name: '兴趣', // 表单标题\n          checkList: [\n            {\n              label: '篮球'\n            },\n            {\n              label: '足球'\n            }\n          ], // 若为单选框则需要提供checklist列表，表示选项\n          val: 'interest', // 表单传给后端值的参数名\n          valType: 'array'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-radio', // 表单类型\n          name: '活动', // 表单标题\n          radioList: [\n            {\n              label: '活动1'\n            },\n            {\n              label: '活动2'\n            }\n          ], // 若为单选框则需要提供radioList列表，表示选项\n          val: 'activity', // 表单传给后端值的参数名\n          valType: 'string'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-input-number', // 表单类型\n          name: '年龄', // 表单标题\n          min: 1, // 最小值\n          max: 100, // 最大值\n          step: 0.1, // 按钮控制步数\n          val: 'age', // 表单传给后端值的参数名\n          valType: 'string'// 表单传给后端值的参数类型\n        },\n        {\n          type: 'el-switch', // 表单类型\n          name: '参加', // 表单标题\n          val: 'attend', // 表单传给后端值的参数名\n          valType: 'boolean'// 表单传给后端值的参数类型\n        }\n      ],\n      // 算法信息\n      algorithmInfo: {\n        // 算法名称\n        name: '',\n        group: '',\n        type: '',\n        args: {}\n      },\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，你需要提供你的动态组件参数列表 `dynamicComponentParameters` 和动态组件绑定后传值的参数 `args`。",
      "id": 12
    },
    {
      "id": 13,
      "type": "vue",
      "recommendationIndex": 4,
      "name": "vue2播放hls视频流)",
      "content": "这是一个使用 `HLSPlay` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `HLSPlay` 组件。\n\n## 下载\n\n```js\nnpm install vue-video-player@5.0.2\nnpm install videojs-contrib-hls@5.14.1\n```\n\n## 代码\n\n```js\n<template>\n  <section class=\"HLSPlay-component\">\n    <video-player\n      ref=\"videoPlayer\"\n      class=\"video-player-box\"\n      :options=\"playerOptions\"\n      :playsinline=\"true\"\n      custom-event-name=\"customstatechangedeventname\"\n    />\n  </section>\n</template>\n<script>\nimport 'video.js/dist/video-js.css'\nimport 'videojs-contrib-hls'\nimport { videoPlayer } from 'vue-video-player'\n\nexport default {\n  name: 'HLSPlay',\n  components: {\n    videoPlayer\n  },\n  props: {\n    // eslint-disable-next-line vue/require-default-prop\n    src: {\n      type: String\n    },\n    // eslint-disable-next-line vue/prop-name-casing,vue/require-default-prop\n    cover_url: {\n      type: String\n    }\n  },\n  data() {\n    return {\n      playerOptions: {\n        autoplay: true,\n        muted: true,\n        preload: '63:25',\n        language: 'zh-CN',\n        fluid: true,\n        // playbackRates: [0.7, 1.0, 1.5, 2.0],\n        sources: [\n          {\n            type: 'application/x-mpegURL',\n            src: this.src // 路径\n            // src: 'https://cdn.theguardian.tv/webM/2015/07/20/150716YesMen_synd_768k_vp8.webm'\n          }\n        ],\n        poster: this.cover_url, // 你的封面地址\n        notSupportedMessage: '此视频暂无法播放，请稍后再试'\n        // controlBar: {\n        //   timeDivider: true,\n        //   durationDisplay: true,\n        //   remainingTimeDisplay: false,\n        //   fullscreenToggle: true, // 全屏按钮\n        //   currentTimeDisplay: true, // 当前时间\n        //   volumeControl: false, // 声音控制键\n        //   playToggle: false, // 暂停和播放键\n        //   // progressControl: true // 进度条\n        // }\n      }\n    }\n  },\n  computed: {\n    player() {\n      return this.$refs.videoPlayer.player\n    }\n  },\n  mounted() {\n    // this.play()\n    // console.log('this is current player instance object', this.player)\n  },\n  beforeDestroy() {\n    this.player && this.player.dispose()\n  },\n  methods: {\n    setSrc(src) {\n      this.player.src({ src: src, type: 'application/x-mpegURL' })\n    },\n    play() {\n      try {\n        this.$nextTick(() => {\n          this.player.play().then(res => {\n            this.$message('获取视频成功')\n          }).catch(e => {\n            console.log(e, '失败')\n          }) // 播放\n        })\n      } catch (e) {\n        console.log(e)\n      }\n      // 手动触发播放\n    }\n  }\n\n}\n</script>\n<style lang=\"scss\" scoped>\n.HLSPlay-component{\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  ::v-deep.video-player-box{\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    #vjs_video_1{\n      height: 100%;\n    }\n   #vjs_video_3 {\n      height: inherit;\n      padding-top: 36.25% !important;\n    }\n  }\n}\n::v-deep.video-player {\n  //.vjs_video_3-dimensions {\n  //  width: 100%;\n  //  height: 96%;\n  //}\n\n  // 初始化，暂停按钮居中\n  .vjs-big-play-button {\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n\n  .video-js .vjs-tech {\n    object-fit: fill;\n    height: 100%;\n  }\n  .vjs-fluid{\n    padding-top: 2vw !important;\n    height: inherit;\n  }\n}\n</style>\n\n\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `HLSPlay` 组件来创建一个 HLS 视频播放器。以下是 `HLSPlay` 组件的属性：\n\n- `src`：视频源的 URL，字符串类型。\n- `cover_url`：视频封面的 URL，字符串类型。\n\n`HLSPlay` 组件还包含以下方法：\n\n- `setSrc(src)`：设置新的视频源。\n- `play()`：播放视频。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `HLSPlay` 组件的示例：\n\n```vue\n<template>\n  <div>\n    <HLSPlay :src=\"videoSrc\" :cover_url=\"coverUrl\" ref=\"hlsPlayer\" />\n    <button @click=\"changeVideo\">Change Video</button>\n  </div>\n</template>\n\n<script>\nimport HLSPlay from './HLSPlay'\n\nexport default {\n  components: {\n    HLSPlay\n  },\n  data() {\n    return {\n      videoSrc: 'https://path/to/your/video.m3u8',\n      coverUrl: 'https://path/to/your/cover.jpg'\n    }\n  },\n  methods: {\n    changeVideo() {\n      this.videoSrc = 'https://path/to/another/video.m3u8'\n      this.$refs.hlsPlayer.setSrc(this.videoSrc)\n      this.$refs.hlsPlayer.play()\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，`HLSPlay` 组件用于播放一个 HLS 视频。当你点击 “Change Video” 按钮时，视频源会被更改，新的视频会开始播放。希望这个文档能对你有所帮助！"
    },
    {
      "name": "闭包",
      "id": 14,
      "type": "js",
      "recommendationIndex": 5,
      "content": "闭包 让私有变量变成全局变量 一般写法都是a函数里面return一个b函数 从而让a函数里面的变量变为全局变量 也就是每次调用a函数 里面的变量就不会初始化 而是继续保留上次的值 原理是一个函数只要在调用 那么它所在的环境不会被销毁 闭包正是因为返回一个b函数 当这个函数被调用 那么它所在的a函数里面的环境就不会被销毁 从而得就让私有变量变成全局变量"
    },
    {
      "name": "this",
      "type": "js",
      "recommendationIndex": 4,
      "content": "在JavaScript中，`this`关键字是一个特殊的变量，它在函数被调用时自动定义。`this`的值取决于函数如何被调用，而不是函数如何被定义或者在哪里被定义。\n\n以下是`this`在不同情况下的值：\n\n1. **全局作用域或函数外部**：在全局作用域或函数外部，`this`指向全局对象。在浏览器中，全局对象是`window`。\n\n```javascript\nconsole.log(this); // 输出: Window {...} (或者全局对象的其他表示)\n```\n\n2. **函数内部**：在函数内部，`this`的值取决于函数如何被调用。如果函数是普通函数调用，`this`通常指向全局对象（在严格模式下，`this`会是`undefined`）。\n\n```javascript\nfunction myFunction() {\n  console.log(this);\n}\nmyFunction(); // 输出: Window {...} (或者全局对象的其他表示)\n```\n\n3. **对象方法中**：当函数作为对象的方法被调用时，`this`指向调用该方法的对象。\n\n```javascript\nlet myObject = {\n  property: 'I am an object!',\n  myMethod: function() {\n    console.log(this);\n  }\n};\nmyObject.myMethod(); // 输出: myObject\n```\n\n4. **构造函数中**：在构造函数中，`this`指向新创建的对象实例。\n\n```javascript\nfunction MyConstructor() {\n  this.property = 'I am a new object!';\n}\nlet myObject = new MyConstructor();\nconsole.log(myObject.property); // 输出: 'I am a new object!'\n```\n\n5. **事件处理函数中**：在事件处理函数中，`this`通常指向触发事件的元素。\n\n```javascript\nbutton.addEventListener('click', function() {\n  console.log(this); // 输出: <button> element\n});\n```\n\n6. **箭头函数中**：箭头函数不绑定自己的`this`，它会捕获其所在（即定义的位置）上下文的`this`值。\n\n```javascript\nlet myObject = {\n  myMethod: function() {\n    console.log(this); // 输出: myObject\n    let arrowFunction = () => {\n      console.log(this); // 输出: myObject\n    };\n    arrowFunction();\n  }\n};\nmyObject.myMethod();\n```\n\n7. **使用call, apply, bind方法调用/绑定**：`call`，`apply`和`bind`方法可以用来改变函数调用时`this`的指向。\n\n```javascript\nfunction myFunction() {\n  console.log(this);\n}\nlet myObject = {property: 'I am an object!'};\nmyFunction.call(myObject); // 输出: myObject\n```\n`call`, `apply` 和 `bind` 是JavaScript中的函数方法，它们都可以改变函数的`this`指向。\n\n1. ***call方法***：`call`方法可以改变函数的`this`指向，并立即执行这个函数。`call`方法的第一个参数是`this`应该指向的对象，其余参数是传递给函数的参数。\n\n```javascript\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\n\nlet person = {name: 'Alice'};\ngreet.call(person, 'Hello', '!'); // 输出: 'Hello, Alice!'\n```\n\n2. ***apply方法***：`apply`方法和`call`方法非常相似，也可以改变函数的`this`指向，并立即执行这个函数。不同的是，`apply`方法的第二个参数是一个数组，这个数组的元素会作为参数传递给函数。\n\n```javascript\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\n\nlet person = {name: 'Alice'};\ngreet.apply(person, ['Hello', '!']); // 输出: 'Hello, Alice!'\n```\n\n3. ***bind方法***：`bind`方法可以改变函数的`this`指向，但不会立即执行这个函数，而是返回一个新的函数。这个新的函数在被调用时，`this`会指向`bind`方法的第一个参数。\n\n```javascript\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\n\nlet person = {name: 'Alice'};\nlet greetAlice = greet.bind(person, 'Hello', '!');\ngreetAlice(); // 输出: 'Hello, Alice!'\n```\n\n以上就是`call`, `apply`, `bind`方法的基本用法和行为。理解这些方法是理解JavaScript中函数调用和面向对象编程的关键。\n以上就是`this`在JavaScript中的一些基本用法和行为。理解`this`的行为是理解JavaScript中函数调用和面向对象编程的关键。",
      "id": 15
    },
    {
      "name": "js同步和异步执行机制",
      "id": 16,
      "type": "js",
      "recommendationIndex": 5,
      "content": "首先判断js代码是同步还是异步,同步就进入主进程,异步就进入event table\n异步任务在event table中注册函数,当满足触发条件后,被推入event queue\n同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中\n以上三步循环执行,这就是event loop\n\n既然js是单线程，那就像只有一个窗口的食堂，学生需要排队一个一个打饭，同理js任务也要一个一个顺序执行。这种模式执行简单，但随着日后的需求，事务，请求增多，这种单线程模式执行效率必定低下。只要有一个任务执行消耗了很长时间，在这个时间里后面的任务无法执行。\n\n常见的有新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？为了解决这个问题，**JavaScript语言将任务执行模式分成同步和异步：**\n\n- **同步模式：** 就是上面所说的一种执行模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。\n- **异步模式：** 就是每一个任务有一个或多个回调函数（`callback`），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\nhttps://img.jbzj.com/file_images/article/202109/2021924162932253.png?2021824162952\n\n**导图要表达的内容用文字来表述的话：**\n\n- \n\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入`Event Table`并注册函数。\n- 当指定的事情完成时，`Event Table`会将这个函数移入`Event Queue`。\n- 主线程内的任务执行完毕为空，会去`Event Queue`读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的`Event Loop`(事件循环)。\n\n **再配上代码表达：**\n```javascriptlet data = [];\n$.ajax({\n    url:blog.csdn.net,\n    data:data,\n    success:() => {\n        console.log('发送成功!');\n    }\n})\nconsole.log('代码执行结束');\n```\n**上面是一段简易的ajax请求代码：**\n\n- `ajax`进入`Event Table`，注册回调函数`success`。\n- 执行`console.log`('代码执行结束')。\n- ajax事件完成，回调函数`success`进入`Event Queue`。\n- 主线程从`Event Queue`读取回调函数`success`并执行。\n\n\n\n\n```javascript\nsetTimeout(()=>{\n\n  console.log(111);\n\n  },0)\n\n  new Promise((*resolve*, *reject*) => {\n\n  console.log(222);\n\n  setTimeout(() => {\n\n    console.log(333);\n\n  }, 0);\n\n  resolve(444);\n\n  }).then(*res*=>{\n\n  console.log(res);\n\n  })\n\n  console.log(555);\n```\n\n  /* js执行顺序是同步>微任务队列>宏任务队列，首先同步任务先执行222和555，\n\n  然后promise是微任务队列,这个时候js主线程任务已经执行完毕,开始把微任务队列中的\n\n  任务添加到主线程继续执行，所以输出555，最后定时器是宏任务队列，所以\n\n  最后执行111和333\n\n  js运行，代码刚开始就是定时器，我们首先把定时器加入event table中，注册好里面的回调函数，同时被推入入event queue(任务队列)，等待主线程执行完后，此时，就回去任务队列查找是否有可执行的异步任务，有就推到主线程执行，这个过程的循环执行，就是event loop[事件循环\n\n  */"
    },
    {
      "name": "js原型和原型链",
      "type": "js",
      "recommendationIndex": 5,
      "content": "所有对象和函数数组等都有__proto__属性，他指向了其构造函数的protoType对象属性,如对象的构造函数就是new Object(),一般我们会把公共方法存入原型之中，这样方便在实例化对象使用方法时指向同一个内存地址，不要要每实例化一个对象就新开辟一个内存空间用来存放方法，同时__proto__和protoType都有constructor属性，他就是指向构造函数本身，故而，点开constructor属性，里面也会有protoType属性和__proto__等。注意，Object已经是最高层级的构造函数了，原型链也在这为起点。\n![原型链.png](https://github.com/zpfzpf123/images/blob/master/原型链.png?raw=true){{{width=\"auto\" height=\"auto\"}}}",
      "id": 17
    },
    {
      "name": "js代码运行过程以及函数运行过程以及闭包",
      "id": 18,
      "type": "js",
      "recommendationIndex": 5,
      "content": "全局代码执行顺序\n\n想要弄懂函数的执行过程，就必须知道全局代码是怎么执行的\n\n函数的执行过程与全局代码执行过程非常相似，这也是设计的js不同于其他语言地方之一\n\n代码执行之前\n\n当全局代码执行之前，v8引擎会在堆内存中开辟一块空间叫GO（看补充），GO中有很多默认的属性(环境属性)，比如Date、String、window等等，还有我们声明的函数和用var定义的变量，那么他们默认是什么值呢？这划分为简单数据类型和复杂数据类型：\n\n简单数据类型默认值是undefined\n\n复杂数据类型默认值是一块地址：如果发现是复杂数据类型，v8就会在堆中另开辟一块空间，GO中的相应变量指向该空间（所以复杂数据类型存在深浅拷贝问题）\n\n函数也会创建一块空间，暂且叫它函数空间\n\n2. v8又会帮我们在栈中创建一个GEC(看补充)，GEC又包含两部分：\n\nGEC部分一：VO(看补充)，VO是一个虚拟对象并且指向GO，VO中也包含很多属性(环境属性)，比如this、父级作用域等等\n\nGEC部分二：代码执行体，就是一行行的代码\n\n注意：这些都是在代码具体执行之前就完成的，就是说这些东西在执行之前就会被确定\n\n全局代码执行\n\n执行一行行代码，当执行到为变量初始化或赋值时，就对应将GO中属性的值覆盖掉......\n\n补充：执行用到的变量都是通过VO往GO里找并操作\n\n函数执行过程\n\n在全局代码执行过程中遇到函数加小括号调用，会发生什么呢？\n\n会分为函数的具体代码执行之前和代码具体执行和执行完毕三部分\n\n函数代码执行之前\n\n当执行到‘函数()’的时候，前面说过会在GO找到对应的属性，发现属性值是一块空间(函数空间)，v8就会在堆中另外开辟一块独属于本次引用的空间AO(看补充)，此AO与GO作用相似，也会在执行代码之前做本作用域中的预解析（为简单数据类型和复杂数据类型分别做不同初始化），另外在执行栈中创建FEC(看补充)，同样的 FEC和GEC作用也相似，也分为两部分：\n\nFEC部分一：VO，虚拟对象指向AO，包含父级作用域等等\n\nFEC部分二：代码执行体\n\n函数代码执行\n\n执行一行行代码，当执行到为变量初始化或赋值时，就对应将AO中属性的值覆盖掉......\n\nQ：但是，如果发现一个属性在AO中找不到怎么办？\n\nA：在上面说过，VO中包含父级作用域，父级作用域在代码执行之前就会被确定，所以自然而然往父级作用域里找，父级作用域指向的是父级的VO，这样一层一层直到GO，如果还是找不到，返回undefined\n\n函数执行完毕\n\n函数执行完毕会把本函数的FEC弹出执行栈\n\n如果发现没有变量再指向函数空间，也会在堆中销毁该函数空间\n\n闭包原理\n\n// 示例代码 /* 1 */ var function foo() { /* 2 */ var num = 10 /* 3 */ return function bar() { /* 4 */ console.log(num) // 10 /* 5 */ } /* 6 */ } /* 7 */ /* 8 */ var fn = foo() /* 9 */ fn() /*10 */ \n\n全局预解析（看全局代码执行顺序）......\n\n第8行，调用foo（看函数执行过程）......\n\n第5行，通过VO将foo的AO的num改成10\n\n第3行，返回一个函数bar，函数不能被‘直接返回’，返回的是foo的AO的属性bar存的地址\n\n第8行，给fn初始化，值是一块地址，此时GO里的fn指向的就是bar的函数地址\n\n第9行，调用fn，从GO里面找到fn，发现是一块函数地址，进行创建VO和AO等操作......\n\n第4行，打印num，发现num并不存在当前AO中，通过父级作用域找foo的AO，返回num\n\n原因原理：因为全局的fn指向bar，bar的父级作用域又指向foo的AO，所以不管fn、foo、bar都不会被销毁，尽管fn、foo、bar都执行完毕，这样就会造成内存泄漏\n\n补充\n\nGEC：Global Execution Context 全局执行上下文\n\n存在并一直存在执行栈中，直到script代码执行完毕，包含执行前和执行两部分：\n\n执行前，创建VO指向GO\n\n执行一行行代码\n\nFEC：Function Execution Content 函数执行上下文\n\n在函数被调用代码执行之前被创建，包含执行前和执行两部分：\n\n执行前，创建VO指向AO\n\n执行一行行代码\n\nGO：Globel Object 全局对象\n\n存在于最根层，由V8引擎在代码执行之前创建在堆空间中，默认存在一些属性：Date、Math等等，还包含个特殊属性window指向GO本身，默认属性还包含我们定义的函数和var声明的变量\n\n在创建的时候会根据数据类型决定默认值，并且为复杂类型开辟内存\n\nAO：Activation Object\n\n在函数调用代码执行之前被创建，里面默认存在一些属性：传递来的参数、var声明的变量、定义的函数\n\n创建的时候也会根据数据类型不同决定默认值，并且为复杂类型开辟内存\n\nVO：Variable Object\n\n像是AO或GO的傀儡，也是代码执行之前被创建在执行上下文中并指向创建它的那一块空间，或许是AO或许是GO。包含this，包含scoped chain(作用域链): scoped(当前作用域)、scoped parent(父级作用域)等等\n\n补充：\n\n看到好多的文章都把VO省略掉了，但其实在代码执行过程中不能直接访问AO或GO，只能通过VO间接访问，可以理解为VO==AO或VO==GO，但VO是切实存在的\n\n每个函数都有属于自己的AO、VO、FEC\n\nA回答：\n\n在全局代码执行之前，V8会创建GO，并会判断你声明的变量的数据类型，为其添加默认值或为其在内存中开辟空间，发现定义一个函数就会开辟一块空间。这块空间是在代码执行之前创建的，所以当执行函数时，就会从GO或AO里面找到那一块空间\n\nJS内存垃圾回收(GC)的机制是从根开始找，某块空间没有再被指向的时会被销毁。上段代码为例，GO的fn指向bar(函数空间)，bar的父级作用域指向GO的foo的AO\n\n引申：那怎么解决闭包引起的内存泄露呢？手动更改fn的值或直接指向null"
    },
    {
      "id": 19,
      "type": "js",
      "name": "Set和Map",
      "recommendationIndex": 5,
      "content": "# 1、什么是Set()\n\nSet是[es6](https://so.csdn.net/so/search?q=es6&spm=1001.2101.3001.7020)新增的数据结构，**似于数组**，但它的一大特性就是**所有元素都是唯一的**，没有重复的值，我们一般称为集合。\n\nSet本身是一个构造函数，用来生成 Set 数据结构\n\n# 2、增删改查方法\n\n###### 2.1 添加元素`add`\n\n添加某个值，返回 Set 结构本身，当添加实例中已经存在的元素，set不会进行处理添加\n\n```js\nlet list=new Set();\nlist.add(1)\nlist.add(2).add(3).add(3)   // 2只被添加了一次\n123\n```\n\n###### 2.2 删除元素 `delete`\n\n删除某个值，返回一个布尔值，表示删除是否成功\n\n```js\nlet list=new Set([1,20,30,40])\nlist.delete(30)      //删除值为30的元素，这里的30并非下标\n12\n```\n\n###### 2.3 判断某元素是否存在`has`\n\n返回一个布尔值，判断该值是否为Set的成员\n\n```js\nlet list=new Set([1,2,3,4])\nlist.has(2)//true\n12\n```\n\n###### 2.4 清除所有元素`clear`\n\n清除所有成员，没有返回值\n\n```js\nlet list=new Set([1,2,3,4])\nlist.clear()\n12\n```\n\n# 3、遍历方法\n\n###### 3.1 遍历 `keys()`\n\n返回键名的遍历器，相等于返回键值遍历器values()\n\n```js\nlet list2=new Set(['a','b','c'])\nfor(let key of list2.keys()){\n   console.log(key)//a,b,c\n}\n1234\n```\n\n###### 3.2 遍历 `values()`\n\n返回键值的遍历器\n\n```js\nlet list=new Set(['a','b','c'])\nfor(let value of list.values()){\nconsole.log(value)//a,b,c\n}\n1234\n```\n\n###### 3.3 遍历 `entries()`\n\n返回键值对的遍历器\n\n```js\nlet list=new Set(['4','5','hello'])\nfor (let item of list.entries()) {\n  console.log(item);\n}\n// ['4','4']   ['5','5']   ['hello','hello'] \n12345\n```\n\n###### 3.4 遍历 `forEach()`\n\n使用回调函数遍历每个成员\n\n```js\nlet list=new Set(['4','5','hello'])\nlist.forEach((value, key) => console.log(key + ' : ' + value))\n// 4:4    5:5   hello:hello\n123\n```\n\n# 4、使用情形\n\n###### 4.1 用于[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)去重\n\n```js\nlet arr = [3, 5, 2, 2, 5, 5];\nlet setArr = new Set(arr)     // 返回set数据结构  Set(3) {3, 5, 2}\n\n//方法一   es6的...解构\nlet unique1 =  [...setArr ];      //去重转数组后  [3,5,2]\n\n//方法二  Array.from()解析类数组为数组\nlet unique2 = Array.from(setArr )   //去重转数组后  [3,5,2]\n12345678\n```\n\n###### 4.2 用于字符串去重\n\n```js\nlet str = \"352255\";\nlet unique = [...new Set(str)].join(\"\");     // 352 \n12\n```\n\n###### 4.3 实现并集、交集、和差集\n\n```js\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// （a 相对于 b 的）差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n\n# 1、Map是什么\n\nMap类型是**键值对的有序列表**，而`键和值都可以是任意类型`\n\n#### Map与Set的区别\n\n- Set是一种叫做[集合](https://so.csdn.net/so/search?q=集合&spm=1001.2101.3001.7020)的数据结构，Map是一种叫做字典的数据结构\n\n  > 集合-----是由一堆无序的、相关联的，且不重复的[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)结构【数学中称为元素】组成的组合\n  > 字典-----是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同\n\n- Set集合是以[值，值]的形式存储元素，\n  Map字典是以[键，值]的形式存储\n\n# 2、增删改查\n\n###### 2.1 `size`\n\nsize属性返回 Map 结构的成员总数。\n\n```js\nconst map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n12345\n```\n\n###### 2.2 `set()`\n\n设置键名key对应的键值为value，然后返回整个 Map 结构\n\n如果key已经有值，则键值会被更新，否则就新生成该键\n\n同时返回的是当前Map对象，可采用链式写法\n\n```js\nconst m = new Map();\nlet fn = function(){}\n\nm.set('edition', 6)        // 键是字符串\nm.set(fn, 'standard')     // 键是函数\nm.set(undefined, 'nah')    // 键是 undefined\nm.set(1, 'a').set(2, 'b').set(3, 'c') // 链式操作\n1234567\n```\n\n###### 2.3 `get()`\n\nget方法读取key对应的键值，如果找不到key，返回undefined\n\n```js\nconst m = new Map();\n\nconst hello = function() {console.log('hello');};\nm.set(hello, 'Hello ES6!') // 键是函数\n\nm.get(hello)  // Hello ES6!\n123456\n```\n\n###### 2.4 `has()`\n\nhas方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\n\n```js\nconst m = new Map();\n\nm.set('edition', 6);\nm.set(262, 'standard');\nm.set(undefined, 'nah');\n\nm.has('edition')     // true\nm.has('years')       // false\nm.has(undefined)     // true\n123456789\n```\n\n###### 2.4 `delete()`\n\ndelete方法删除某个键，返回true。如果删除失败，返回false\n\n```js\nconst m = new Map();\nm.set(undefined, 'nah');\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n123456\n```\n\n###### 2.5 `clear()`\n\nclear方法清除所有成员，没有返回值\n\n```js\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n1234567\n```\n\n# 3、遍历\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回所有成员的遍历器\n- forEach()：遍历 Map 的所有成员\n\n```js\nconst map = new Map([\n  ['F', 'no'],\n  ['T',  'yes'],\n]);\n\n//keys()\nfor (let key of map.keys()) {\n  console.log(key);       // \"F\"  \"T\"\n}\n\n//values()\nfor (let value of map.values()) {\n  console.log(value);    // \"no\"  \"yes\"\n}\n\n// entries()\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"F\" \"no\"  、\"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"F\" \"no\" 、\"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"  、 \"T\" \"yes\"\n\nmap.forEach(function(value, key, map) {\n  console.log(key, value);    // \"F\" \"no\"  、 \"T\" \"yes\"\n});\n```"
    },
    {
      "id": 20,
      "type": "js",
      "name": "两个数组求交集，并集和差集",
      "recommendationIndex": 5,
      "content": "```js\n//数组普通值\nlet a = [1, 2, 3, 4, 5, 10]\nlet b = [2, 3, 4, 5]\n//求交集\nlet c = [...new Set(a.filter(item => new Set(b).has(item)))]\n// console.log(c);\n//求并集\nlet d = [...new Set([].concat(a).concat(b))]\n//求差集\nlet e = [...new Set(a.filter(item => !new Set(b).has(item)))]\nconsole.log(e);\n\n//数组对象值\n// 形如如下数组\nlet arr1 = [], arr2 = [];\narr1 = [\n  {\n    ID: 1,\n    Name: 1,\n    desc: 'Number'\n  },\n  {\n    ID: 2,\n    Name: 2,\n    desc: 'Number'\n  },\n  {\n    ID: 3,\n    Name: 3,\n    desc: 'Number'\n  },\n  {\n    ID: 4,\n    Name: 4,\n    desc: 'Number'\n  },\n  {\n    ID: 5,\n    Name: 5,\n    desc: 'Number'\n  }\n]\narr2 = [\n  {\n    ID: 5,\n    Name: 5,\n    desc: 'Number'\n  },\n  {\n    ID: 6,\n    Name: 6,\n    desc: 'Number'\n  },\n  {\n    ID: 7,\n    Name: 7,\n    desc: 'Number'\n  },\n  {\n    ID: 8,\n    Name: 8,\n    desc: 'Number'\n  },\n  {\n    ID: 9,\n    Name: 9,\n    desc: 'Number'\n  }\n]\n\n// 交集\nlet intersection = []\nfor (let i = 0, len = arr1.length; i < len; i++) {\n  for (let j = 0, length = arr2.length; j < length; j++) {\n    if (arr1[i].ID === arr2[j].ID) {\n      intersection.push(arr1[i])\n    }\n  }\n}\nconsole.log('交集', intersection)\n\n// 并集\nlet union = [...arr1, ...arr2]\nfor (let i = 0, len = arr1.length; i < len; i++) {\n  for (let j = 0, length = arr2.length; j < length; j++) {\n    if (arr1[i].ID === arr2[j].ID) {\n      union.splice(union.findIndex(item => item.ID === arr1[i].ID), 1)\n    }\n  }\n}\nconsole.log('并集', union)\n\n// 补集\nlet complement = [...arr1, ...arr2]\nfor (let i = 0, len = arr1.length; i < len; i++) {\n  for (let j = 0, length = arr2.length; j < length; j++) {\n    if (arr1[i].ID === arr2[j].ID) {\n      complement.splice(complement.findIndex(item => item.ID === arr1[i].ID), 1)\n      complement.splice(complement.findIndex(item => item.ID === arr2[j].ID), 1)\n    }\n  }\n}\nconsole.log('补集', complement)\n\n// 差集\nlet diff = [...arr1]\nfor (let i = 0, len = arr1.length; i < len; i++) {\n  let flag = false\n  for (let j = 0, length = arr2.length; j < length; j++) {\n    if (arr1[i].ID === arr2[j].ID) {\n      flag = true\n    }\n  }\n  if (flag) {\n    diff.splice(diff.findIndex(item => item.ID === arr1[i].ID), 1)\n  }\n}\nconsole.log('差集', diff)\n```"
    },
    {
      "id": 21,
      "type": "js",
      "name": "数组去重",
      "recommendationIndex": 5,
      "content": "```js\n//数组对象去重\nlet a = [{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }, { id: 4, name: 'd' }, { id: 1, name: 'a' }]\nlet map = new Map();\nfor (let item of a) {\nlet key=Object.values(item).reduce((pre, nex) => {\nreturn pre+nex\n})\nmap.set(key,item)\n}\n// console.log(map);\na = [...map.values()];\nconsole.log(a)\n//数组普通值去重\nlet e = [1, 1, 1, 2, 2]\nlet f = [...new Set(e)]\nconsole.log(f);\n```"
    },
    {
      "name": "部分数组方法",
      "type": "js",
      "recommendationIndex": 5,
      "content": "# 1 forEach遍历\n\nforEach(function(value,index,array))\n\nvalue:数组中的每一个值\n\nindex:数组中的每一个索引号\n\narray:数组本身\n\n```js\n    var arr = [1, 2, 3, 4, 5，6]\n    arr.forEach((value, index, array) => {\n      console.log(`数组中的每个值${value},对应的索引号${index},整个数组为${array}`);\n    })\n```\n\n\n# 2 filter 过滤筛选数组\n\nfilter(function(value,index,array))返回一个新数组\n\n```js\n    var arr = [1, 2, 3, 4, 5]\n    var newArr = arr.filter((value) => {\n      return value > 2\n    })\n    console.log(newArr);\n```\n\n\n# 3 some 有满足条件的元素返回true\n\nsome(function(value,index,array))返回值为布尔值，找到满足条件的就为true，(找到第一个满足条件的就终止循环)\n\n```js\n    var arr = [1, 2, 3, 4, 5]\n    var newArr = arr.some((value) => {\n      return value == 2\n    })\n    console.log(newArr);// true\n```\n\n\n\n# 4 every 所有元素满足条件返回true\n\nevery(function(value,index,array))返回值为布尔值，所有元素满足条件的就为true\n\n```js\n    var arr = [1, 2, 3, 4, 5]\n    var flag = arr.every((value) => {\n      return value > 0\n    })\n    var flags = arr.every((value) => {\n      return value > 1\n    })\n    console.log(flag);// true\n    console.log(flags);// false\n```\n\n# 5 map 返回一个新数组\n\nmap(function(value,index,array))返回值为新数组，数组中的元素为原始数组元素调用函数处理后的值\n\n```js\n    var arr = [1, 2, 3, 4, 5]\n    var newArr = arr.map((value) => {\n      return value * 2\n    })\n    console.log(newArr);//[2,4,6,8,10]\n```\n\n# 6 find 找出第一个符合条件的数组成员\n\nfind(function(value,index,array))返回值为满足条件的数组成员\n\n```js\n    const arr = [{\n      id: 1,\n      name: 'zpf'\n    }, {\n      id: 2,\n      name: 'zzz'\n    }]\n    const a = arr.find(value => value.id)\n    const b = arr.find(value => value.id == 11)\n    console.log(a);// {id:1,name:'zpf'}\n    console.log(b);// undefined\n```\n\n# 7 findIndex 找到第一个符合条件的数组成员的索引值\n\nfindIndex(function(value,index,array))返回值为满足条件的数组成员的索引值 找不到为-1\n\n```js\n    const arr = [{\n      id: 1,\n      name: 'zpf'\n    }, {\n      id: 2,\n      name: 'zzz'\n    }]\n    const a = arr.findIndex(value => value.id)\n    const b = arr.findIndex(value => value.id == 11)\n    console.log(a);// 0\n    console.log(b);// -1\n```\n\n# 8 includes() 数组中是否包含给定的值 包含返回true 不包含false\n\n```js\n    console.log([1, 2, 3].includes(3, -1));// 搜索值3 起始位置倒数第一个-1 true\n    console.log([1, 2, 3].includes(4));// false\n    console.log([1, 2, 3].includes(1, 2, 3, 4));//false\n    console.log([1, 2, 3].includes(1, 2, 4));//false\n```",
      "id": 22
    },
    {
      "id": 23,
      "type": "js",
      "name": "时间戳转化为年月日时分秒",
      "recommendationIndex": 4,
      "content": "```js\ntimestampToTime(time) {\n      if (!time) {\n        return\n      }\n      let date = new Date(time)\n      let len = time.toString().length;\n      if (len < 13) {\n        let sub = 13 - len;\n        sub = Math.pow(10, sub);\n        date = new Date(time * sub);\n      }\n      let y = date.getFullYear() + '-';\n      let M = date.getMonth() + 1;\n      M = (M < 10 ? '0' + M : M) + '-';\n      let d = date.getDate();\n      d = (d < 10 ? '0' + d : d) + ' ';\n      return y + M + d;\n    },\n```\n\n"
    },
    {
      "id": 24,
      "type": "js",
      "name": "标准时间转化为年月日时分秒",
      "recommendationIndex": 4,
      "content": "```js\nformatTime(time, fmt) {\n  if (!time) return '';\n  else {\n    const date = new Date(time);\n    const o = {\n      'M+': date.getMonth() + 1,\n      'd+': date.getDate(),\n      'H+': date.getHours(),\n      'm+': date.getMinutes(),\n      's+': date.getSeconds(),\n      'q+': Math.floor((date.getMonth() + 3) / 3),\n      S: date.getMilliseconds(),\n    };\n    if (/(y+)/.test(fmt))\n      fmt = fmt.replace(\n        RegExp.$1,\n        (date.getFullYear() + '').substr(4 - RegExp.$1.length)\n      );\n    for (const k in o) {\n      if (new RegExp('(' + k + ')').test(fmt)) {\n        fmt = fmt.replace(\n          RegExp.$1,\n          RegExp.$1.length === 1\n            ? o[k]\n            : ('00' + o[k]).substr(('' + o[k]).length)\n        );\n      }\n    }\n    return fmt;\n  }\n}\n//formatTime(new Date(), \"yyyyMMddHHmmss\")\n```"
    },
    {
      "id": 25,
      "type": "js",
      "name": "函数的节流与防抖",
      "recommendationIndex": 5,
      "content": "## 防抖函数：将多次触发变成最后一次触发；\n\n```js\nfunction debounce(fn,wait){\n  let timer = null;\n  return function (){\n    let arg = arguments;\n    if(timer){\n      clearTimeout(timer);\n      timer = null;\n    }\n    timer = setTimeout(()=>{\n       fn.apply(this,arg)\n    },wait)\n  }\n}\nfunction clg(){\n  console.log('clg')\n}\nwindow.addEventListener('resize',debounce(clg,1000))\n```\n\n ## 节流函数：将多次执行变成每隔一个时间节点去执行的函数\n\n```js\nfunction throttle(fn,time){\n  let lastTime = null;\n  return function(){\n    let nowTime = Date.now();\n    if(nowTime - lastTime > time || !lastTime){\n      fn();\n      last = nowTime\n    }\n  }\n}\nfunction sayHi(){\n  console.log('hi')\n}\nsetInterval(throttle(sayHi,1000),500)\n```"
    },
    {
      "id": 26,
      "type": "js",
      "name": "监听网页行为",
      "recommendationIndex": 4,
      "content": "监听网页行为（如是否调用某个接口）\n\n```js\nconst observer = new PerformanceObserver(_ => {\n\t\tif (performance.getEntriesByName(\"接口ip\")\n\t\t\t.length >\n\t\t\t0) {\n\t\t\tconsole.log('网页调用该接口')\n\t\t}\n\n\t});\n\tobserver.observe({\n\t\tentryTypes: [\"resource\"]\n\t})\n```"
    },
    {
      "name": "修改浏览器默认滚动条样式",
      "type": "css",
      "recommendationIndex": 5,
      "content": "```css\n// 滚动条整体部分\n&::-webkit-scrollbar {\n  width: 6px;\n  height: 6px;\n}\n// 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。\n&::-webkit-scrollbar-button {\n  display: none;\n}\n// 滚动条的轨道（里面装有Thumb）\n&::-webkit-scrollbar-track {\n  background: transparent;\n}\n// 滚动条的轨道（里面装有Thumb）\n&::-webkit-scrollbar-track-piece {\n  background-color: transparent;\n}\n// 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）\n&::-webkit-scrollbar-thumb {\n  background: #007cd6;\n  cursor: pointer;\n  border-radius: 4px;\n}\n// 边角，即两个滚动条的交汇处\n&::-webkit-scrollbar-corner {\n  display: none;\n}\n// 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件\n&::-webkit-resizer {\n  display: none;\n}\n```",
      "id": 27
    },
    {
      "name": "组件",
      "type": "component",
      "recommendationIndex": 5,
      "content": "# 1.前端实用组件\n\n## 1.1 [vue无缝滚动组件 vue2 ](https://chenxuan0000.github.io/vue-seamless-scroll/)  [vue3](https://doc.wssio.com/opensource/vue3-seamless-scroll/#%E5%BC%80%E5%A7%8B)\n\n要想让他实现无缝滚动，首先看你页面的滚动内容高度是多少，比如是500px,在不滚动的时候看多少行数据占满这个高度，假设需要10行数据显示在页面上，那么每行的高度需要设置为大于500/10=50px,这样才可以实现无缝滚动，一般就设置为50px,通过class-option中的属性limitMoveNum判断是否滚动，比如这里就可以设置为10，超出10行意味着滚动，小于等于就不滚动\n\n```vue\n<template>\n  <div id=\"jobStatistics\">\n    <el-row :gutter=\"10\" type=\"flex\" align=\"middle\" style=\"height: 75%\">\n      <el-col :span=\"18\" style=\"height: 100%;border:1px solid black\">\n        <table>\n          <!-- 设置列宽 -->\n          <colgroup>\n            <col v-for=\"item of 2\" width=\"10%\">\n            <col width=\"18%\">\n            <col width=\"10%\">\n            <col width=\"12%\">\n            <col v-for=\"item of 4\" width=\"10%\">\n          </colgroup>\n          <thead>\n          <th v-for=\"item in tableName\">{{item}}</th>\n          </thead>\n        </table>\n        <vue-seamless-scroll :data=\"testArray\" :class-option=\"optionHover\" class=\"seamless-warp\">\n          <ul>\n            <li v-for=\"(item,index) in testArray\" class=\"liStyle\" :class=\"{ bg: index%2===0 }\">\n              <span :title=\"index+1\" class=\"title1 text_align\">{{ index + 1 }}</span>\n              <span :title=\"item.name\" class=\"title1 text_align\">{{ item.name }}</span>\n              <span :title=\"item.age\" class=\"title2 text_align\">{{ item.age }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title3 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n              <span :title=\"item.phone\" class=\"title1 text_align\">{{ item.phone }}</span>\n            </li>\n          </ul>\n        </vue-seamless-scroll>\n      </el-col>\n    </el-row>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"jobStatistics\",\n  data() {\n    return {\n      //表格表头名称\n      tableName:['序号','作业区域','作业内容','就业人员','现场负责人','部门','进入时间','离开时间','现场图像'],\n      testArray: [\n        {name: '刘明明', age: 14, phone: '15876512321'},\n        {name: '王五五', age: 15, phone: '15876512321'},\n        {name: '张萌萌', age: 23, phone: '15876512321'},\n        {name: '刘浩', age: 20, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '15876512321'},\n        {name: '刘佳', age: 21, phone: '1587651232313121'},\n      ],\n    };\n  },\n  computed: {\n    //滚动表格的配置项\n    optionHover() {\n      return {\n        limitMoveNum:10,//数据超出10行才滚动\n        hoverStop: true, // 是否开启鼠标悬停stop\n        direction: 1, // 0向下 1向上 2向左 3向右\n        step: .5,// 数值越大速度滚动越快\n        openWatch: true, // 开启数据实时监控刷新dom\n      }\n    }\n  },\n};\n</script>\n<style lang=\"less\">\n#jobStatistics{\n  height:100%;\n}\n* {\n  margin: 0;\n  padding: 0;\n}\n\nul {\n  list-style: none;\n}\n\ntable {\n  width: 100%;\n  text-align: center;\n}\n\nth {\n  height: 260%;\n  line-height: 260%;\n  font-size: 16px;\n  background-color: rgba(180, 181, 198, 0.1);\n}\n\n.seamless-warp {\n  height: 90%;\n  overflow: hidden;\n\n  .liStyle {\n    height: 45.5px;\n    line-height: 45.5px;\n    width: 100%;\n    display: flex;\n    overflow: hidden;\n\n    .title1 {\n      width: 10%;\n    }\n\n    .title2 {\n      width: 18%;\n    }\n\n    .title3 {\n      width: 12%;\n    }\n\n    .text_align {\n      text-align: center;\n      overflow: hidden;\n      white-space: nowrap;\n      text-overflow: ellipsis;\n    }\n\n  }\n}\n.bg{\n  background: gainsboro;\n}\n</style>\n```\n\n## 1.2 [vue-cropper裁剪图片插件](https://github.com/xyxiao001/vue-cropper)\n## 1.3 [自定义表格](https://vxetable.cn/#/table/start/install)\n## 1.4 [Vue 字符串实现JSON格式显示 ](https://github.com/chenfengjw163/vue-json-viewer/blob/master/README_CN.md)\n+ 请注意 复制功能按钮显示不出请添加如下样式代码\n以scss为例子\n```js\n::v-deep .jv-button{\n  &::after{\n    width: 20px;\n    height: 20px;\n    content: '复制';\n    display: inline-block;\n    position: fixed;\n  }\n}\n```\n## 1.5 [移动端vue手势库](https://github.com/gggso/vue-finger)\n## 1.6 [搭建虚拟服务器调用接口](https://github.com/typicode/json-server)\n### 简介\njson-server 是一款小巧的接口模拟工具，一分钟内就能搭建一套 Restful 风格的 API，尤其适合前端接口测试使用。🔥🔥🔥\n只需指定一个 json 文件作为 api 的数据源即可，使用起来非常方便，30 秒入门，基本上有手就行。👍\n进阶操作还支持分页，排序等操作，简直强大。💪\n\n### 开源地址\n主页地址：https://www.npmjs.com/package/json-server\nGithub项目地址：https://github.com/typicode/json-server\n\n### 30秒入门\n#### 环境依赖\n安装 Node.js 环境即可\n#### 操作步骤\n安装 JSON 服务器\n```js \nnpm install -g json-server\n```\n创建一个db.json包含一些数据的文件\n```js\n{\n  \"posts\": [\n    { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }\n  ],\n  \"comments\": [\n    { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\n  ],\n  \"profile\": { \"name\": \"typicode\" }\n}\n```\n启动 json-server 接口服务器\n#### 快速创建\njson-server db.json\n\n#### 配置参数\n```js \njson-server db.json --watch --port 3000\n```\n浏览器访问 http://localhost:3000/posts/1，你会得到\n```js\n{ \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }\n```\n🎉恭喜你，已经完成 json-server 快速搭建，熟练使用的话 30 秒即可完成服务器搭建⏰。\n#### 补充\n如果您发出 POST、PUT、PATCH 或 DELETE 请求，更改将自动安全地保存到 db.json 文件中。\n路由进阶\n根据之前的db.json文件，这里是所有的默认路由。\n\n##### 路由形式一\n```js\nGET    /posts\nGET    /posts/1\nPOST   /posts\nPUT    /posts/1\nPATCH  /posts/1\nDELETE /posts/1\n```\n##### 路由形式二\n```js\nGET    /profile\nPOST   /profile\nPUT    /profile\nPATCH  /profile\n```\n##### 筛选\n使用 . 访问筛选\n```js\nGET /posts?title=json-server&author=typicode\nGET /posts?id=1&id=2\nGET /comments?author.name=typicode\n```\n##### 分页\n使用_page和可选地_limit对返回的数据进行分页。\n\n在Link标题，你会得到first，prev，next和last链接。\n\n```js\nGET /posts?_page=7\nGET /posts?_page=7&_limit=20\n```\n默认返回10项\n\n##### 排序\n添加_sort和_order（默认升序）\n\n```js\nGET /posts?_sort=views&_order=asc\nGET /posts/1/comments?_sort=votes&_order=asc\n```\n对于多个字段，请使用以下格式：\n\n```js\nGET /posts?_sort=user,views&_order=desc,asc\n```\n##### 切片(分页)\n添加_start和_end或_limit\n\n```js\nGET /posts?_start=20&_end=30\nGET /posts/1/comments?_start=20&_end=30\nGET /posts/1/comments?_start=20&_limit=10\n```\n与Array.slice完全一样工作（即_start开始_end结束）\n\n##### 特殊符号\n添加_gte或_lte获取范围\n\n```js\nGET /posts?views_gte=10&views_lte=20\n```\n##### 添加_ne以排除值\n\n```js\nGET /posts?id_ne=1\n```\n##### 添加_like到过滤器（支持正则表达式）\n\n```js\nGET /posts?title_like=server\n```\n##### 全文搜索\n添加 q\n\n```\nGET /posts?q=internet\n```\n##### 关系\n要包含子资源，请添加 _embed\n\n```js\nGET /posts?_embed=comments\nGET /posts/1?_embed=comments\n```\n要包含父资源，请添加 _expand\n\n```js\nGET /comments?_expand=post\nGET /comments/1?_expand=post\n```\n##### 获取或创建嵌套资源（默认为一级）\n\n```js\nGET  /posts/1/comments\nPOST /posts/1/comments\n```\n##### 数据库\n```js\nGET /db\n```\n##### 主页\n返回默认索引文件或服务./public目录\n\n```js\nGET /\n```\n#### 附加功能\n##### 静态文件服务器\n您可以使用 JSON Server 为您的 HTML、JS 和 CSS 提供服务，只需创建一个./public目录或用于--static设置不同的静态文件目录。\n\n```js\nmkdir public\necho 'hello world' > public/index.html\njson-server db.json\njson-server db.json --static ./some-other-dir\n```\n##### 替换端口\n您可以使用以下--port标志在其他端口上启动 JSON Server ：\n```js\n$ json-server --watch db.json --port 3004\n```\n##### 支持跨域\n您可以使用 CORS 和 JSONP 从任何地方访问您模拟的 API 接口。\n\n##### 远程模式\n您可以加载远程模式。\n```js\n$ json-server http://example.com/file.json\n$ json-server http://jsonplaceholder.typicode.com/db\n```\n##### 生成随机数据\n使用 JS 而不是 JSON 文件，您可以通过编程方式创建数据。\n```js\n// index.js\nmodule.exports = () => {\n  const data = { users: [] }\n  // 创建 1000 个用户信息\n  for (let i = 0; i < 1000; i++) {\n    data.users.push({ id: i, name: `user${i}` })\n  }\n  return data\n}\n```\n```js\n$ json-server index.js\n```\n提示：使用Faker、Casual、Chance或JSON Schema Faker 等模块。\n\n#### 添加自定义路由\n创建一个routes.json文件。注意每条路线都以/.\n```js\n{\n  \"/api/*\": \"/$1\",\n  \"/:resource/:id/show\": \"/:resource/:id\",\n  \"/posts/:category\": \"/posts?category=:category\",\n  \"/articles\\\\?id=:id\": \"/posts/:id\"\n}\n```\n使用--routes选项启动 JSON 服务器。\n\njson-server db.json --routes routes.json\n现在您可以使用其他路线访问资源。\n```js\n/api/posts # → /posts\n/api/posts/1  # → /posts/1\n/posts/1/show # → /posts/1\n/posts/javascript # → /posts?category=javascript\n/articles?id=1 # → /posts/1\n```\n##### 添加中间件\n您可以使用以下--middlewares选项从 CLI 添加中间件：\n```js\n// hello.js\nmodule.exports = (req, res, next) => {\n  res.header('X-Hello', 'World')\n  next()\n}\n```\n```js\njson-server db.json --middlewares ./hello.js\njson-server db.json --middlewares ./first.js ./second.js\n```\n##### 命令行使用\n```js\njson-server [options] <source>\n\nOptions:\n  --config, -c       Path to config file           [default: \"json-server.json\"]\n  --port, -p         Set port                                    [default: 3000]\n  --host, -H         Set host                             [default: \"localhost\"]\n  --watch, -w        Watch file(s)                                     [boolean]\n  --routes, -r       Path to routes file\n  --middlewares, -m  Paths to middleware files                           [array]\n  --static, -s       Set static files directory\n  --read-only, --ro  Allow only GET requests                           [boolean]\n  --no-cors, --nc    Disable Cross-Origin Resource Sharing             [boolean]\n  --no-gzip, --ng    Disable GZIP Content-Encoding                     [boolean]\n  --snapshots, -S    Set snapshots directory                      [default: \".\"]\n  --delay, -d        Add delay to responses (ms)\n  --id, -i           Set database id property (e.g. _id)         [default: \"id\"]\n  --foreignKeySuffix, --fks  Set foreign key suffix, (e.g. _id as in post_id)\n                                                                 [default: \"Id\"]\n  --quiet, -q        Suppress log messages from output                 [boolean]\n  --help, -h         Show help                                         [boolean]\n  --version, -v      Show version number                               [boolean]\n\nExamples:\n  json-server db.json\n  json-server file.js\n  json-server http://example.com/db.json\n```\nhttps://github.com/typicode/json-server\n您还可以在json-server.json配置文件中设置选项。\n```js\n{\n  \"port\": 3000\n}\n```\n#### 模块\n如果您需要添加身份验证、验证或任何行为，您可以将项目作为模块与其他 Express 中间件结合使用。\n\n简单的例子\n```js\n$ npm install json-server --save-dev\n```\n```js\n// server.js\nconst jsonServer = require('json-server')\nconst server = jsonServer.create()\nconst router = jsonServer.router('db.json')\nconst middlewares = jsonServer.defaults()\n\nserver.use(middlewares)\nserver.use(router)\nserver.listen(3000, () => {\n  console.log('JSON Server is running')\n})\n```\n```js\n$ node server.js\n```\n您提供给jsonServer.router函数的路径是相对于您启动节点进程的目录的。如果从另一个目录运行上述代码，最好使用绝对路径：\n```js\nconst path = require('path')\nconst router = jsonServer.router(path.join(__dirname, 'db.json'))\n```\n对于内存数据库，只需将对象传递给jsonServer.router().\n\n另请注意，jsonServer.router()它可用于现有的 Express 项目。\n\n##### 自定义路由示例\n假设您想要一个回显查询参数的路由和另一个在创建的每个资源上设置时间戳的路由。\n```js\nconst jsonServer = require('json-server')\nconst server = jsonServer.create()\nconst router = jsonServer.router('db.json')\nconst middlewares = jsonServer.defaults()\n// 设置默认中间件（记录器、静态、cors 和无缓存）\nserver.use(middlewares)\n\n// 写在自定义路由之前\nserver.get('/echo', (req, res) => {\n  res.jsonp(req.query)\n})\n\n// 要处理 POST、PUT 和 PATCH，您需要使用 body-parser\n// 您可以使用 JSON Server\nserver.use(jsonServer.bodyParser)\nserver.use((req, res, next) => {\n  if (req.method === 'POST') {\n    req.body.createdAt = Date.now()\n  }\n  // 继续到 JSON Server 路由器\n  next()\n})\n\n// 使用默认路由器\nserver.use(router)\nserver.listen(3000, () => {\n  console.log('JSON Server is running')\n})\n访问控制示例\nconst jsonServer = require('json-server')\nconst server = jsonServer.create()\nconst router = jsonServer.router('db.json')\nconst middlewares = jsonServer.defaults()\n\nserver.use(middlewares)\nserver.use((req, res, next) => {\n if (isAuthorized(req)) { // 在此处添加您的授权逻辑\n   next() // 继续到 JSON Server 路由器\n } else {\n   res.sendStatus(401)\n }\n})\nserver.use(router)\nserver.listen(3000, () => {\n  console.log('JSON Server is running')\n})\n```\n##### 自定义输出示例\n要修改响应，请覆盖router.render方法：\n```js\n// 在这个例子中，返回的资源将被包装在一个 body 属性\nrouter.render = (req, res) => {\n  res.jsonp({\n    body: res.locals.data\n  })\n}\n```\n您可以为响应设置自己的状态代码：\n```js\n// 在这个例子中，我们模拟了一个服务器端错误响应\nrouter.render = (req, res) => {\n  res.status(500).jsonp({\n    error: \"error message here\"\n  })\n}\n```\n##### 重写器示例\n要添加重写规则，请使用jsonServer.rewriter()：\n```js\n// 写在 server.use(router) 之前\nserver.use(jsonServer.rewriter({\n  '/api/*': '/$1',\n  '/blog/:resource/:id/show': '/:resource/:id'\n}))\n```\n在另一个端点上挂载 JSON 服务器示例\n或者，您也可以将路由器安装在/api.\n```js\nserver.use('/api', router)\n```\nAPI\n```js\njsonServer.create()\n```\n\n返回一个 Express 服务器。\n```js\njsonServer.defaults([options])\n```\n\n返回 JSON 服务器使用的中间件。\n\n##### 选项\n```js\nstatic 静态文件的路径\nlogger 启用记录器中间件（默认值：true）\nbodyParser 启用 body-parser 中间件（默认值：true）\nnoCors 禁用 CORS（默认值：false）\nreadOnly 只接受 GET 请求（默认值：false）\njsonServer.router([path|object])\n```\n返回 JSON 服务器路由器。\n## 1.7 [vue大屏自适应组件](https://github.com/Alfred-Skyblue/v-scale-screen)\n## 1.8 [下载文件组件](https://github.com/kennethjiang/js-file-download)\n## 1.9 [vue编辑预览md组件](https://code-farmer-i.github.io/vue-markdown-editor/zh/)",
      "id": 28
    },
    {
      "id": 29,
      "type": "uniapp",
      "name": "uniapp存储文件和读取文件",
      "recommendationIndex": 3,
      "content": "# 一、读取本地文件\n\n```js\n        // 读取本地文件的方法 参数1为文件名称，参数2为回调方法用于处理获取到的文件数据\n\t\tfetchFileData(fileName,callback) {\n\t\t\tplus.io.requestFileSystem(\n\t\t\t\tplus.io.PUBLIC_DOWNLOADS, // 文件系统中的根目录\n\t\t\t\tfs => {\n\t\t\t\t\t// 创建或打开文件, fs.root是根目录操作对象,直接fs表示当前操作对象\n\t\t\t\t\tfs.root.getFile(fileName, {\n\t\t\t\t\t\tcreate: true // 文件不存在则创建\n\t\t\t\t\t}, fileEntry => {\n\t\t\t\t\t\t// 文件在手机中的路径\n\t\t\t\t\t\tconsole.log('文件在手机中的路径', fileEntry.fullPath)\n\t\t\t\t\t\tfileEntry.file(function(file) {\n\t\t\t\t\t\t\tvar fileReader = new plus.io.FileReader();\n\t\t\t\t\t\t\tconsole.log(\"getFile:\" + JSON.stringify(file));\n\t\t\t\t\t\t\tfileReader.readAsText(file, \"utf-8\")\n\t\t\t\t\t\t\tfileReader.onloadend = function(res) { //读取文件内容成功后的回调事件\n\t\t\t\t\t\t\t\t//res.target.result读取到的文件内容信息\n\t\t\t\t\t\t\t\tconsole.log('最后读取文件内容是=======', res.target.result)\n\t\t\t\t\t\t\t\tcallback(res.target.result)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}, e => {\n\t\t\t\t\t\tconsole.log('报错111', \"getFile failed: \" + e.message);\n\t\t\t\t\t});\n\t\t\t\t},\n \n\t\t\t\te => {\n\t\t\t\t\tconsole.log('报错222', e.message);\n\t\t\t\t}\n\t\t\t);\n\t\t},\n```\n\n# 二、存储数据到本地文件\n\n```js\n// 参数1为文件名称 参数2是文件内容 参数3是回调参数\t\t\nsaveFile(fileName,fileInfo,callback) {\n\t\t\t// 请求本地文件系统对象\n\t\t\tplus.io.requestFileSystem(\n\t\t\t\tplus.io.PUBLIC_DOWNLOADS, // 文件系统中的根目录\n\t\t\t\tfs => {\n\t\t\t\t\t// 创建或打开文件, fs.root是根目录操作对象,直接fs表示当前操作对象\n\t\t\t\t\tfs.root.getFile(fileName, {\n\t\t\t\t\t\tcreate: true // 文件不存在则创建\n\t\t\t\t\t}, fileEntry => {\n\t\t\t\t\t\t// 文件在手机中的路径\n\t\t\t\t\t\tconsole.log('最后文件在手机中的路径========', fileEntry.fullPath)\n\t\t\t\t\t\tfileEntry.createWriter(writer => {\n\t\t\t\t\t\t\t// 写入文件成功完成的回调函数\n\t\t\t\t\t\t\twriter.onwrite = e => {\n\t\t\t\t\t\t\t\tconsole.log(\"写入数据成功\");\n\t\t\t\t\t\t\t\tcallback(true)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// 写入数据\n\t\t\t\t\t\t\twriter.write(JSON.stringify(fileInfo));\n\t\t\t\t\t\t})\n\t\t\t\t\t}, e => {\n\t\t\t\t\t\tcallback(false)\n\t\t\t\t\t\tconsole.log('报错111', \"getFile failed: \" + e.message);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\tconsole.log('报错222', e.message);\n\t\t\t\t\tcallback(false)\n\t\t\t\t}\n\t\t\t);\n\t\t},\n```\n\n "
    },
    {
      "id": 30,
      "type": "ai",
      "name": "ai工具合集",
      "recommendationIndex": 5,
      "content": "# [chatgpt](https://chat.openai.com/chat):人工智能ai聊天工具\n\n# [newbing](https://www.bing.com/search?q=Bing+AI&showconv=1&FORM=hpcodx):结合chatgpt+微软搜索引擎的新一代智能对话\n\n# [cursor](https://www.cursor.so/):结合chatgpt+编程工具的最新智能IDE\n\n# [闪击ppt](https://ppt.sankki.com/#/works):结合chatgpt生成文本，然后快速生成ppt的工具\n\n```\n我的名字叫做周鹏飞，帮我制作一篇内容为《xxxx》PPT，要求如下： 第一、一定要使用中文。 第二、页面形式有3种，封面、目录、列表、总结。 第三、目录页要列出内容大纲。 第四、根据内容大纲，生成对应的PPT列表页，每一页PPT列表页使用=====列表=====开头。 第五、封面页格式如下： =====封面===== # 主标题 ## 副标题 演讲人：我的名字 第六、目录页格式如下： =====目录===== # 目录 ## CONTENT 1、内容 2、内容 第七、列表页格式如下： =====列表===== # 页面主标题 1、要点1 要点描述内容 第八、列表页里的要点描述内容是对要点的详细描述，10个字以上，50个字以内。第九、最后一个列表为全文总结。第十、至少要求十个列表。 最后，一定要使用代码块回复你生成的内容，切记切记。\n```\n\n\n\n# [discord](https://discord.com/)：全球聊天频道，可在里面和ai绘画智能机器人对话，生成对应图片，还有很多其他功能等待发现\n\n# [未来百科](https://www.futurepedia.io/):ai工具合集\n\n\n\n"
    },
    {
      "name": "vue 自定义弹出菜单",
      "type": "component",
      "recommendationIndex": 5,
      "content": "# 安装\n```js\nnpm install vue-contextmenujs\n```\n# 使用\n```js\nimport Contextmenu from \"vue-contextmenujs\"\nVue.use(Contextmenu);\n```\n# 代码实现\n以element-ui图标为例实现右键菜单，图标会为被渲染为<i class=\"icon\"></i>，代码如下：\n```js\n<template>\n  <div style=\"width:100vw;height:100vh\" @contextmenu.prevent=\"onContextmenu\"></div>\n</template>\n\n<script>\nimport Vue from 'vue'\nimport Contextmenu from \"vue-contextmenujs\"\nVue.use(Contextmenu);\nexport default {\n  methods: {\n    onContextmenu(event) {\n      this.$contextmenu({\n        items: [\n          {\n            label: \"返回(B)\",\n            onClick: () => {\n              this.message = \"返回(B)\";\n              console.log(\"返回(B)\");\n            }\n          },\n          { label: \"前进(F)\", disabled: true },\n          { label: \"重新加载(R)\", divided: true, icon: \"el-icon-refresh\" },\n          { label: \"另存为(A)...\" },\n          { label: \"打印(P)...\", icon: \"el-icon-printer\" },\n          { label: \"投射(C)...\", divided: true },\n          {\n            label: \"使用网页翻译(T)\",\n            divided: true,\n            minWidth: 0,\n            children: [{ label: \"翻译成简体中文\" }, { label: \"翻译成繁体中文\" }]\n          },\n          {\n            label: \"截取网页(R)\",\n            minWidth: 0,\n            children: [\n              {\n                label: \"截取可视化区域\",\n                onClick: () => {\n                  this.message = \"截取可视化区域\";\n                  console.log(\"截取可视化区域\");\n                }\n              },\n              { label: \"截取全屏\" }\n            ]\n          },\n          { label: \"查看网页源代码(V)\", icon: \"el-icon-view\" },\n          { label: \"检查(N)\" }\n        ],\n        event, // 鼠标事件信息\n        customClass: \"custom-class\", // 自定义菜单 class\n        zIndex: 3, // 菜单样式 z-index\n        minWidth: 230 // 主菜单最小宽度\n      });\n      return false;\n    }\n  }\n};\n</script>\n```\n# 自定义样式\n打开控制台，查看元素即可查看到菜单的各个 class 名称。最外层的 class 为上面的customClass属性设置的值，样式可根据需求自行调整。\n```js\n<style>\n.custom-class .menu_item__available:hover,\n.custom-class .menu_item_expand {\n  background: #ffecf2 !important;\n  color: #ff4050 !important;\n}\n</style>\n```\n# 总结\n以上就基本使用方法，是不是比自己封装节省了大把时间。注意菜单会在点击左键或者滚轮滚动时自动销毁，同时也可调用this.$contextmenu.destroy()在其他场景自行销毁 。以下是插件的参数配置：\n## MenuOptions 菜单属性\n![Description](https://github.com/zpfzpf123/images/blob/master/1700101354909.jpg?raw=true)\n## MenuItemOptions 选项属性\n![Description](https://github.com/zpfzpf123/images/blob/master/1700101706614.jpg?raw=true)\n\n",
      "id": 31
    },
    {
      "name": "github api+axios 接口上传github图片",
      "type": "js",
      "recommendationIndex": 5,
      "content": "# 作用\n可在前端实现通过接口把图片上传到对应github仓库\n# 创建token\n1. 访问：https://github.com/settings/tokens ，点击 Generate new token 按钮，创建一个新 Token：\n2. 设置一下过期时间，这里我们选择“不会过期”，然后勾选一下 repo 所有权限：\n3. 接着滚到底下点击生成按钮，会看到 Token 生成完毕：\n# 创建github.js\n```js\nimport axios from 'axios'\nimport { Loading, Message } from 'element-ui'\n\naxios.defaults.timeout = 10000\naxios.interceptors.response.use(response => {\n  return response\n}, (err) => {\n  // 返回状态码不为200时候的错误处理\n  Message.error(err.toString())\n  return Promise.reject(err)\n})\nconst repo = 'zpfzpf123/images' // 填你的仓库 repo\nconst cutToken = 'ghp_lUbD67XeagTCo' // 填你的 Token\nconst tailToken = 'kcXfLOOXA01XYysbz0hGN73'\nconst uploader = async(content, files) => {\n  const loadingInstance = Loading.service({ fullscreen: true, text: '正在上传...' }) // 启动全屏加载提示\n  try {\n    const imageUrl = 'https://api.github.com/repos/' + repo + '/contents/' + files + '.png'\n    const body = { message: 'upload', content }\n    const headers = {\n      Authorization: `token ${cutToken}${tailToken}`,\n      Accept: 'application/vnd.github.v3+json'\n    }\n    await axios.put(imageUrl, body, { headers })\n    // 如果上传成功，关闭加载提示并返回文件名\n    loadingInstance.close()\n    Message.success('上传github成功！！回显由于网络延迟，显示不出来或显示较缓慢属于正常现象')\n    return files + '.png'\n  } catch (error) {\n    // 如果上传失败，关闭加载提示并显示错误信息\n    loadingInstance.close()\n    Message.error('上传失败: ' + error.toString())\n    return null\n  }\n}\nexport default {\n  uploader\n}\n```\n# 使用示例\n```js\n async handleUploadImage(event, insertImage, files) {\n      const reader = new FileReader()\n\n      function getBase64(file) {\n        return new Promise((resolve) => {\n          reader.onload = function(event) {\n            const fileContent = event.target.result\n            resolve(fileContent.split(',')[1])\n          }\n          reader.readAsDataURL(file)\n        })\n      }\n\n      const content = await getBase64(files[0]) // 目前上传接口支持上传base64格式图片，所以先将不是base6格式的文件流转化成base64,如果是base64格式忽略这一步\n      try {\n        this.dialogVisible = true\n        this.timer = setInterval(async() => {\n          if (!this.dialogVisible) {\n            clearInterval(this.timer)\n            var path = await github.uploader(content, this.imageName)\n            if (path) {\n              // 此处只做示例\n              insertImage({\n                url: `https://github.com/zpfzpf123/images/blob/master/${path}?raw=true`,\n                desc: `${path}`,\n                width: 'auto',\n                height: 'auto'\n              })\n              this.imageName = ''\n            }\n          }\n        }, 1000)\n      } catch (e) {\n        console.log(e,'e')\n        this.$message.error(e.message)\n        this.imageName = ''\n        clearInterval(this.timer)\n      }\n    },\n```\n# vue代码\n```js\n<template>\n  <div id=\"btn-table\">\n    <el-card class=\"top\">\n      <div class=\"btn\">\n        <el-form ref=\"inquire\" label-width=\"80px\" :model=\"inquire\" inline>\n          <el-form-item label=\"文章标题\" prop=\"name\">\n            <el-input v-model=\"inquire.name_like\" />\n          </el-form-item>\n          <el-form-item label=\"文章类型\" prop=\"type\">\n            <el-select v-model=\"inquire.type\" placeholder=\"请选择文章类型\">\n              <el-option\n                v-for=\"item of noteTypeList\"\n                :key=\"item.label\"\n                :label=\"item.label\"\n                :value=\"item.value\"\n              />\n            </el-select>\n          </el-form-item>\n          <el-form-item style=\"margin-left: 20px\">\n            <button class=\"pan-btn green-btn\" @click.prevent=\"reset\">重置</button>\n          </el-form-item>\n          <el-form-item\n            v-if=\"environment === 'development'\"\n            style=\"margin-left: 20px\"\n          >\n            <button class=\"pan-btn tiffany-btn\" @click=\"addNote\">\n              新增文章\n            </button>\n          </el-form-item>\n        </el-form>\n      </div>\n    </el-card>\n    <el-card style=\"margin-top: 20px; width: 100%\">\n      <div class=\"table\">\n        <el-table\n          :data=\"noteList\"\n          :column=\"column\"\n          height=\"64vh\"\n          :default-sort=\"{ prop: 'recommendationIndex', order: 'descending' }\"\n        >\n          <el-table-column\n            type=\"index\"\n            label=\"序号\"\n            align=\"center\"\n            width=\"50\"\n          />\n          <el-table-column\n            v-for=\"item in column\"\n            :key=\"item.label\"\n            :prop=\"item.prop\"\n            :label=\"item.label\"\n            align=\"center\"\n          />\n          <el-table-column\n            width=\"200px\"\n            label=\"推荐指数\"\n            sortable\n            prop=\"recommendationIndex\"\n          >\n            <template slot-scope=\"scope\">\n              <el-rate\n                v-model=\"scope.row.recommendationIndex\"\n                disabled\n                show-score\n                text-color=\"#ff9900\"\n                :max=\"5\"\n                :min=\"1\"\n              />\n            </template>\n          </el-table-column>\n          <el-table-column label=\"操作\" align=\"center\" width=\"300\">\n            <template slot-scope=\"scope\">\n              <el-button\n                type=\"primary\"\n                @click=\"viewInfo(scope.$index, scope.row)\"\n              >预览\n              </el-button>\n              <el-button\n                v-if=\"environment === 'development'\"\n                style=\"margin-left: 20px\"\n                type=\"warning\"\n                @click=\"editInfo(scope.$index, scope.row)\"\n              >修改\n              </el-button>\n              <el-popconfirm\n                style=\"margin-left: 20px\"\n                title=\"确定要删除选择项吗？\"\n                @onConfirm=\"delInfo(scope.$index, scope.row)\"\n              >\n                <el-button\n                  v-if=\"environment === 'development'\"\n                  slot=\"reference\"\n                  type=\"danger\"\n                >删除文章\n                </el-button>\n              </el-popconfirm>\n            </template>\n          </el-table-column>\n        </el-table>\n      </div>\n    </el-card>\n    <el-dialog-com\n      :visible=\"showAddNote\"\n      :title=\"status === 0 ? '新增文章' : '修改文章'\"\n      fullscreen\n      @closeDialog=\"closeAddNote\"\n    >\n      <template v-slot:content>\n        <el-form ref=\"note\" :model=\"note\" label-width=\"120px\" :rules=\"rules\">\n          <el-form-item label=\"文章标题\" prop=\"name\">\n            <el-input v-model=\"note.name\" />\n          </el-form-item>\n          <el-form-item label=\"文章类型\" prop=\"type\">\n            <el-select v-model=\"note.type\" placeholder=\"请选择文章类型\">\n              <el-option\n                v-for=\"item of noteTypeList\"\n                :key=\"item.label\"\n                :label=\"item.label\"\n                :value=\"item.value\"\n              />\n            </el-select>\n          </el-form-item>\n          <el-form-item\n            label=\"推荐指数\"\n            class=\"postInfo-container-item\"\n            prop=\"recommendationIndex\"\n          >\n            <el-rate\n              v-model=\"note.recommendationIndex\"\n              :max=\"5\"\n              :colors=\"['#99A9BF', '#F7BA2A', '#FF9900']\"\n              :low-threshold=\"1\"\n              :high-threshold=\"5\"\n              style=\"display: inline-block\"\n            />\n          </el-form-item>\n          <el-form-item label=\"文章内容\" prop=\"content\">\n            <v-md-editor\n              v-model=\"note.content\"\n              :disabled-menus=\"[]\"\n              :include-level=\"[1, 2, 3, 4]\"\n              height=\"400px\"\n              @upload-image=\"handleUploadImage\"\n            />\n          </el-form-item>\n        </el-form>\n      </template>\n      <template v-slot:footer>\n        <el-button type=\"primary\" @click=\"submitForm\">提交</el-button>\n      </template>\n    </el-dialog-com>\n    <el-dialog-com\n      :visible=\"showDetail\"\n      title=\"\"\n      width=\"80vw\"\n      @closeDialog=\"closeDetail\"\n    >\n      <template v-slot:content>\n        <div class=\"detail\">\n          <v-md-editor\n            v-if=\"showDetail\"\n            v-model=\"articleDetails\"\n            left-toolbar=\"fullscreen toc\"\n            right-toolbar=\"\"\n            :include-level=\"[1, 2, 3]\"\n            height=\"70vh\"\n            @copy-code-success=\"handleCopyCodeSuccess\"\n          />\n        </div>\n      </template>\n    </el-dialog-com>\n    <el-dialog\n      title=\"输入图片名称\"\n      :visible.sync=\"dialogVisible\"\n      width=\"30%\"\n      @close=\"decideOnAName\"\n      @open=\"focusInput\"\n    >\n      <el-input\n        ref=\"nameInput\"\n        v-model=\"imageName\"\n        placeholder=\"请输入图片名称\"\n        @keyup.enter.native=\"decideOnAName\"\n      />\n      <span slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"dialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"decideOnAName\">确 定</el-button>\n      </span>\n    </el-dialog>\n  </div>\n</template>\n<script>\nimport Note from '@/api/note'\nimport elDialogCom from '@/components/Dialog/el-dialog-com.vue'\nimport db from '../../../static/db'\nimport github from '@/request/github'\nimport { Loading } from 'element-ui'\n\nexport default {\n  name: 'StudyNote',\n  components: {\n    elDialogCom\n  },\n  data() {\n    return {\n      dialogVisible: false,\n      timer: null,\n      imageName: '',\n      status: 0, // 0新增，1修改\n      noteList: [],\n      initList: [],\n      showAddNote: false,\n      showDetail: false,\n      articleDetails: '',\n      noteTypeList: [\n        {\n          label: 'vue',\n          value: 'vue'\n        },\n        {\n          label: 'js',\n          value: 'js'\n        },\n        {\n          label: 'css',\n          value: 'css'\n        },\n        {\n          label: 'uniapp',\n          value: 'uniapp'\n        },\n        {\n          label: 'ai',\n          value: 'ai'\n        },\n        {\n          label: 'component',\n          value: 'component'\n        },\n        {\n          label: '公司',\n          value: '公司'\n        }, {\n          label: 'git',\n          value: 'git'\n        }\n      ],\n      // 组名信息\n      note: {\n        name: '',\n        type: '',\n        recommendationIndex: 0,\n        content: ''\n      },\n      inquire: {\n        name_like: '',\n        type: ''\n      },\n      rules: {\n        name: [{ required: true, message: '请输入文章标题', trigger: 'blur' }],\n        type: [\n          { required: true, message: '请选择文章类型', trigger: 'change' }\n        ]\n      },\n      column: [\n        {\n          prop: 'name',\n          label: '标题'\n        },\n        {\n          prop: 'type',\n          label: '类型'\n        }\n      ]\n    }\n  },\n  computed: {\n    condition() {\n      return { name: this.inquire.name_like, type: this.inquire.type }\n    },\n    environment() {\n      return process.env.NODE_ENV\n    }\n  },\n  watch: {\n    condition: {\n      handler(val) {\n        this.queryTheArticle()\n      }\n    }\n  },\n  mounted() {\n    this.init()\n  },\n  methods: {\n    focusInput() {\n      this.$nextTick(() => {\n        this.$refs.nameInput.focus()\n      })\n    },\n    async handleUploadImage(event, insertImage, files) {\n      const reader = new FileReader()\n\n      function getBase64(file) {\n        return new Promise((resolve) => {\n          reader.onload = function(event) {\n            const fileContent = event.target.result\n            resolve(fileContent.split(',')[1])\n          }\n          reader.readAsDataURL(file)\n        })\n      }\n\n      const content = await getBase64(files[0]) // 目前上传接口支持上传base64格式图片，所以先将不是base6格式的文件流转化成base64,如果是base64格式忽略这一步\n      try {\n        this.dialogVisible = true\n        this.timer = setInterval(async() => {\n          if (!this.dialogVisible) {\n            clearInterval(this.timer)\n            var path = await github.uploader(content, this.imageName)\n            if (path) {\n              // 此处只做示例\n              insertImage({\n                url: `https://github.com/zpfzpf123/images/blob/master/${path}?raw=true`,\n                desc: `${path}`,\n                width: 'auto',\n                height: 'auto'\n              })\n              this.imageName = ''\n            }\n          }\n        }, 1000)\n      } catch (e) {\n        console.log(e,'e')\n        this.$message.error(e.message)\n        this.imageName = ''\n        clearInterval(this.timer)\n      }\n    },\n    init() {\n      if (this.environment === 'development') {\n        Note.getNote()\n          .then((list) => {\n            this.noteList = []\n            this.noteList.push(...list)\n          })\n      } else {\n        this.noteList = []\n        this.noteList.push(...db.note)\n        this.initList = []\n        this.initList.push(...db.note)\n      }\n    },\n    addNote() {\n      this.status = 0\n      this.showAddNote = true\n      this.note = Object.assign(\n        {},\n        {\n          name: '',\n          type: '',\n          recommendationIndex: 0,\n          content: '',\n          id: ''\n        }\n      )\n      this.$nextTick(() => {\n        this.$refs.note.resetFields()\n      })\n    },\n    queryTheArticle() {\n      const condition = Object.fromEntries(\n        Object.entries(this.inquire).filter(\n          ([key, value]) => value != null && value !== ''\n        )\n      )\n      if (this.environment === 'development') {\n        Note.getNote(condition)\n          .then((list) => {\n            this.noteList = []\n            this.noteList.push(...list)\n          })\n      } else {\n        this.noteList = this.initList.filter((item) => {\n          return (\n            item.name.includes(this.inquire.name_like) &&\n            item.type.includes(this.inquire.type)\n          )\n        })\n      }\n    },\n    reset() {\n      this.inquire = Object.assign(\n        {},\n        {\n          name_like: '',\n          type: ''\n        }\n      )\n    },\n    closeAddNote() {\n      this.showAddNote = false\n    },\n    submitForm() {\n      this.$refs.note.validate((valid) => {\n        if (!valid) {\n          return false\n        }\n        if (!this.note.recommendationIndex) {\n          this.$message.warning('请选择推荐指数')\n          return false\n        }\n        if (!this.note.content) {\n          this.$message.warning('请填写文章内容')\n          return false\n        }\n        if (this.status === 0) {\n          const id = this.noteList.length + 1\n          Note.postNote({\n            ...this.note,\n            id\n          }).then((_) => {\n            this.$message.success('添加文章成功！')\n            this.init()\n            this.showAddNote = false\n          })\n        } else if (this.status === 1) {\n          Note.putNote(this.note.id, this.note).then((res) => {\n            this.$message.success('修改文章成功！')\n            this.init()\n            this.showAddNote = false\n          })\n        }\n      })\n    },\n    closeDetail() {\n      this.showDetail = false\n    },\n    viewInfo(index, val) {\n      this.showDetail = true\n      this.$nextTick(() => {\n        this.articleDetails = val.content\n        document.querySelector('.v-md-icon-toc').click()\n      })\n    },\n    decideOnAName() {\n      this.dialogVisible = false\n    },\n    editInfo(index, val) {\n      this.status = 1\n      this.showAddNote = true\n      this.$nextTick(() => {\n        this.$refs.note.resetFields()\n        this.note = Object.assign(\n          {},\n          {\n            name: val.name,\n            type: val.type,\n            recommendationIndex: val.recommendationIndex,\n            content: val.content,\n            id: val.id\n          }\n        )\n      })\n    },\n    delInfo(index, val) {\n      Note.delNote(val.id).then((res) => {\n        this.$message.success('删除成功！')\n      })\n    },\n    handleCopyCodeSuccess() {\n      this.$message.success('复制成功！')\n    }\n  }\n}\n</script>\n<style scoped lang=\"scss\">\n#btn-table {\n  //width: 100%;\n  //height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  box-sizing: border-box;\n  margin: 20px;\n\n  .top {\n    width: 100%;\n    height: 10vh;\n  }\n\n  .btn {\n    width: 100%;\n    flex: 1;\n    display: flex;\n    column-gap: 20px;\n    justify-items: center;\n    align-items: center;\n  }\n\n  .table {\n    width: 100%;\n    flex: 6;\n\n    ::v-deep .el-table {\n      .el-table__body-wrapper {\n        // 滚动条整体部分\n        &::-webkit-scrollbar {\n          width: 6px;\n          height: 6px;\n        }\n\n        // 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。\n        &::-webkit-scrollbar-button {\n          display: none;\n        }\n\n        // 滚动条的轨道（里面装有Thumb）\n        &::-webkit-scrollbar-track {\n          background: transparent;\n        }\n\n        // 滚动条的轨道（里面装有Thumb）\n        &::-webkit-scrollbar-track-piece {\n          background-color: transparent;\n        }\n\n        // 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）\n        &::-webkit-scrollbar-thumb {\n          background: #42b983;\n          cursor: pointer;\n          border-radius: 4px;\n        }\n\n        // 边角，即两个滚动条的交汇处\n        &::-webkit-scrollbar-corner {\n          display: none;\n        }\n\n        // 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件\n        &::-webkit-resizer {\n          display: none;\n        }\n      }\n    }\n  }\n}\n\n.el-select {\n  width: 100%;\n}\n\n.detail {\n\n  //::v-deep .v-note-wrapper {\n  //  padding: 0;\n  //  margin: 0;\n  //  max-width: none;\n  //}\n\n  ::v-deep .v-md-textarea-editor {\n    display: none;\n  }\n\n  ::v-deep .v-md-editor__editor-wrapper {\n    display: none;\n  }\n  ::v-deep .scrollbar{\n    overflow-y: auto;\n  }\n  ::v-deep .v-md-editor__main{\n    overflow-y: auto;\n  }\n  ::v-deep .scrollbar__thumb{\n    background: #42b983;\n  }\n}\n\n.top {\n  ::v-deep .el-card__body {\n    padding: 0 !important;\n    height: 100%;\n\n    .btn {\n      height: 100%;\n      display: flex;\n      align-items: center;\n\n      .el-form {\n        height: 100%;\n        padding: 10px;\n\n        .el-form-item {\n          margin-bottom: 10px;\n        }\n      }\n    }\n  }\n}\n</style>\n```",
      "id": 32
    },
    {
      "name": "检测棚摄像机配置",
      "type": "公司",
      "recommendationIndex": 5,
      "content": "# 1 打开配置工具（批量配置工具）\n# 2 显示未激活页面\n![files.name](https://github.com/zpfzpf123/images/blob/master/image.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n",
      "id": 33
    },
    {
      "name": "git各分支开发，最后合并主分支",
      "type": "git",
      "recommendationIndex": 5,
      "content": "# 1 重新拉取远程分支\n\n```\ngit fetch origin\n```\n\n# 2 将远程的develop代码合并到本地的dev-zhou分支\n\n要将远程的`develop`分支代码合并到本地的`dev-zhou`分支，你可以按照以下步骤操作：\n\n1. **确保你在`dev-zhou`分支上**：\n\n首先，你需要确保你当前在`dev-zhou`分支上工作。你可以使用`git status`查看当前分支，或者使用`git branch`查看所有分支并确认你所在的分支。如果不在`dev-zhou`分支上，使用`git checkout`命令切换到该分支：\n\n```bash\ngit checkout dev-zhou\n```\n\n1. **拉取远程的`develop`分支的最新代码**：\n\n在合并之前，你需要确保本地的`develop`分支是最新的，与远程仓库的`develop`分支保持一致。使用`git fetch`和`git merge`或者`git pull`来更新你的本地`develop`分支：\n\n```bash\ngit fetch origin develop  \ngit checkout develop  \ngit merge origin/develop\n```\n\n或者你也可以直接使用`git pull`来简化这个过程：\n\n```bash\ngit checkout develop  \ngit pull origin develop\n```\n\n这将会把远程`develop`分支的最新代码合并到你的本地`develop`分支。\n\n1. **将`develop`分支的代码合并到`dev-zhou`分支**：\n\n现在你已经有了最新的`develop`分支代码，可以将其合并到`dev-zhou`分支：\n\n首先，切换回`dev-zhou`分支（如果你之前不在这个分支上）：\n\n``` \ngit checkout dev-zhou\n```\n\n然后，将`develop`分支的代码合并到`dev-zhou`分支：\n\n```bash\ngit merge develop\n```\n\nGit会尝试将`develop`分支上的更改合并到`dev-zhou`分支。如果有冲突，Git会暂停合并过程，并标记出冲突的文件。你需要手动编辑这些文件来解决冲突，然后运行`git add`来标记冲突已解决，并最后使用`git commit`来提交合并的更改。\n\n1. **解决可能的冲突**：\n\n如果在合并过程中出现冲突，你需要打开有冲突的文件，查找并编辑以`<<<<<<<`、`=======`和`>>>>>>>`标记的区域，以解决冲突。解决完冲突后，保存文件并使用`git add`命令将文件添加到暂存区：\n\n```bash\ngit add <conflicted-file>\n```\n\n重复这个过程，直到所有的冲突都已解决。\n\n1. **提交合并的更改**：\n\n一旦所有的冲突都已解决，你可以提交这个合并：\n\n```bash\ngit commit -m \"Merge develop into dev-zhou\"\n```\n\n1. **（可选）推送更改到远程仓库**：\n\n如果你想要将本地的更改推送到远程仓库的`dev-zhou`分支，使用`git push`命令：\n\n```bash\ngit push origin dev-zhou\n```\n\n这样，你就成功地将远程的`develop`分支代码合并到了本地的`dev-zhou`分支，并可以选择将更改推送到远程仓库。\n\n# 3 将dev-zhou分支推给远程develop分支\n\n1. 首先，确保你的本地`dev-zhou`分支是最新的。在`dev-zhou`分支上运行`git pull`来同步远程变更。\n\n   ```bash\n   git checkout dev-zhou\n   git pull origin dev-zhou\n   ```\n\n   \n\n2. 切换到本地的`develop`分支，并拉取最新的远程变更，以确保合并时没有冲突。\n\n   ```bash\n   git checkout develop\n   git pull origin develop\n   ```\n\n   \n\n3. 将`dev-zhou`分支的变更合并到`develop`分支。\n\n   ```bash\n   git merge dev-zhou\n   ```\n\n   \n\n4. 如果合并成功且没有冲突，推送合并后的变更到远程的`develop`分支。\n\n   ```bash\n   git push origin develop\n   ```",
      "id": 34
    },
    {
      "name": "vue3+ts+axios封装",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "在Vue 3和TypeScript中封装Axios的一个基本方法涉及创建一个服务类，它使用Axios实例来发送HTTP请求。以下是一个简单的封装示例：\n```js\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\n\n// 定义接口以扩展AxiosResponse\ninterface CustomAxiosResponse<T> extends AxiosResponse {\n  data: T;\n}\n\n// 创建一个服务类\nclass AxiosService {\n  private instance: AxiosInstance;\n\n  constructor() {\n    // 创建axios实例\n    this.instance = axios.create({\n      baseURL: '你的API基础URL',\n      // 其他配置...\n    });\n\n    // 请求拦截器\n    this.instance.interceptors.request.use(\n      (config: AxiosRequestConfig) => {\n        // 在这里添加例如token等请求头信息\n        // config.headers.Authorization = `Bearer ${token}`;\n        return config;\n      },\n      (error) => {\n        return Promise.reject(error);\n      }\n    );\n\n    // 响应拦截器\n    this.instance.interceptors.response.use(\n      (response: CustomAxiosResponse<any>) => {\n        // 在这里处理响应数据，例如转换格式\n        return response.data;\n      },\n      (error) => {\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  // 封装GET请求\n  public get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    return this.instance.get<T, CustomAxiosResponse<T>>(url, config);\n  }\n\n  // 封装POST请求\n  public post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this.instance.post<T, CustomAxiosResponse<T>>(url, data, config);\n  }\n\n  // ...可以继续封装其他请求方法\n}\n\n// 使用封装好的AxiosService\nconst axiosService = new AxiosService();\n\nexport default axiosService;\n```\n在上面的代码中，我们创建了一个AxiosService类，它包含了一个Axios实例和一些基本的HTTP请求方法。我们还添加了请求和响应拦截器来处理通用逻辑，如添加认证头和处理返回数据。\n\n你可以根据你的项目需求进一步扩展这个服务类，例如添加更多的请求方法或者处理更复杂的拦截逻辑。这个封装方法的好处是可以在多个组件或服务中重用AxiosService，并且可以轻松地替换底层的HTTP请求库.接下来我们再加一些请求和拦截举例，如下。\n```js\n// ...之前的AxiosService代码...\n\n// 封装PUT请求\npublic put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n  return this.instance.put<T, CustomAxiosResponse<T>>(url, data, config);\n}\n\n// 封装DELETE请求\npublic delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n  return this.instance.delete<T, CustomAxiosResponse<T>>(url, config);\n}\n\n// ...其他HTTP请求方法...\n\n// 添加更复杂的拦截逻辑\n// 例如，自动刷新token，处理全局错误等\nthis.instance.interceptors.response.use(\n  (response: CustomAxiosResponse<any>) => {\n    // 如果响应中的token即将过期，自动刷新token\n    if (response.headers['x-refresh-token']) {\n      // 假设有一个refreshToken方法可以调用\n      refreshToken(response.headers['x-refresh-token']);\n    }\n    return response.data;\n  },\n  (error) => {\n    // 处理全局的HTTP错误，例如401或500等\n    if (error.response && error.response.status === 401) {\n      // 假设有一个handleUnauthorized方法可以调用\n      handleUnauthorized();\n    } else if (error.response && error.response.status >= 500) {\n      // 假设有一个handleServerError方法可以调用\n      handleServerError();\n    }\n    return Promise.reject(error);\n  }\n);\n\n// ...其他拦截逻辑...\n```\n在这个扩展中，我们添加了put和delete方法来处理PUT和DELETE请求。同时，我们在响应拦截器中添加了一些逻辑来处理token刷新和全局错误。\n\n请注意，上述代码中的refreshToken、handleUnauthorized和handleServerError方法需要你根据实际情况来实现。这些方法通常会涉及到与用户认证相关的逻辑，比如刷新token或者重定向到登录页面。\n使用封装好的AxiosService非常简单。首先，你需要在你的Vue组件或者服务中导入这个服务。然后，你可以调用它提供的方法来发送HTTP请求。以下是一个在Vue组件中使用AxiosService的例子：\n```js\n<script lang=\"ts\">\nimport { defineComponent } from 'vue';\nimport axiosService from '@/services/AxiosService'; // 假设你的服务文件位于services文件夹\n\nexport default defineComponent({\n  name: 'ExampleComponent',\n\n  methods: {\n    async fetchData() {\n      try {\n        const response = await axiosService.get<{ message: string }>('/path/to/your/api');\n        console.log(response.message);\n      } catch (error) {\n        console.error('An error occurred:', error);\n      }\n    }\n  },\n\n  mounted() {\n    this.fetchData();\n  }\n});\n</script>\n```\n在这个例子中，我们在组件的mounted生命周期钩子中调用了fetchData方法。这个方法使用axiosService.get来发送GET请求到指定的API路径。我们假设API响应的数据格式是一个对象，包含一个message属性。我们使用TypeScript的泛型来指定响应数据的类型，这样我们就可以得到类型检查和自动完成的好处。\n\n如果你想要发送POST请求，可以这样做：\n```js\nasync createData() {\n  try {\n    const postData = { name: 'New Item', price: 100 };\n    const response = await axiosService.post<{ id: number }>('/path/to/your/api', postData);\n    console.log('Created new item with ID:', response.id);\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n}\n```\n在这个POST请求的例子中，我们发送了一个新的数据对象到API，并且假设API会返回一个包含新创建的项目ID的响应。\n\n这些例子展示了如何在Vue组件中使用封装好的AxiosService来发送GET和POST请求。你可以根据需要添加更多的方法和逻辑来处理其他类型的请求和响应。",
      "id": 35
    },
    {
      "name": "广钞服务器操作",
      "type": "公司",
      "recommendationIndex": 5,
      "content": "# 启动nginx\n\n```bash\ncd nginx目录\n./sbin/nginx -p ./\n```\n\n# 启动接口\t\n\n```bash\ncd  /cambricon/etc\n./zckx.sh\n```\n\n",
      "id": 36
    },
    {
      "name": "检测棚服务器配置",
      "type": "公司",
      "recommendationIndex": 5,
      "content": "#  0 开机初始密码\n\n```\ndell+123456\n```\n\n+ 凡是遇到权限不够的 在前面加上sudo\n\n# 1 设置root密码\n\n```bash\nsudo passwd\n```\n\n# 2 创建cbpm用户\n\n```bash\nsudo su\nadduser cbpm\nadduser cbpm sudo\n```\n\n+ 创建后需要切换到cbpm用户下后再打开终端操作 \n\n# 3 安装curl\n\n+ 安装前需要有网，插好网线，ip设置为自动。\n\n```bash\nsudo apt install curl\n```\n\n# 4 安装docker\n\n```bash\nsudo curl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh get-docker.sh\n```\n\n# 5 安装vim\n\n```bash\nsudo apt install vim\n```\n\n# 6 设置镜像加速\n\n```bash\ncd /etc/docker\ntouch daemon.json\nsudo vim daemon.json\n```\n\n+ 修改daemon.json内容为\n\n  ```bash\n  {\n          \"registry-mirrors\":[\"https://docker.mirrors.ustc.edu.cn\"]\n  }\n  ```\n\n  \n\n# 7 安装docker-compose\n\n使用命令 \n\n```bash\nsudo docker info\n```\n\n查看已安装的docker是否自带dockers compose插件\n\n如果没有安装插件，可以使用命令\n\n```bash\nsudo apt-get install docker-compose\n```\n\n安装docker-compose\n\n这个时候需要查看PATH环境变量，确保当前命令是否存在于PATH环境变量中：\n\n```bash\necho $PATH\n```\n\n如果命令行的路径不在PATH环境变量路径中，则需要修改PATH环境变量，具体方法如下：\n\n```bash\n#通过修改profile文件:\nsudo vim /etc/profile\nexport PATH=docker-compose路径:$PATH\n#生效方法：（有以下两种）\n#1、关闭当前终端窗口，重新打开一个新终端窗口就能生效\n#2、输入“source /etc/profile”命令，立即生效\n#有效性：只在当前终端生效\n#2：系统重启\n#有效期限：永久有效\n#用户局限：对所有用户\n```\n\n# 8 配置docker用户组\n\n在默认情况下，docker命令需要使用sudo权限来执行。使用sudo权限执行命令可能会影响到环境变量，所以最好对docker用户组进行设置，把系统当前用户添加到docker用户组。\n\n依次执行下列命令即完成设置：\n\n```bash\nsudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n```\n\n# 9 移植docker镜像\n\n在开发机器使用下列任一命令完成打包，然后将tar包拷贝到目标机器进行安装：\n\n ```bash\n docker save -o 打包名.tar 镜像名:版本\n docker save -o 打包名.tar 镜像ID\n ```\n\n使用镜像ID打包的镜像文件，在安装后可能出现镜像名和版本为“<none>”的情况。\n\n# 10 安装docker镜像\n\n```bash\ncd /test/docker-images\n#依次加载所有镜像 \ndocker load -i 镜像包名.tar\n```\n\n+ 镜像列表如下\n\n  | 序号 | 镜像名                     |                功能/用途                |\n  | ---- | -------------------------- | :-------------------------------------: |\n  | 1    | rabbitmq:3.10.5-management |                rabbitmq                 |\n  | 2    | mysql:8.0.29               |                  mysql                  |\n  | 3    | redis:6.2.7                |                  redis                  |\n  | 4    | workshed-base:env_abnormal |                  算法                   |\n  | 5    | cenv:2.0                   |                C/C++程序                |\n  | 6    | java:8                     |                 web后台                 |\n  | 7    | 6053537/portainer-ce       | 应用监控用户名admin 密码adminadminadmin |\n  |      | ubuntu18.04.1              |       流媒体服务（客户端/服务端）       |\n\n# 11 镜像安装结果验证\n\n使用命令：\n\n```bash\ndocker images\n#检查显示结果的镜像和版本号与docker-compose.yml中的配置是否可以一一对应\n```\n\n查看镜像安装结果。\n\n# 12 docker开机自启动\n\n```bash\nsystemctl enable docker\n```\n\n# 13 容器的开机自启动\n\n容器的“--restart”参数控制容器的重启策略，当设置为“always”时容器会自动尝试重启，设置为“no”则不尝试重启。当执行了“docker stop”命令， --restart 失效，容器不再尝试重启。\n\n“--restart”参数可以在容器创建时设置，“docker run -it --name=test_container --restart=always cenv:2.0”。\n\n已创建的容器可使用“docker container update”命令修改“--restart”参数值，“docker container update --restart=no 容器ID或容器名称”\n\n# 14 把其他磁盘挂载到指定目录\n\n•  首先，你需要安装逻辑卷管理系统工具lvm2，这个工具可以让你将多个物理卷（硬盘或分区）组合成一个卷组，然后在卷组上创建一个或多个逻辑卷，这样就可以将多个硬盘的空间合并起来  。你可以使用`sudo apt install lvm2`命令来安装这个工具  。\n\n•  然后，你需要查看你的电脑上有哪些硬盘和分区，以及它们的设备名和文件系统类型。你可以使用`sudo fdisk -l`命令来查看这些信息  。\n\n•  接着，你需要创建物理卷，这是逻辑卷管理中的最底层单位，它可以是硬盘或分区。你可以使用`sudo pvcreate /dev/sdX`命令来创建物理卷，其中/dev/sdX是你要创建物理卷的硬盘或分区的设备名  。\n\n•  然后，你需要创建卷组，这是逻辑卷管理中的中间层单位，它可以包含一个或多个物理卷。你可以使用`sudo vgcreate vg_name /dev/sdX /dev/sdY` ...命令来创建卷组，其中vg_name是你要创建的卷组的名称，/dev/sdX /dev/sdY ...是你要加入到卷组中的物理卷的设备名  。\n\n•  接着，你需要创建逻辑卷，这是逻辑卷管理中的最高层单位，它可以在卷组中划分出一部分空间，并作为一个独立的设备来使用。你可以使用`sudo lvcreate -n lv_name -l 100%FREE vg_name`命令来创建逻辑卷，其中lv_name是你要创建的逻辑卷的名称，vg_name是你要从中划分空间的卷组的名称  。\n\n•  然后，你需要格式化逻辑卷，这样才能在上面存储数据。你可以使用`sudo mkfs.ext4 /dev/mapper/vg_name-lv_name`命令来格式化逻辑卷为ext4文件系统类型，其中/dev/mapper/vg_name-lv_name是逻辑卷的设备名  。\n\n•  最后，你需要将逻辑卷挂载到指定的文件夹上，这样才能访问和操作数据。你可以使用`sudo mount /dev/mapper/vg_name-lv_name /home/cbpm/ftproot`命令来挂载逻辑卷到指定的文件夹上，其中/home/cbpm/ftproot是你要挂载到的文件夹的路径  。如果你想让逻辑卷在每次开机时自动挂载到指定的文件夹上，你需要修改/etc/fstab文件，在最后一行添加一条记录  :\n\n`/dev/mapper/vg_name-lv_name /home/cbpm/ftproot ext4 defaults 0 0`\n\n\n\n# 15  docker-compose启动命令\n\n```bash\ndocker-compose up -d\n# “-d”参数让容器后台运行。\n```\n\n如果算法镜像启动失败，执行以下命令。\n\n```bash\n#先关闭docker-compose\ndocker compose down\n#验证nvidia-cuda-toolkit是否安装\nnvcc --version\n#安装CUDA 12.2 nvidia-cuda-toolkit\nsudo apt install nvidia-cuda-toolkit\n#安装nvidia-container-runtime\nsudo curl -s -L https://nvidia.github.io/nvidia-container-runtime/gpgkey | \\ sudo apt-key add -\n\n\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID)\n\nsudo curl -s -L https://nvidia.github.io/nvidia-container-runtime/$distribution/nvidia-container-runtime.list | \\ sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list\n\nsudo apt-get update\n \nsudo apt-get install nvidia-container-runtime\n```\n\n重启服务器。\n\n# 16 使用crontab命令实现开机启动\n\n使用“crontab -e”命令开启定时任务编辑，@reboot表示开机时执行。\n\n@reboot (sleep 120; sh /home/cbpm/zhudao/test/jcp_start.sh)\n\n+ jcp_start.sh是一个脚本，建议放在代码文件夹下，方便管理\n\n编辑成功后使用“crontab -l”命令可查看定时任务内容。\n\njcp_start.sh脚本中调用“docker-compose up -d”命令实现启动。\n\n# 17 docker-compose.yml\n\n```yaml\nversion: '3.3'\nservices:\n\n# 基础服务\n  rabbitmq-server:\n    image: \"rabbitmq:3.10.5-management\"\n    container_name: rabbitmq-server\n    restart: always\n    ports:\n      - \"15672:15672\"\n      - \"5672:5672\"\n    environment:\n      - RABBITMQ_DEFAULT_USER=cbpm\n      - RABBITMQ_DEFAULT_PASS=cbpm2016      \n    volumes:\n      - ./server/config/rabbitmq:/etc/rabbitmq/conf.d/\n      - ./server/data/rabbitmq:/var/lib/rabbitmq\n      - /etc/localtime:/etc/localtime\n\n  mysql-server:\n    image: \"mysql:8.0.29\"\n    container_name: mysql-server\n    restart: always\n    ports:\n      - \"3306:3306\"\n    environment:\n      - \"MYSQL_ROOT_PASSWORD=cbpm2016\"\n      - \"TZ=Asia/Shanghai\"\n    volumes:\n      - ./server/data/mysql:/var/lib/mysql\n      - ./server/config/mysql:/etc/mysql/conf.d \n      - ./server/data/mysql/init:/docker-entrypoint-initdb.d\n      - /etc/localtime:/etc/localtime\n      \n  redis-server:\n    image: \"redis:6.2.7\"\n    container_name: redis-server\n    restart: always\n    ports:\n      - \"6379:6379\"\n    command: [\"redis-server\",\"/etc/redis/redis.conf\"]\n    volumes: \n      - ./server/config/redis:/etc/redis\n      - ./server/data/redis:/data/\n      - /etc/localtime:/etc/localtime\n      \n#算法\n  alg-probe:\n    image: \"workshed-base:env_abnormal\"\n    restart: always\n    container_name: alg-probe\n    command: [\"./ProbeDetectionAlgDocker/run_probe_algorithm.sh\"]\n    deploy:\n      resources:\n        reservations:\n          devices:\n          - driver: nvidia\n            device_ids: ['1']\n            capabilities: [gpu]\n    volumes:\n      - ./code/algorithm/ProbeDetectionAlgDocker:/workspace/ProbeDetectionAlgDocker\n      - /etc/localtime:/etc/localtime\n      - ../ftproot/:/home/cbpm/zcxd/ftproot\n      - ../ftproot/logs/algorithm:/home/cbpm/zcxd/ftproot/logs/algorithm\n    depends_on:\n      - redis-server\n    ipc: host\n    \n  alg-other:\n    image: \"workshed-base:env_abnormal\"\n    restart: always\n    container_name: alg-other\n    command: [\"./RaillObjDetectionAlg/run_all_algorithm.sh\"]\n    deploy:\n      resources:\n        reservations:\n          devices:\n          - driver: nvidia\n            device_ids: ['2']\n            capabilities: [gpu]\n    volumes:\n      - ./code/algorithm/RaillObjDetectionAlg:/workspace/RaillObjDetectionAlg\n      - /etc/localtime:/etc/localtime\n      - ../ftproot/:/ftproot\n      - ../ftproot/logs/algorithm:/home/cbpm/zcxd/ftproot/logs/algorithm\n    depends_on:\n      - redis-server\n    ipc: host    \n    \n#程序\n  jcpdetect:\n    image: \"cenv:2.0\"\n    restart: always\n    container_name: jcpdetect\n    working_dir: /jcpdetect/build \n    command: [\"./jcpdetect\"]\n    volumes:  \n      - ./code/jcpdetect:/jcpdetect\n      - ../ftproot/:/ftproot\n      - ../ftproot/image-video/image_origin:/home/cbpm/zcxd/ftproot/image-video/image_origin/\n      - ../ftproot/image-video/image_result:/home/cbpm/zcxd/ftproot/image-video/image_result/\n      - /etc/localtime:/etc/localtime\n    depends_on:\n      - mysql-server\n      - rabbitmq-server\n      - redis-server\n    ipc: host\n      \n  control_preset_point:\n    image: \"cenv:2.0\"\n    restart: always\n    container_name: control_preset_point\n    working_dir: /control_preset_point/bin\n    command: [\"./HIKCamPTZCtrlAndCapPicture\"]\n    volumes:  \n      - ./code/control_preset_point:/control_preset_point\n      - /etc/localtime:/etc/localtime\n    ipc: host\n    \n  push_video:\n    image: \"cenv:2.0\"\n    restart: always\n    deploy:\n      resources:\n        reservations:\n          devices:\n          - driver: nvidia\n            count: 1\n            capabilities: [gpu]\n    container_name: push_video\n    working_dir: /push_video\n    command: [\"./push_video\"]\n    volumes:  \n      - ./code/push_video:/push_video  \n      - /etc/localtime:/etc/localtime\n      - /home/cbpm/zhudao/test/videos:/test_videos\n    ipc: host\n    \n  decode_video:\n    image: \"cenv:2.0\"\n    restart: always\n    deploy:\n      resources:\n        reservations:\n          devices:\n          - driver: nvidia\n            count: 1\n            capabilities: [gpu]\n    container_name: decode_video\n    working_dir: /decode_video\n    command: [\"./decode_video\"]\n    volumes:  \n      - ./code/decode_video:/decode_video    \n      - /etc/localtime:/etc/localtime\n      - /home/cbpm/zhudao/test/videos:/test_videos\n    ipc: host\n    \n  store_alarm_video:\n    image: \"cenv:2.0\"\n    restart: always\n    container_name: store_alarm_video\n    working_dir: /store_alarm_video\n    command: [\"./store_alarm_video\"]\n    volumes:  \n      - ./code/store_alarm_video:/store_alarm_video\n      - ../ftproot/image-video/video_origin:/home/cbpm/zcxd/ftproot/image-video/video_origin\n      - /home/cbpm/zhudao/test/videos:/test_videos\n      - /etc/localtime:/etc/localtime\n      \n  store_real_time_video:\n    image: \"cenv:2.0\"\n    restart: always\n    container_name: store_real_time_video\n    working_dir: /store_real_time_video\n    command: [\"./store_real_time_video\"]\n    volumes:  \n      - ./code/store_real_time_video:/store_real_time_video    \n      - ../ftproot/video/realtime:/home/cbpm/zcxd/ftproot/video/realtime\n      - /home/cbpm/zhudao/test/videos:/test_videos\n      - /etc/localtime:/etc/localtime     \n\n# web程序 \n  web-server:\n    image: \"java:8\"\n    restart: always\n    container_name: web-server\n    working_dir: /web   \n    entrypoint: [\"java\",\"-jar\"] \n    command: \n      - -Dloader.path=lib/\n      - -Dspring.config.additional-location=config/application.yml \n      - -Duser.timezone=GMT+8\n      - jar/checkshed02.jar\n    ports:\n      - \"2000:2000\"\n    volumes:  \n      - ./code/web:/web\n      - ./code/:/code\n      - ../ftproot/:/ftproot\n      - ../:/data\n      - /etc/localtime:/etc/localtime\n    depends_on:\n      - mysql-server\n      - rabbitmq-server\n\n    \n  node-media-cms:\n    restart: always\n    image: \"ubuntu:18.04.1\"\n    container_name: node-media-cms\n    working_dir: /node-media-cms\n    entrypoint: [\"./start.sh\"] \n    ports:\n      - \"8100:8100\"\n    volumes:  \n      - ./code/node-media-cms:/node-media-cms\n      - /etc/localtime:/etc/localtime\n    depends_on:\n      - push_video\n      - decode_video\n      - web-server\n      \n  node-media-server:\n    restart: always\n    image: \"ubuntu:18.04.1\"\n    container_name: node-media-server\n    working_dir: /node-media-server\n    entrypoint: [\"./start.sh\"]\n    ports:\n      - \"8000:8000\"\n      - \"1935:1935\"\n    volumes:  \n      - ./code/node-media-server:/node-media-server\n      - /etc/localtime:/etc/localtime\n    depends_on:\n      - push_video\n      - decode_video\n      - web-server\n    \n# #磁盘清理程序\n  # DiskMonitor:\n    # image: \"cenv:2.0\"\n    # restart: always\n    # container_name: DiskMonitor\n    # working_dir: /DiskMonitor/install\n    # command: [\"./diskmonitor\"]\n    # volumes:  \n      # - ./code/DiskMonitor/install:/DiskMonitor/install    \n      # - ../ftproot/:/ftproot\n      # - /etc/localtime:/etc/localtime     \n\n \n      \n#应用监控 用户名admin 密码adminadminadmin\n  portainer:\n    image: \"6053537/portainer-ce\"\n    container_name: portainer\n    restart: always\n    working_dir: /workspace\n    ports:\n      - \"19000:9000\"\n      - \"18000:8000\"\n    volumes:\n      - ./server/data/portainer:/data\n      - /var/run/docker.sock:/var/run/docker.sock \n      - /etc/localtime:/etc/localtime      \n```\n\n# 18 设置最大日志内存\n\n### 全局范围内\n\n修改docker daemon.json文件，配置日志文件参数\n默认 /etc/docker/daemon.json\n\n```json\n{\n\t\"log-driver\": \"json-file\",\n\t\"log-opts\": {\n\t\t\"max-size\": \"2000m\",\n\t\t\"max-file\": \"2\"\n\t}\n}\n```\n\n修改后，docker需要重新加载配置文件和重启。\n\n```\nsudo systemctl daemon-reload\n```\n\n\n\n# # 注意事项\n\n+ 把上海南翔的code文件夹拷贝一份，然后需要修改一下网卡ip端口配置\n\n主导需要做的端口映射",
      "id": 37
    },
    {
      "name": "检测棚跨网段访问 验证情况说明",
      "type": "公司",
      "recommendationIndex": 5,
      "content": "1 设备连接\n本次验证工作设备网络拓扑结构如下图所示。\n![files.name](https://github.com/zpfzpf123/images/blob/master/1n0j2z9eag.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n2 路由器配置\n本次验证工作中，内网使用192.168.31.1网段，外网使用10.128.150.1网段。\n2.1 内网配置\n![files.name](https://github.com/zpfzpf123/images/blob/master/2sbdesaxfh.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n2.2 外网设置\n![files.name](https://github.com/zpfzpf123/images/blob/master/xpavif7d32.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n2.3 端口映射\n![files.name](https://github.com/zpfzpf123/images/blob/master/t317bg7mrh.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n3 验证结果\n模拟动车段电脑跨网段访问“10.128.150.170:2000”效果如下图所示，可以跨网段查看现场监控视频。\n![files.name](https://github.com/zpfzpf123/images/blob/master/qvnkz0i93h.png?raw=true){{{width=\"auto\" height=\"auto\"}}}",
      "id": 38
    },
    {
      "name": "石钞项目-天衡公司相关资料",
      "type": "公司",
      "recommendationIndex": 5,
      "content": "# 1 gitlab地址\n```js\n网址：https://gitlab.office.iios.com.cn/\n账号：kx_pengfei_zhou\n密码：18582297328zpf\n```\n# 2 打包网址\n```js\n网址：http://jenkins.office.iios.com.cn/\n账号：kx_pengfei_zhou\n密码：eg5ju4ZQ5wuAQc2cpyUW\n```\n# 3 地听智造平台\n```js\n网址:https://www.dev.iios.com.cn/\n账号:zpf\n密码:eg5ju4ZQ5wuAQc2cpyUW\n```",
      "id": 39
    },
    {
      "name": "es6+高阶js",
      "type": "js",
      "recommendationIndex": 5,
      "content": "# 1 创建类和对象\n\n![类和对象.png](https://github.com/zpfzpf123/images/blob/master/类和对象.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n```js\n    class Star {\n      constructor(uname, age) {\n        this.uname = uname\n        this.age = age\n      }\n    }\n    var ldh = new Star('ldh', 55)\n    console.log(ldh);\n```\n\n# 2 创建类方法\n\n```js\n    class Star {\n      constructor(uname, age) {\n        this.uname = uname\n        this.age = age\n      }\n      sing(song) {\n        console.log(`${this.uname}唱了${song}`);\n      }\n    }\n    var ldh = new Star('ldh', 55)\n    ldh.sing('今天')// ldh唱了今天\n```\n\n# 3 类的继承\n\n## 子承父类extends\n\n```js\n    class Father {\n      constructor(x, y) {\n        this.x = x\n        this.y = y\n      }\n      sum() {\n        return this.x + this.y\n      }\n      sing() {\n        console.log('sing');\n      }\n    }\n    class Son extends Father {\n\n    }\n    var son = new Son()\n    son.sing()\n```\n\n## super关键字\n\n![image-20201117170407358](D:\\images\\image-20201117170407358.png)\n\n```js\n    class Father {\n      constructor(x, y) {\n        this.x = x\n        this.y = y\n      }\n      sum() {\n        console.log(this.x + this.y);\n      }\n      sing() {\n        return '我是父亲'\n      }\n    }\n    class Son extends Father {\n      constructor(x, y) {\n        super(x, y)// 继承父类x,y\n      }\n      sing() {\n        return super.sing()//继承父类方法\n      }\n    }\n    var son = new Son(111, 112)\n    console.log(son.sing());// 我是父亲\n    son.sum()// 223\n```\n\n## super必须放到this前\n\n```js\n    class Father {\n      constructor(x, y) {\n        this.x = x\n        this.y = y\n      }\n      sum() {\n        console.log(this.x + this.y);\n      }\n      sing() {\n        return '我是父亲'\n      }\n    }\n    class Son extends Father {\n      constructor(x, y) {\n        super(x, y)//super必须放到this前 不然会报错\n        this.x = x\n        this.y = y\n      }\n      sing() {\n        return super.sing()\n      }\n      sub() {\n        console.log(this.x - this.y);\n      }\n    }\n    var son = new Son(111, 112)\n    son.sum()\n    son.sub()\n```\n\n# 4 函数this指向\n\n![this指向.png](https://github.com/zpfzpf123/images/blob/master/this指向.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n## call()\n\n1 call方法可以调用函数\n\n2 call方法可以改变函数的this指向\n\n3 call可以实现继承\n\n```js\n    function Star(uname, age) {\n      this.uname = uname\n      this.age = age\n    }\n    function S(uname, age) {\n      Star.call(this, uname, age)\n    }\n    var ldh = new S('刘德华', 55)\n    console.log(ldh);// S {uname: '刘德华', age: 55}\n```\n\n## apply()\n\n1 apply方法可以调用函数\n\n2 apply方法可以改变函数的this指向\n\n3 apply可以实现继承\n\n4 apply的参数是数组形式\n\n```js\n    var arr = [1, 23, 34, 3, 423, 4234, 3, 434, 32, 423, 34]\n    var max = Math.max.apply(this, arr)\n    console.log(max)// 4234\n```\n\n## bind()\n\n1bind()不会调用函数，知识返回一个原函数的拷贝\n\nxxxxxxxxxx     console.log([1, 2, 3].includes(3, -1));// 搜索值3 起始位置倒数第一个-1 true    console.log([1, 2, 3].includes(4));// false    console.log([1, 2, 3].includes(1, 2, 3, 4));//false    console.log([1, 2, 3].includes(1, 2, 4));//falsejs\n\n```js\n    var o = {\n      name: 'andy'\n    }\n    function a(a, b) {\n      console.log(this);\n      console.log(a + b);\n    }\n    a.bind(o, 1, 2)()\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <button>点击</button>\n  <script>\n    var btn = document.querySelector('button')\n    btn.addEventListener('click', function () {\n      this.disabled = true\n      setTimeout(function () {\n        this.disabled = false\n      }.bind(this), 2000)\n    })\n  </script>\n</body>\n\n\n</html>\n```\n\n# 5 严格模式\n\n## 严格模式的启用\n\n```js\n'use strict'\n```\n\n## 变量变化\n\n![严格模式-变量变化.png](https://github.com/zpfzpf123/images/blob/master/严格模式-变量变化.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n## this指向改变\n\n![this指向改变.png](https://github.com/zpfzpf123/images/blob/master/this指向改变.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n## 函数变化\n\n![严格模式-函数变化.png](https://github.com/zpfzpf123/images/blob/master/严格模式-函数变化.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n# 6 高阶函数\n\n![高阶函数.png](https://github.com/zpfzpf123/images/blob/master/高阶函数.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n# 7 闭包\n\n![闭包.png](https://github.com/zpfzpf123/images/blob/master/闭包.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n```js\n    function fn() {\n      var sum = 10\n      return function () {\n        console.log(sum);\n      }\n    }\n    var a = fn()\n    a()\n```\n\n闭包作用:延伸了变量的使用范围\n\n## 例子 点击li打印当前索引号\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <ul>\n    <li>你好</li>\n    <li>我好</li>\n    <li>大家好</li>\n    <li>世界好</li>\n  </ul>\n  <script>\n    var lis = document.querySelector('ul').querySelectorAll('li')\n    for (var i = 0; i < lis.length; i++) {\n      (function (i) {\n        lis[i].onclick = function () {\n          console.log(i);\n        }\n      })(i)\n    }\n  </script>\n</body>\n\n\n</html>\n```\n\n## 例子 打车\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <script>\n    //打车起步价13元(3公里以内)，堵车加10元，每公里加五元\n    var a = (function () {\n      var start = 13\n      var total = 13\n      return {\n        price: function (n, flag) {\n          if (flag) {\n            total = 23\n            return n <= 3 ? total : total = (n - 3) * 5 + total\n          } else {\n            total = 13\n            return n <= 3 ? total : total = (n - 3) * 5 + total\n          }\n        }\n      }\n    })()\n    console.log(a.price(4, false));\n  </script>\n</body>\n\n\n</html>\n```\n\n# 8 递归\n\n## 利用递归查找元素\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <script>\n    var data = [\n      {\n        id: 1,\n        name: '家电',\n        goods: [{\n          id: 11,\n          name: '冰箱'\n        }, {\n          id: 22,\n          name: '电视机'\n        }]\n      },\n      {\n        id: 2,\n        name: '衣服'\n      }\n    ]\n    //根据id号取出对象 遍历数组 递归\n    function get(json, id) {\n      var o = {}\n      json.forEach(function (value) {\n        if (value.id == id) {\n          o = value\n        } else if (value.goods && value.goods.length > 0) {\n          o = get(value.goods, id)\n        }\n      })\n      return o\n    }\n    console.log(get(data, 22));\n  </script>\n</body>\n\n\n</html>\n```\n\n# 9 浅拷贝和深拷贝\n\n![深浅拷贝.png](https://github.com/zpfzpf123/images/blob/master/深浅拷贝.png?raw=true){{{width=\"auto\" height=\"auto\"}}}\n\n\n\n浅拷贝对更深一层进行拷贝时，只是把对象地址拷贝给了新元素，当我们改变新元素的值时，旧元素会一起改变\n\n## 浅拷贝\n\n```js\n    var a = {\n      name: 'zpf',\n      age: 18,\n      height: {\n        name: 'zpf',\n        age: 18\n      }\n    }\n    var o = {}\n    /* for (let k in a) {\n      o[k] = a[k]\n    } */\n    Object.assign(o, a)\n    o.height.name = 'hello'\n    console.log(o);\n    console.log(a);\n```\n\n## 深拷贝\n\n```js\n    var a = {\n      name: 'zpf',\n      age: 18,\n      height: {\n        name: 'zpf',\n        age: 18\n      },\n      hoppy: [1, 2, 3, 4]\n    }\n    var o = {}\n    // 深拷贝 递归\n    function deepcopy(newobj, oldobj) {\n      for (let i in oldobj) {\n        if (oldobj[i] instanceof Array) {\n          newobj[i] = []\n          deepcopy(newobj[i], oldobj[i])\n        } else if (oldobj[i] instanceof Object) {\n          newobj[i] = {}\n          deepcopy(newobj[i], oldobj[i])\n        } else {\n          newobj[i] = oldobj[i]\n        }\n      }\n    }\n    deepcopy(o, a)\n    o.height.name = 'zzppff'\n    console.log(o);\n    console.log(a);\n```\n\n# 10 let\n\n具有块级作用域的变量\n\n没有变量提升\n\nlet会暂时性死区\n\n```js\n    /* for (let i = 0; i < 3; i++) {\n      console.log(i);\n    }\n    console.log(i);//let具有块级作用域 在全局访问不到 */\n\n\n    /* console.log(b);// undefined\n    console.log(c);// 报错 let 没有变量提升\n    var b = 20\n    let c = 10 */\n\n    /* var a = 10\n    if (true) {\n      console.log(a);\n      let a = 20//一旦出现let 代表这个let a绑定在了整个块级作用域内部，所以前面打印a会报错，因为let a没有变量提升,出现暂时性死区\n    } */\n    var arr = []\n    for (let i = 0; i < 2; i++) {\n      arr[i] = function () {\n        console.log(i);\n      }\n    }\n    arr[0]()//当函数执行时，会访问上一个作用域，这里的上一个作用域其实就是let绑定了的块级作用域，所以此时i为0 如果let改为var 函数执行访问的作用中没有块级作用域 就会在全局作用域下面查找 for执行完毕后i为2 故而此时打印i为2\n```\n\n\n\n# 11 const\n\n有块级作用域的常量\n\n常量的内存地址不可更改\n\n常量必须赋初始值\n\n常量没有变量提升\n\n```js\n    /* const a// 报错 */\n    const arr = [1, 2]\n    arr[0] = 2\n    console.log(arr);// [2,2]\n    arr = [11, 22]\n    console.log(arr);// 报错\n```\n\n# 12 解构赋值\n\n## 数组解构\n\n我们将数组中的值一一取出，然后再一一对应给我们的新变量的过程为数组解构\n\n```js\n    const [a, b, c, d, e] = [1, 2, 3, [1, 2]]\n    console.log(a);// 1\n    console.log(b);// 2\n    console.log(c);// 3\n    console.log(d);// [1,2]\n    console.log(e);// undefined\n```\n\n## 对象解构\n\n我们将对象中的一个个属性取出来，然后再一一赋值给我们的新变量的过程为对象解构\n\n```js\n    const { names, age, height, sex, ss } = { names: 'zpf', age: 21, height: 1.88, sex: '男' }\n    console.log(names);// zpf\n    console.log(age);// 21\n    console.log(height);// 1.88\n    console.log(sex);// 男\n    console.log(ss);// undefined\n```\n\n```js\n    const { names: myname } = { names: 'zpf', age: 21, height: 1.88, sex: '男' }\n    console.log(myname);// zpf\n```\n\n# 13 箭头函数\n\n## 箭头函数书写方式\n\n```js\n    const a = (n1, n2) => n1 + n2// 函数只有一句代码 且代码结果就是函数赴安徽智 括号就可以省略\n    console.log(a(12, 23));\n    const b = n => n// 只有一个参数 括号可以省略\n    console.log(b(5));\n```\n\n## 箭头函数this指向\n\n箭头函数是没有this指向 它的this指向取决于他的函数上下文 也就是箭头函数被定义的作用域下的this指向就是箭头函数的this指向\n\n```js\n    const obj = { name: 'zpf' }\n    function fn() {\n      console.log(this);\n      return () => {\n        console.log(this);\n      }\n    }\n    const fnn = fn.call(obj)// obj\n    fnn()// obj\n```\n\n## 普通函数和箭头函数求任意个参数和\n\n```js\n    /*     function sum() {\n          let total = 0\n          for (let i = 0; i < arguments.length; i++) {\n            total += arguments[i]\n          }\n          console.log(total);\n        }\n        sum(1, 2, 3, 4) */\n\n        \n    const sum = (...args) => {\n      let total = 0\n      args.forEach(item => total += item)\n      console.log(total);\n    }\n    sum(1, 2, 3, 4)\n```\n\n# 14 扩展运算符\n\n可以将数组或者对象转化为逗号分隔的参数序列\n\n```js\n    const arr = [1, 2, 3, 4]\n    console.log(...arr);// 1 2 3 4\n    const arr1 = [1, 2, 3, 4]\n    const arr2 = [4, 5, 6, 7]\n    const arr3 = [...arr1, ...arr2]\n    console.log(arr3);// [1,2,3,4,4,5,6,7]\n    arr1.push(...arr2)\n    console.log(arr1);// [1,2,3,4,4,5,6,7]\n    const b = 'hello'\n    console.log([...b]);//['h','e','l','l','o']\n\n\t\t\nfunction sumRest (...m) {\n    var total = 0; \n    for(var i of m){\n        total += i;\n    }\n    return total;\n}\nconsole.log(sumRest(1,2,3));//6\n\n```\n\n# 15 模板语法\n\n```\n    console.log(`\n    hello\n    zpf\n    i\n    am\n    your\n    `);//模板字符串可以换行\n    const a = 1\n    console.log(`a的值为${a}`);// 模板字符串变量书写形式${}\n    function fn() {\n      return 'aaa'\n    }\n    console.log(`${fn()}`);// 模板字符串能执行函数\n```\n\n# 16 Set 伪数组\n\n一种新的数据结构，类似于数组，里面的值是唯一的，没有重复的值\n\n```js\n    const a = new Set([1, 2, 3, 3, 3, 32, 1])\n    console.log(a);// 自动去重 Set(4) {1, 2, 3, 32}\n    console.log(a.size);// a的元素个数 4\n    a.add(12)// 添加a元素 重复就忽略\n    console.log(a);// Set(5) {1, 2, 3, 32, 12}\n    a.delete(1)// 删除set中的元素'1' \n    console.log(a);// Set(4) {2, 3, 32, 12}\n    const flag = a.has(3)//set中是否有元素'3'\n    console.log(flag);// true\n    a.clear()// 清除所有成员\n    console.log(a);// Set(0)\n\n\t const b = new Set([1, 2, 3, 4, 5])\n    b.forEach(value => {\n      console.log(value);// 1 2 3 4 5换行显示\n    })\n```",
      "id": 40
    },
    {
      "name": "pxTorem+vue2",
      "type": "vue",
      "recommendationIndex": 5,
      "content": "在Vue项目中使用pxToRem可以帮助你将像素单位自动转换为rem单位，从而实现自适应设计。这里是如何在Vue项目中使用pxToRem的步骤：\n# vue2.x\n## 1.安装postcss-pxtorem插件\n首先，你需要安装postcss-pxtorem，这是一个PostCSS插件，用于将px单位转换为rem单位。你可以使用npm来安装它：\n```js\nnpm install postcss-pxtorem --save-dev\n```\n## 2.配置插件\n根据你的Vue项目版本（Vue CLI 2或Vue CLI 3），配置方式会有所不同。以下是在vue.config.js文件中添加配置的示例：\n```js\n// 引入等比适配插件\nconst pxToRem = require('postcss-pxtorem');\n\n// 配置基本大小\nconst postcss = pxToRem({\n  rootValue: 36, // 表示根元素字体大小\n  propList: ['*'], // 可以从px更改为rem的属性, 通配符 * 表示启用所有属性\n  selectorBlackList: ['.norem'] // 过滤掉.norem开头的 class ，不进行rem转换\n});\n\nmodule.exports = {\n  css: {\n    loaderOptions: {\n      postcss: {\n        postcssOptions: {\n          plugins: [postcss]\n        },\n      }\n    }\n  },\n};\n```\n## 3.动态修改rem对应值\n 为了实现自适应，你需要动态地改变html的font-size。你可以创建一个rem.js文件，并在其中设置基本大小和rem函数，然后在main.js中引入它。rem.js是一个用于设置根元素字体大小的脚本，它可以根据不同屏幕尺寸动态调整rem单位的基准值。这有助于实现自适应设计。以下是一个rem.js的示例。\n```js\n// rem.js\n(function (doc, win) {\n  var docEl = doc.documentElement,\n      resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',\n      recalc = function () {\n        var clientWidth = docEl.clientWidth;\n        if (!clientWidth) return;\n        // 这里是将屏幕宽度分成10份，1份就是1rem\n        // 如果设计稿是750px，那么这里可以设置为75\n        // 如果设计稿是640px，可以设置为64\n        // 以此类推\n        docEl.style.fontSize = 100 * (clientWidth / 750) + 'px';\n      };\n\n  if (!doc.addEventListener) return;\n  win.addEventListener(resizeEvt, recalc, false);\n  doc.addEventListener('DOMContentLoaded', recalc, false);\n})(document, window);\n```\n在上面的代码中，我们首先获取了文档的根元素documentElement，然后定义了一个recalc函数来计算和设置根元素的字体大小。这个函数会根据设备的屏幕宽度来动态设置font-size，这里以750px宽的设计稿为例，将屏幕宽度分成750份，每份代表1rem的大小。\n\n然后，我们监听了窗口大小变化的事件（resize事件和orientationchange事件），当这些事件发生时，会调用recalc函数重新计算根元素的字体大小。\n\n最后，当文档加载完成时（DOMContentLoaded事件），也会调用recalc函数来设置初始的根元素字体大小。\n\n这样，无论何时屏幕尺寸发生变化，rem.js都会确保根元素的字体大小相应地调整，从而使得使用rem单位的元素能够根据屏幕尺寸自适应地缩放。\n## 4.使用pxToRem\n在你的CSS中，你可以正常地使用px单位。当你构建项目时，postcss-pxtorem插件会自动将px单位转换为rem单位。\n- **原理**：pxToRem的工作原理是通过配置一个remUnit，在打包过程中把所有的px单位通过换算转换为rem单位。再配置html下的font-size，进而设置rem的值，达到自适应当前尺寸。\n- **优点**\n1. **自动化**：自动将px转换为rem，简化了手动计算的过程。\n2. **灵活性**：通过调整根元素的font-size，可以轻松地对整个网站的布局和字体大小进行全局性的调整。\n- **缺点**\n1. **兼容性问题**：在一些旧的浏览器中可能不支持rem单位。\n2. **控制精度**：通过调整根元素的font-size，可以轻松地对整个网站的布局和字体大小进行全局性的调整。可能需要额外的配置来确保转换的精度，特别是在复杂的设计中。\n使用pxToRem可以帮助你更容易地实现自适应设计，但是它并不是完美的解决方案。你可能需要根据项目的具体需求来调整配置，以达到最佳的自适应效果\n# vue3.x\n在Vue 3项目中使用`pxToRem`功能，你可以通过以下步骤来实现`px`到`rem`的自动转换：\n\n## 1. **安装`postcss-pxtorem`插件**:\n   ```bash\n   npm install postcss-pxtorem --save-dev\n   ```\n\n## 2. **配置`postcss.config.js`**:\n   在项目根目录下创建或编辑`postcss.config.js`文件，添加`postcss-pxtorem`插件的配置：\n   ```javascript\n   // postcss.config.js\n   module.exports = {\n     plugins: {\n       'postcss-pxtorem': {\n         rootValue: 16, // 设计稿的基准大小，通常是设计稿宽度的1/10\n         propList: ['*'], // 可以从px更改为rem的属性\n         selectorBlackList: ['.norem'] // 过滤掉.norem开头的class，不进行rem转换\n       }\n     }\n   };\n   ```\n\n## 3. **在Vue组件中使用px单位**:\n   在你的Vue组件的`<style>`标签中正常使用`px`单位。当你构建项目时，`postcss-pxtorem`插件会自动将`px`单位转换为`rem`单位。\n\n## 4. **动态设置根元素字体大小**:\n   你可以创建一个`rem.js`文件来动态设置根元素的字体大小，以适应不同屏幕尺寸：\n   ```javascript\n   // rem.js\n   (function(doc, win) {\n     var docEl = doc.documentElement,\n         resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',\n         recalc = function() {\n           var clientWidth = docEl.clientWidth;\n           if (!clientWidth) return;\n           docEl.style.fontSize = 100 * (clientWidth / 1920) + 'px';\n         };\n     if (!doc.addEventListener) return;\n     win.addEventListener(resizeEvt, recalc, false);\n     doc.addEventListener('DOMContentLoaded', recalc, false);\n   })(document, window);\n   ```\n\n## 5. **引入`rem.js`到主文件**:\n   在你的入口文件（通常是`main.js`或`main.ts`）中，导入`rem.js`文件：\n   ```javascript\n   // main.js 或 main.ts\n   import './path/to/rem.js'; // 确保路径正确\n   ```\n\n通过以上步骤，你可以在Vue 3项目中实现`px`到`rem`的自动转换，从而更容易地创建自适应的网页布局。请确保在`postcss-pxtorem`的配置中设置正确的`rootValue`，以匹配你的设计稿和`rem.js`中的设置。",
      "id": 41
    }
  ],
  "vue": [
    {
      "name": "vue",
      "svg": "vue",
      "id": 0,
      "urlList": [
        {
          "name": "vue2",
          "svg": "vue",
          "id": 0,
          "url": "https://v2.cn.vuejs.org/v2/guide/"
        },
        {
          "name": "router(vue2)",
          "svg": "router",
          "url": "https://v3.router.vuejs.org/zh/installation.html"
        },
        {
          "name": "vuex",
          "svg": "vuex",
          "url": "https://v3.vuex.vuejs.org/zh/"
        },
        {
          "name": "vue3",
          "svg": "vue3",
          "url": "https://cn.vuejs.org/guide/introduction.html"
        },
        {
          "name": "router(vue3)",
          "svg": "router3",
          "url": "https://router.vuejs.org/zh/introduction.html"
        },
        {
          "name": "pinia",
          "svg": "vuex3",
          "url": "https://pinia.vuejs.org/zh/introduction.html"
        }
      ]
    }
  ],
  "ui": [
    {
      "name": "ui",
      "svg": "UI",
      "id": 1,
      "urlList": [
        {
          "name": "ElementUI(vue2)",
          "svg": "elementui",
          "url": "https://element.eleme.cn/#/zh-CN/component/installation"
        },
        {
          "name": "ElementUI(vue3)",
          "svg": "elementui",
          "url": "https://element-plus.org/zh-CN/component/overview.html"
        },
        {
          "name": "iView",
          "svg": "iview",
          "url": "http://v4.iviewui.com/docs/introduce"
        },
        {
          "name": "Ant Design Vue",
          "svg": "antd",
          "url": "https://www.antdv.com/components/overview-cn"
        },
        {
          "name": "DataV",
          "svg": "datav",
          "url": "http://datav.jiaminghi.com/guide/"
        },
        {
          "name": "fast-dataview-ui(vue3)",
          "svg": "fast-dataview-ui",
          "url": "https://aafx11.github.io/fast-dataview-ui/components/scrollTable.html"
        }
      ]
    }
  ],
  "time": [
    {
      "name": "时间",
      "svg": "times",
      "id": 2,
      "urlList": [
        {
          "name": "moment",
          "svg": "moment",
          "url": "http://momentjs.cn/docs/"
        },
        {
          "name": "dayjs",
          "svg": "times",
          "url": "https://dayjs.gitee.io/docs/zh-CN/installation/installation"
        }
      ]
    }
  ],
  "js": [
    {
      "name": "js",
      "svg": "js",
      "id": 3,
      "urlList": [
        {
          "name": "ES6",
          "svg": "ES6",
          "url": "https://es6.ruanyifeng.com/"
        },
        {
          "name": "lodash",
          "svg": "lodash",
          "url": "https://www.lodashjs.com/"
        }
      ]
    }
  ],
  "img": [
    {
      "name": "图标网站",
      "svg": "icon",
      "id": 4,
      "urlList": [
        {
          "name": "阿里巴巴图标库",
          "svg": "alibaba",
          "url": "https://www.iconfont.cn/"
        }
      ]
    }
  ],
  "http": [
    {
      "name": "http",
      "svg": "http",
      "id": 5,
      "urlList": [
        {
          "name": "axios",
          "svg": "axios",
          "url": "https://www.axios-http.cn/docs/intro"
        }
      ]
    }
  ],
  "echarts": [
    {
      "name": "可视化组件库",
      "svg": "可视化",
      "id": 6,
      "urlList": [
        {
          "name": "echart官网",
          "svg": "echart",
          "url": "https://echarts.apache.org/zh/index.html"
        },
        {
          "name": "MCChart",
          "svg": "MCChart",
          "url": "http://echarts.zhangmuchen.top/#/index"
        },
        {
          "name": "chartLib",
          "svg": "chartLib",
          "url": "http://chartlib.datains.cn"
        },
        {
          "name": "ppchart",
          "svg": "ppchart",
          "url": "https://ppchart.com/#/"
        },
        {
          "name": "v-chart2",
          "svg": "v-chart2",
          "url": "https://denaro-org.github.io/v-charts2/charts/"
        }
      ]
    }
  ],
  "other": [
    {
      "name": "框架",
      "svg": "框架",
      "urlList": [
        {
          "name": "若依",
          "svg": "ruoyi",
          "url": "https://doc.ruoyi.vip/ruoyi/"
        }
      ]
    },
    {
      "name": "人工智能",
      "svg": "ai",
      "id": 7,
      "urlList": [
        {
          "name": "chatgpt",
          "svg": "chatgpt",
          "url": "https://chat.openai.com/"
        },
        {
          "name": "bingChat",
          "svg": "bingChat",
          "url": "https://www.bing.com/search?q=Bing+AI&showconv=1&FORM=hpcodx"
        },
        {
          "name": "bard",
          "svg": "bard",
          "url": "https://bard.google.com/chat"
        },
        {
          "name": "文心一言",
          "svg": "文心一言",
          "url": "https://yiyan.baidu.com/"
        },
        {
          "name": "讯飞星火",
          "svg": "讯飞星火",
          "url": "https://xinghuo.xfyun.cn/desk"
        },
        {
          "name": "通义千问",
          "svg": "通义千问",
          "url": "https://tongyi.aliyun.com/qianwen/"
        },
        {
          "name": "kimi",
          "svg": "kimi",
          "url": "https://kimi.moonshot.cn/chat/co6eskqlnl9054hogulg"
        }
      ]
    },
    {
      "name": "实用网站",
      "svg": "usefulURLs",
      "urlList": [
        {
          "name": "奶牛快传",
          "svg": "nnkc",
          "url": "https://cowtransfer.com/"
        },
        {
          "name": "ip查询",
          "svg": "ip",
          "url": "https://tool.lu/ip/"
        },
        {
          "name": "百度翻译",
          "svg": "bdfy",
          "url": "http://fanyi.baidu.com/"
        },
        {
          "name": "GitHub",
          "svg": "Github",
          "url": "https://github.com/"
        },
        {
          "name": "Vue example",
          "svg": "vueEx",
          "url": "https://vuejsexamples.com/"
        },
        {
          "name": "elementui生成器",
          "svg": "createElementui",
          "url": "https://mrhj.gitee.io/form-generator/#/"
        },
        {
          "name": "vue-element-admin",
          "svg": "vue-element-admin",
          "url": "https://panjiachen.github.io/vue-element-admin-site/zh/guide/"
        }
      ]
    },
    {
      "name": "vpn",
      "svg": "vpn",
      "urlList": [
        {
          "name": "iKun",
          "svg": "ikun",
          "url": "https://ikuuu.me/user#"
        },
        {
          "name": "一元机场",
          "svg": "一元机场",
          "url": "https://xn--4gq62f52gdss.com/#/dashboard"
        }
      ]
    }
  ]
}
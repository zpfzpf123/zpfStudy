export default {
  note: [
    {
      'id': 1,
      'name': 'vuex',
      'type': 'vue',
      'recommendationIndex': 5,
      'content': '## Vuex\n\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。\n\n调试工具：vue devtools\n\n> Vuex就像眼镜：您自会知道什么时候需要它。\n\n### 1、state\n\n在store中定义数据，在组件中直接使用：\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    getters: {},\n    mutations: {},\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Home.vue`\n\n```html\n<template>\n  <div class="home">\n    <h2>Home页面的数字：{{$store.state.num}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  \n}\n</script>\n```\n\n或者写为：\n\n```html\n<template>\n  <div class="about">\n    <h2>About页面的数字：{{num}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    num(){\n      return this.$store.state.num\n    }\n  }\n}\n</script>\n```\n\n### 2、getters\n\n将组件中统一使用的computed都放到getters里面来操作\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    mutations: {},\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Home.vue`\n\n```html\n<template>\n  <div class="home">\n    <h2>Home页面的数字：{{$store.getters.getNum}}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  \n}\n</script>\n```\n\n### 3、mutations\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。\n\n目录：`store/index.js`\n\n```js\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios）\n    mutations: {\n        // 让num累加\n        // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n        increase(state, payload){\n            state.num += payload ? payload : 1;\n        }\n    },\n    actions: {},\n    modules: {}\n})\n```\n\n目录：`Btn.vue`\n\n```html\n<template>\n    <div>\n        <button @click="$store.commit(\'increase\', 2)">点击加1</button>\n    </div>\n</template>\n<script>\nexport default {\n   methods: {\n       /* addFn(){\n           // 调用store中的mutations里的increase方法\n           // 传参的话，使用payload\n           this.$store.commit(\'increase\', 2)\n       } */\n   }\n}\n</script>\n```\n\n### 4、actions\n\nactions是store中专门用来处理异步的，实际修改状态值的，还是mutations\n\n目录：`store/index.js`\n\n```js\n// 在store(仓库)下的index.js这份文件，就是用来做状态管理\nimport Vue from \'vue\'\nimport Vuex from \'vuex\'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    // state相当于组件中的data，专门用来存放全局的数据\n    state: {\n        num: 0\n    },\n    // getters相当于组件中的computed，getters是全局的，computed是组件内部使用的\n    getters: {\n        getNum(state) {\n            return state.num\n        }\n    },\n    // mutations相当于组件中的methods，但是它不能使用异步方法（定时器、axios）\n    mutations: {\n        // 让num累加\n        // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n        increase(state, payload){\n            state.num += payload ? payload : 1;\n        },\n        // 让num累减\n        decrease(state){\n            state.num--;\n        }\n    },\n    // actions专门用来处理异步，实际修改状态值的，依然是mutations\n    actions: {\n        // 点击了“减1”按钮后，放慢一秒再执行减法\n        decreaseAsync(context){\n            context.commit(\'decrease\')\n        }\n    },\n    modules: {}\n})\n\n```\n\n目录：`Btn.vue`\n\n```html\n<template>\n    <div>\n        <button @click="$store.commit(\'increase\', 2)">点击加1</button>\n        <button @click="$store.dispatch(\'decreaseAsync\')">点击延迟减1</button>\n    </div>\n</template>\n<script>\nexport default {\n   methods: {\n       /* addFn(){\n           // 调用store中的mutations里的increase方法\n           // 传参的话，使用payload\n           this.$store.commit(\'increase\', 2)\n       }\n       reduceFn(){\n           this.$store.dispatch(\'decreaseAsync\')\n       } */\n   }\n}\n</script>\n```\n\n### 5、辅助函数\n\nmapState和mapGetters在组件中都是写在computed里面\n\n```html\n<template>\n\t<div>\n        <h2>Home页面的数字：{{num}}</h2>\n        <h2>About页面的数字：{{getNum}}</h2>\n    </div>\n</template>\n\n<script>\nimport { mapState, mapGetters } from \'vuex\'\n\nexport default {\n  computed: {\n    ...mapState([\'num\'])\n    ...mapGetters([\'getNum\'])\n  }\n}\n</script>\n```\n\nmapMutations和mapActions在组件中都是写在methods里面\n\n```html\n<template>\n\t<div>\n        <button @click="increase(2)">点击加1</button>\n        <button @click="decreaseAsync()">点击延迟减1</button>\n    </div>\n</template>\n\n<script>\nimport { mapMutations, mapActions } from \'vuex\'\n\nexport default {\n  methods: {\n       ...mapMutations([\'increase\']),\n       ...mapActions([\'decreaseAsync\'])\n   }\n}\n</script>\n```\n\n### 6、拆分写法\n\nstore中的所有属性，都可以拆分成单独的js文件来书写\n\n### 7、modules\n\n![](.\\1111.png)我们的store可以认为是一个主模块，它下边可以分解为很多子模块，子模块都可以单独领出来写，写完再导入到主模块中。下面以 `users` 子模块举例：\n\n将mutations中所有的方法，归纳起来。\n\n目录：`mutations_type.js`\n\n```js\nexport const MUTATIONS_TYPE = {\n    INCREASE: \'increase\',\n    DECREASE: \'decrease\'\n}\n\nexport default {\n    // 让num累加\n    // payload是一个形参，如果组件在commit时，有传这个参数过来，就存在，如果没有传过来，就是undefined\n    [MUTATIONS_TYPE.INCREASE](state, payload){\n        state.num += payload ? payload : 1;\n    },\n    // 让num累减\n    [MUTATIONS_TYPE.DECREASE](state){\n        state.num--;\n    }\n}\n```\n\n目录：`store/index.js`\n\n```js\nimport mutations from \'./mutaions_type\'\n\nexport default new Vuex.Store({\n    ...\n    mutations,\n    ...\n})\n```\n\n组件中：\n\n```html\n<template>\n  <div class="about">\n    <h2>About页面的数字：{{getNum}}</h2>\n    <button @click="increase()">About的按钮，点击加1</button>\n  </div>\n</template>\n<script>\nimport { mapGetters, mapMutations } from \'vuex\'\nimport { MUTATIONS_TYPE } from \'@/store/mutaions_type.js\'\nexport default {\n  computed: {\n    ...mapGetters([\'getNum\'])\n  },\n  methods: {\n    // 方法一：\n    ...mapMutations([MUTATIONS_TYPE.INCREASE])\n      \n    // 方法二：\n    /* increase(){\n      this.$store.commit(MUTATIONS_TYPE.INCREASE)\n    } */\n  }\n}\n</script>\n\n```\n\n\n\n'
    },
    {
      'id': 2,
      'name': 'vue大屏动态配置组件数量、每个组件的占比和位置代码示例',
      'type': 'vue',
      'recommendationIndex': 4,
      'content': '以下是使用Vue.js创建一个大屏组件，并且可以通过传递props来配置组件数量、每个组件的占比和位置的代码示例：\n\n```js\n<template>\n  <div class="big-screen">\n    <div v-for="(item, index) in screenList" :key="index" :style="getStyle(item)">\n      <slot :name="item.name"></slot>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'BigScreen\',\n  props: {\n    screenList: {\n      type: Array,\n      required: true,\n      default: () => []\n    }\n  },\n  methods: {\n    getStyle(item) {\n      return {\n        position: \'absolute\',\n        left: `${item.left}%`,\n        top: `${item.top}%`,\n        width: `${item.width}%`,\n        height: `${item.height}%`\n      }\n    }\n  }\n}\n</script>\n\n<style>\n.big-screen {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n</style>\n```\n\n在这个示例中，我们定义了一个名为`BigScreen`的组件，并且传递了一个名为`screenList`的props，它是一个数组，用来指定大屏组件的个数、占比和位置。\n\n在组件的模板中，我们使用了`v-for`来遍历`screenList`数组，并为每个大屏组件指定样式（位置和大小），然后使用插槽来插入具体的大屏组件内容。\n\n在组件的方法中，我们定义了一个名为`getStyle`的方法，它接受一个参数`item`，并返回一个包含位置和大小信息的样式对象，这个样式对象会被应用到每个大屏组件的容器元素上。\n\n现在让我们看一个如何使用这个`BigScreen`组件的示例：\n\n```js\n<template>\n  <div style="height:100%">\n    <big-screen :screen-list="screenList">\n      <template #screen1>\n        <div>第一个大屏内容</div>\n      </template>\n      <template #screen2>\n        <div>第二个大屏内容</div>\n      </template>\n    </big-screen>\n  </div>\n</template>\n\n<script>\nimport BigScreen from \'./BigScreen.vue\'\n\nexport default {\n  name: \'App\',\n  components: {\n    BigScreen\n  },\n  data() {\n    return {\n      screenList: [\n        { name: \'screen1\', left: 0, top: 0, width: 50, height: 100 },\n        { name: \'screen2\', left: 50, top: 0, width: 50, height: 100 }\n      ]\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，我们在父组件中使用了`BigScreen`组件，并且传递了一个名为`screenList`的props，它包含了两个元素，分别代表了两个大屏组件的位置、大小和内容名称。\n\n我们也定义了两个插槽（`#screen1`和`#screen2`），它们分别对应了`screenList`数组中的两个元素，表示在第一个大屏和第二个大屏'
    },
    {
      'id': 3,
      'type': 'vue',
      'recommendationIndex': 3,
      'name': 'vue2+原生js实现上下无缝滚动，鼠标移入停止无缝滚动，可以鼠标滚轮控制滚动，鼠标移出可以继续上下无缝滚动',
      'content': '```js\n<template>\n  <div class="scroll-container" @mouseenter="stopScroll" @mouseleave="startScroll" @wheel="onWheel">\n    <div class="scroll-content">\n      <div class="scroll-item" v-for="item in scrollData" :key="item">{{ item }}</div>\n      <div class="scroll-item" v-for="item in scrollData" :key="item">{{ item }}</div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'SeamlessScroll\',\n  data() {\n    return {\n      scrollData: [\'Item 1\', \'Item 2\', \'Item 3\', \'Item 4\', \'Item 5\'],\n      scrollInterval: null,\n      scrollSpeed: 1,\n    }\n  },\n  mounted() {\n    this.startScroll();\n  },\n  beforeDestroy() {\n    clearInterval(this.scrollInterval);\n  },\n  methods: {\n    startScroll() {\n      this.scrollInterval = setInterval(() => {\n        if (this.$el.scrollTop >= this.$el.scrollHeight / 2) {\n          this.$el.scrollTop = 0;\n        } else {\n          this.$el.scrollTop += this.scrollSpeed;\n        }\n      }, 10);\n    },\n    stopScroll() {\n      clearInterval(this.scrollInterval);\n    },\n    onWheel(event) {\n      event.preventDefault();\n      this.$el.scrollTop += event.deltaY;\n    },\n  },\n}\n</script>\n\n<style scoped>\n.scroll-container {\n  height: 200px;\n  overflow: hidden;\n}\n.scroll-content {\n  display: flex;\n  flex-direction: column;\n}\n.scroll-item {\n  height: 50px;\n}\n</style>\n```\n\n'
    },
    {
      'id': 4,
      'type': 'vue',
      'recommendationIndex': 4,
      'name': 'vue2+Datav实现表格上下无缝滚动',
      'content': '1. 首先需要在vue引入DataV组件 \n   ```js\n   npm install @jiaminghi/data-view\n   ```\n\n   \n\n2. 在main.js注册为全局组件\n   ```js\n   // 将自动注册所有组件为全局组件\n   import dataV from \'@jiaminghi/data-view\'\n   \n   Vue.use(dataV)\n   ```\n\n3. 使用vue文件代码如下\n   ```vue\n   <template>\n     <div id="the-homework-table">\n       <dv-scroll-board\n         :config="config"\n         style="width: 100%; height: 100%"\n       />\n     </div>\n   </template>\n   \n   <script>\n   export default {\n     data() {\n       return {\n         config: {\n           header: [\n             "时间",\n           ],\n           data: [\n             [\n               "2022/11/3 07:45:30",\n             ],\n            [\n               "2022/11/3 07:45:30",\n             ],\n             [\n               "2022/11/3 07:45:30",\n             ],\n             [\n               "2022/11/3 07:45:30",\n             ],\n             [\n               "2022/11/3 07:45:30",\n             ],\n             [\n               "2022/11/3 07:45:30",\n             ],\n             [\n               "2022/11/3 07:45:30",\n             ],\n             [\n               "2022/11/3 07:45:30",\n             ],\n             [\n               "2022/11/3 07:45:30",\n             ],\n             [\n               "2022/11/3 07:45:30",\n             ],\n             [\n               "2022/11/3 07:45:30",\n             ],\n           ],\n           index: true,//增加序号显示\n           rowNum: 10,//超过10行启动无缝滚动\n         },\n       };\n     },\n   };\n   </script>\n   \n   <style lang="less" scoped>\n   #the-homework-table {\n     width: 100%;\n     height: 100%;\n   }\n   /deep/ .dv-scroll-board .header {\n     font-size: 25px;\n   }\n   /deep/ .dv-scroll-board .rows .row-item {\n     font-size: 24px;\n   }\n   /deep/ .dv-scroll-board .rows .ceil {\n     text-align: center;\n   }\n   /deep/ .dv-scroll-board .header .header-item {\n     text-align: center;\n   }\n   </style>\n   ```\n\n   '
    },
    {
      'id': 5,
      'type': 'vue',
      'recommendationIndex': 5,
      'name': 'vue2+echarts封装组件  饼图组件',
      'content': '```js\n<template>\n  <div ref="chart" :style="{ height: \'100%\', width: \'100%\' }"></div>\n</template>\n\n<script>\nimport echarts from "echarts";\n\nexport default {\n  props: {\n    // 接受数据作为 props\n    data: {\n      type: Array,\n      required: true,\n    },\n    // 接受颜色作为 props\n    colors: {\n      type: Array,\n      default() {\n        return ["#00BFFF", "#FF6B00"];\n      },\n    },\n    //标题\n    chartTitle: {\n      type: String,\n      default:\'\'\n    },\n    // 是否显示标签\n    showLabel: {\n      type: Boolean,\n      default: true,\n    },\n    // 标签位置\n    labelPosition: {\n      type: String,\n      default: "inside",\n    },\n    // 标签字体大小\n    labelFontSize: {\n      type: Number,\n      default: 14,\n    },\n    // 是否自适应\n    responsive: {\n      type: Boolean,\n      default: true,\n    },\n    // series 名称\n    seriesName: {\n      type: String,\n      required: true,\n    },\n    // 是否显示图例\n    showLegend: {\n      type: Boolean,\n      default: false,\n    },\n    // 图例位置\n    legendPosition: {\n      type: String,\n      default: "right",\n    },\n  },\n  data() {\n    return {\n      // 设置初始高度\n      chartHeight: "300px",\n    };\n  },\n  mounted() {\n    // 渲染图表\n    this.renderChart();\n    // 如果需要自适应，则监听窗口大小变化\n    if (this.responsive) {\n      window.addEventListener("resize", this.renderChart);\n    }\n  },\n  beforeDestroy() {\n    // 如果需要自适应，则在组件销毁前移除监听器\n    if (this.responsive) {\n      window.removeEventListener("resize", this.renderChart);\n    }\n  },\n  methods: {\n    renderChart() {\n      // 初始化 echarts 实例\n      const chart = echarts.init(this.$refs.chart);\n      // 设置图表选项\n      chart.setOption({\n        title: {\n          text: this.chartTitle,\n          left: "center",\n          textStyle: {\n            fontSize: 20,\n            color:\'white\'\n          },\n        },\n        // 配置提示框\n        tooltip: {\n          trigger: "item",\n          formatter: "{a} <br/>{b}: {c} ({d}%)",\n        },\n        // 配置图例\n        legend: {\n          show: this.showLegend,\n          orient: this.legendPosition,\n        },\n        // 配置 series\n        series: [\n          {\n            // 设置 series 名称\n            name: this.seriesName,\n            // 设置 series 类型为饼状图\n            type: "pie",\n            // 设置饼状图半径\n            radius: ["50%", "70%"],\n            // 避免标签重叠\n            avoidLabelOverlap: false,\n            // 配置标签\n            label: {\n              show: this.showLabel,\n              position: this.labelPosition,\n              fontSize: this.labelFontSize,\n            },\n            // 配置标签强调样式\n            emphasis: {\n              label: {\n                show: true,\n                fontSize: this.labelFontSize + 2,\n                fontWeight: "bold",\n              },\n            },\n            // 配置标签线\n            labelLine: {\n              show: false,\n            },\n            // 配置数据\n            data: this.data.map((item, index) => ({\n              value: item.val,\n              name: item.name,\n              itemStyle: {\n                color: this.colors[index],\n              },\n            })),\n          },\n        ],\n      });\n      // 如果需要自适应，则在渲染后调整图表大小\n      if (this.responsive) {\n        chart.resize();\n      }\n    },\n  },\n};\n</script>\n\n<style>\n/* 可选的图表容器样式 */\n</style>\n```\n\n# 组件使用示例\n\n```js\n<pie-chart\n            :data="chartData"\n            :colors="chartColors"\n            :show-label="showLabel"\n            :label-position="labelPosition"\n            :label-font-size="labelFontSize"\n            :responsive="true"\n            series-name="作业统计"\n            chartTitle="作业统计"\n          />\n  \ndata() {\n    return {\n      chartData: [\n        {name:\'已完成\',val:10},\n        {name:\'未完成\',val:20},\n      ],\n      chartColors: [\'#00BFFF\',\'#FF6B00\'],\n      showLabel: true,\n      labelPosition: \'inside\',\n      labelFontSize: 25,\n    }\n  },\n```\n\n'
    },
    {
      'id': 6,
      'type': 'vue',
      'recommendationIndex': 5,
      'name': 'vue2+echarts封装组件  柱状图组件',
      'content': '```js\n<template>\n  <div ref="chart" style="width: 100%; height: 100%"></div>\n</template>\n\n<script>\nimport echarts from "echarts";\n\nexport default {\n  props: {\n    //颜色\n    colorList: {\n      type: Array,\n      default: () => {\n        return ["#00BFFF", "#FF6B00"];\n      },\n    },\n    // 图表标题\n    title: {\n      type: String,\n      required: true,\n    },\n    // x 轴数据\n    xAxisData: {\n      type: Array,\n      required: true,\n    },\n    // 数据系列\n    seriesData: {\n      type: Array,\n      required: true,\n    },\n    // 图例数据\n    legendData: {\n      type: Array,\n      required: true,\n    },\n    // tooltip 的 crossStyle\n    crossStyle: {\n      type: Object,\n      default: () => {\n        return {\n          color: "white",\n        };\n      },\n    },\n    /**\n     * @description:  字体大小列表，依次为：\n    0. 标题字体大小\n     1. 图例字体大小\n    2. x 轴标签字体大小\n     3. y 轴标签字体大小\n     4. 数据标签字体大小\n     5. tooltip 字体大小\n     * @return {*}\n     */\n    fontSizeList: {\n      type: Array,\n      required: true,\n    },\n  },\n  data() {\n    return {\n      chart: null,\n    };\n  },\n  mounted() {\n    // 初始化 echarts 实例\n    this.chart = echarts.init(this.$refs.chart);\n    // 设置图表配置项\n    this.chart.setOption({\n      color:this.colorList,\n      // 图表标题\n      title: {\n        text: this.title,\n        textStyle: {\n          color: "#fff",\n          fontSize: this.fontSizeList[0],\n        },\n      },\n      // tooltip\n      tooltip: {\n        trigger: "axis",\n        axisPointer: {\n          type: "cross",\n          crossStyle: this.crossStyle,\n        },\n        textStyle: {\n          fontSize: this.fontSizeList[5],\n        },\n      },\n      // 图例\n      legend: {\n        data: this.legendData,\n        textStyle: {\n          color: "#fff",\n          fontSize: this.fontSizeList[1],\n        },\n      },\n      // x 轴\n      xAxis: [\n        {\n          type: "category",\n          data: this.xAxisData,\n          axisPointer: {\n            type: "shadow",\n          },\n          axisLabel: {\n            textStyle: {\n              color: "#fff",\n              fontSize: this.fontSizeList[2],\n            },\n          },\n          // 去掉 x 轴的分割线\n          splitLine: {\n            show: false,\n          },\n        },\n      ],\n      // y 轴\n      yAxis: [\n        {\n          type: "value",\n          axisLabel: {\n            textStyle: {\n              color: "#fff",\n              fontSize: this.fontSizeList[3],\n            },\n          },\n          // 去掉 y 轴的分割线\n          splitLine: {\n            show: false,\n          },\n        },\n      ],\n      // 数据系列\n      series: this.seriesData.map((item) => {\n        return {\n          name: item.name,\n          type: "bar",\n          data: item.data,\n          label: {\n            show: this.showLabel,\n            position: this.labelPosition,\n            fontSize: this.fontSizeList[4],\n          },\n        };\n      }),\n    });\n    // 监听窗口大小变化，自适应图表大小\n    window.addEventListener("resize", () => {\n      this.chart.resize();\n    });\n  },\n};\n</script>\n```\n\n# 组件使用示例\n\n```js\n<bar-chart\n            :title="chartTitle"\n            :x-axis-data="xAxisData"\n            :series-data="seriesData"\n            :legend-data="legendData"\n            :cross-style="crossStyle"\n            :font-size-list="fontSizeList"\n          />\n  \ndata() {\n    return {\n      title: "人员管理",\n      chartTitle: "人员统计",\n      xAxisData: ["A", "B", "C", "D", "E"],\n      seriesData: [\n        {\n          name: "员工数量",\n          data: [10, 20, 30, 40, 50],\n        },\n        {\n          name: "访客数量",\n          data: [20, 30, 40, 50, 60],\n        },\n      ],\n      legendData: ["员工数量", "访客数量"],\n      crossStyle: {\n        color: "white",\n      },\n      fontSizeList: [18, 20, 20, 20, 20, 20],\n    };\n  },\n```\n\n'
    },
    {
      'id': 7,
      'type': 'vue',
      'recommendationIndex': 5,
      'name': 'vue2播放flv视频流',
      'content': '# 下载flv.js\n\n```js\nnpm install --save flv.js\n```\n\n# 代码示例\n\n```js\n<template>\n  <div>\n\t<video id="videoElement" controls autoplay muted width="300px" height="200px">    \n    </video>\n\t<button @click="play">播放</button>\n  </div>\n</template>\n<script>\n    import flvjs from \'flv.js\'\nexport default {\n  data () {\n    return {\n\t  flvPlayer:null\n    }\n  },\n   mounted() {\n      if (flvjs.isSupported()) {\n        var videoElement = document.getElementById(\'videoElement\');\n        this.flvPlayer = flvjs.createPlayer({\n          type: \'flv\',\n\t\t  isLive: true,\n\t\t  hasAudio: false,\n          url: \'http://1011.hlsplay.aodianyun.com/demo/game.flv\'\n        });\n        this.flvPlayer.attachMediaElement(videoElement);\n        this.flvPlayer.load();\n\t\tthis.flvPlayer.play();\n      }\n    },\n    methods:{\n      play () {\n        this.flvPlayer.play();\n      }\n    }\n}\n</script>\n\n```\n\n'
    },
    {
      'id': 8,
      'type': 'vue',
      'recommendationIndex': 5,
      'name': 'vue+nginx部署',
      'content': '# vue\n\nvue.config.js配置如下\n\n```js\nconst {defineConfig} = require(\'@vue/cli-service\')\nmodule.exports = defineConfig({\n    transpileDependencies: true,\n    //打包\n    publicPath: \'./\',\n    devServer: {\n        host: \'0.0.0.0\',\n        port: 8080,\n        proxy: {\n            \'/captures\': {\n                target: \'http://192.168.1.150:18080\', // 目标路径，别忘了加http和端口号 也就是接口的前面的ip地址端口号\n                changeOrigin: true, // 是否跨域\n            }\n        }\n    }\n})\n \n```\n\n# nginx\n\nnginx.conf配置如下\n\n```json\n\nuser  root;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n    #                  \'$status $body_bytes_sent "$http_referer" \'\n    #                  \'"$http_user_agent" "$http_x_forwarded_for"\';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n    \t# 服务器端口号\n        listen       80; \n    \t# 服务器名称\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n        location / {\n            root    /zckx/nginx/html/dist; #项目文件位置\n            index  index.html;\n            try_files $uri $uri/ /index.html;\n        }\n\t\t# 配置跨域 比如接口以/captures开头的配置如下\n        location /captures/ {\n            # 允许http://192.168.1.150:18080跨域 http://192.168.1.150:18080为接口地址\n            proxy_pass http://192.168.1.150:18080; \n        }\n\n        location /live{\n            add_header Access-Control-Allow-Origin *;\n            types {\n                application/vnd.apple.mpegurl m3u8;\n                video/mp2t ts;\n            }\n            # HLS切片文件目录\n            alias /tmp/hls;\n            expires -1;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache\'s document root\n        # concurs with nginx\'s one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n\nrtmp {\n        server {\n                listen 1935;\n                chunk_size 4096;\n                # vod path\n                application live {\n                        live on;\n                        hls on;\n                        ##HLS切片保存路径\n                        hls_path /tmp/hls;\n                        hls_fragment 4;\n                        hls_playlist_length 30;\n                        record off;\n                }\n        }\n}\n\n\n\n\n```\n\n'
    },
    {
      'id': 9,
      'type': 'vue',
      'recommendationIndex': 5,
      'name': 'vue二次封装axios',
      'content': '在src创建request文件夹 新建axios.js\n\n```js\nimport axios from \'axios\';\nimport {Message} from \'element-ui\';\n// 统一请求路径前缀\nlet baseApi = "/";\n\n// 超时设定\naxios.defaults.timeout = 20000;\n\naxios.interceptors.request.use(config => {\n    return config;\n}, err => {\n    Message.error(\'请求超时\');\n    return Promise.reject(err);\n});\n\n// http response 拦截器\naxios.interceptors.response.use(response => {\n    return response.data;\n}, (err) => {\n    // 返回状态码不为200时候的错误处理\n    Message.error(err.toString());\n    return Promise.reject(err);\n});\n\nexport const getRequest = (url, params) => {\n    return axios({\n        method: \'get\',\n        url: `${baseApi}${url}`,\n        params: params,\n    });\n};\n\nexport const postRequest = (url, params) => {\n    return axios({\n        method: \'post\',\n        url: `${baseApi}${url}`,\n        data: params,\n    });\n};\n\nexport const putRequest = (url, params) => {\n    return axios({\n        method: \'put\',\n        url: `${baseApi}${url}`,\n        data: params,\n    });\n};\n```\n\n'
    },
    {
      'id': 10,
      'type': 'vue',
      'recommendationIndex': 4,
      'name': 'vue2+mqtt.js封装',
      'content': '这是一个使用 MQTT.js 的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 MQTT.js。\n\n## 安装\n\n首先，你需要在你的项目中安装 MQTT.js。你可以通过 npm 来安装：\n\n```bash\nnpm install mqtt --save\n```\n\n## 封装插件\n\n```js\n// 导入 mqtt 库\nimport * as mqtt from \'mqtt\'\n\nexport default {\n  install(Vue) {\n    // 在 Vue 的原型上添加一个名为 $mqtt 的方法\n    Vue.prototype.$mqtt = (url, topics, option) => {\n      // 设置 MQTT 客户端的选项\n      const options = {\n        reconnectPeriod: 1000, // 如果连接断开，客户端将在1秒后尝试重新连接\n        ...option\n      }\n\n      // 创建一个新的 MQTT 客户端并连接到服务器\n      const client = mqtt.connect(url, options)\n\n      // 当客户端连接到服务器时，打印一条消息并订阅主题\n      client.on(\'connect\', () => {\n        console.log(\'MQTT client connected\')\n        // 订阅主题\n        topics && topics.forEach(topic => client.subscribe(topic))\n      })\n\n      // 当客户端遇到错误时，打印错误消息\n      client.on(\'error\', (error) => {\n        console.error(\'MQTT client encountered an error:\', error)\n      })\n\n      // 当客户端正在尝试重新连接时，打印一条消息\n      client.on(\'reconnect\', () => {\n        console.log(\'MQTT client is attempting to reconnect\')\n      })\n\n      // 返回一个对象，该对象包含一些方法，这些方法可以在 Vue 组件中使用\n      return {\n        // 收到消息时的回调函数\n        message: (callback) => {\n          client.on(\'message\', (topic, message) => {\n            callback(topic, message.toString())\n          })\n        },\n        // 发送消息\n        publish: function(topic, message, callback) {\n          client.publish(topic, message)\n          callback()\n        },\n\n        // 关闭客户端\n        end: callback => {\n          client.end()\n          callback()\n        }\n      }\n    }\n  }\n}\n\n```\n\n\n\n然后，将上述代码保存为 `mqttPlugin.js` 文件，并将其放在你的项目的 `src/plugins` 目录下。\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `$mqtt` 方法来创建一个新的 MQTT 客户端。以下是 `$mqtt` 方法的参数：\n\n- `url`：MQTT 服务器的 URL。\n- `topics`：一个数组，包含你想要订阅的主题。\n- `option`：一个对象，包含 MQTT 客户端的选项。这个对象会和默认选项合并。默认选项包括 `reconnectPeriod: 1000`，表示如果连接断开，客户端将在1秒后尝试重新连接。\n\n`$mqtt` 方法返回一个对象，该对象包含以下方法：\n\n- `message(callback)`：设置一个回调函数，当收到任何主题的消息时，该回调函数会被调用。回调函数接受两个参数，即主题和消息的内容（字符串格式）。\n- `publish(topic, message, callback)`：向指定主题发送一个消息，然后调用回调函数。\n- `end(callback)`：关闭 MQTT 客户端，然后调用回调函数。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `mqttPlugin` 插件的示例：\n\n```javascript\n<template>\n  <div>\n    <button @click="connect">Connect</button>\n    <button @click="sendMessage">Send Message</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      mqttClient: null\n    }\n  },\n  methods: {\n    connect() {\n      this.mqttClient = this.$mqtt(\'mqtt://test.mosquitto.org\', [\'topic1\', \'topic2\'])\n\n      this.mqttClient.message((topic, message) => {\n        console.log(`Received message on ${topic}: ${message}`)\n      })\n    },\n    sendMessage() {\n      this.mqttClient.publish(\'topic1\', \'Hello, MQTT!\', () => {\n        console.log(\'Message sent\')\n      })\n    },\n    disconnect() {\n      this.mqttClient.end(() => {\n        console.log(\'MQTT client disconnected\')\n      })\n    }\n  },\n  beforeDestroy() {\n    // 在组件销毁时关闭 MQTT 客户端\n    this.disconnect()\n  },\n}\n</script>\n```\n\n在这个示例中，当你点击 “Connect” 按钮时，会创建一个新的 MQTT 客户端并连接到服务器。当你点击 “Send Message” 按钮时，会向 `topic1` 发送一个消息。当你离开当前页面路由，会断开 MQTT 客户端的连接。'
    },
    {
      'id': 11,
      'type': 'vue',
      'recommendationIndex': 5,
      'name': 'vue2+elementui二次封装',
      'content': '# 封装el-dialog\n\n这是一个使用 `Dialog` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `Dialog` 组件。\n\n## 代码\n\n```js\n<template>\n  <div id="Dialog">\n    <el-dialog :fullscreen="fullscreen" :center="center" :visible="visible" :width="width" :custom-class="customClass" @open="openDialog"\n               @close="closeDialog"\n    >\n      <template v-slot:title>\n        <slot name="title"/>\n      </template>\n      <template v-slot:default>\n        <slot name="content"/>\n      </template>\n      <template v-slot:footer>\n        <slot name="footer"/>\n      </template>\n    </el-dialog>\n  </div>\n</template>\n<script>\nexport default {\n  name: \'Dialog\',\n  props: {\n    // 是否显示弹框\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    // 弹框标题\n    title: {\n      type: String,\n      default: \'\'\n    },\n    // 弹框宽度\n    width: {\n      type: String,\n      default: \'50%\'\n    },\n    // Dialog 的自定义类名\n    customClass: {\n      type: String,\n      default: \'\'\n    },\n    // 标题是否居中\n    center: {\n      type: Boolean,\n      default: true\n    },\n    // 弹框是否全屏显示\n    fullscreen: {\n      type: Boolean,\n      default: false\n    }\n  },\n  methods: {\n    /**\n     * 打开弹窗回调\n     * */\n    openDialog() {\n      console.log(\'你打开了弹窗\')\n      this.$emit(\'openDialog\')\n    },\n    /**\n     * 关闭弹窗回调\n     * */\n    closeDialog() {\n      this.$emit(\'closeDialog\', false)\n      console.log(\'你关闭了弹窗\')\n    }\n  }\n}\n</script>\n\n<style scoped lang="scss">\n\n</style>\n\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `Dialog` 组件来创建一个新的对话框。以下是 `Dialog` 组件的属性：\n\n- `visible`：是否显示对话框。默认值为 `false`。\n- `title`：对话框的标题。默认值为 `\'\'`。\n- `width`：对话框的宽度。默认值为 `\'50%\'`。\n- `customClass`：对话框的自定义类名。默认值为 `\'\'`。\n- `center`：标题是否居中。默认值为 `true`。\n- `fullscreen`：对话框是否全屏显示。默认值为 `false`。\n\n`Dialog` 组件还包含以下方法：\n\n- `openDialog`：打开对话框时的回调函数。你可以监听 `openDialog` 事件来执行自定义的逻辑。\n- `closeDialog`：关闭对话框时的回调函数。你可以监听 `closeDialog` 事件来执行自定义的逻辑。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `Dialog` 组件的示例：\n\n```js\n<template>\n  <div>\n    <button @click="visible = true">Open Dialog</button>\n    <Dialog :visible="visible" @closeDialog="visible = false">\n      <template v-slot:title>\n        <h2>Dialog Title</h2>\n      </template>\n      <template v-slot:content>\n        <p>Dialog Content</p>\n      </template>\n      <template v-slot:footer>\n        <button @click="visible = false">Close Dialog</button>\n      </template>\n    </Dialog>\n  </div>\n</template>\n\n<script>\nimport Dialog from \'./Dialog\'\n\nexport default {\n  components: {\n    Dialog\n  },\n  data() {\n    return {\n      visible: false\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，当你点击 “Open Dialog” 按钮时，对话框会打开。当你点击 “Close Dialog” 按钮时，对话框会关闭。'
    },
    {
      'id': 12,
      'type': 'vue',
      'recommendationIndex': 4,
      'name': 'vue2+动态表单生成设计(根据后端返回显示对应表单)',
      'content': '这是一个使用 `DynamicForms` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `DynamicForms` 组件。\n\n## 代码\n\n```js\n<template>\n  <div v-if="Object.keys(args).length">\n    <div v-for="(item, index) in dynamicComponentParameters" :key="index">\n      <el-form-item v-if="item.type === \'el-input\'" :label="item.name">\n        <el-input v-model="args[item.val]" />\n      </el-form-item>\n      <el-form-item v-if="item.type === \'el-select\'" :label="item.name">\n        <el-select v-model="args[item.val]" placeholder="请选择算法类型">\n          <el-option\n            v-for="selectVal of item.selectList"\n            :key="selectVal.label"\n            :label="selectVal.label"\n            :value="selectVal.value"\n          />\n        </el-select>\n      </el-form-item>\n      <el-form-item v-if="item.type === \'el-checkbox\'" :label="item.name">\n        <el-checkbox-group v-model="args[item.val]">\n          <el-checkbox\n            v-for="checkVal of item.checkList"\n            :key="checkVal.label"\n            :label="checkVal.label"\n          />\n        </el-checkbox-group>\n      </el-form-item>\n      <el-form-item v-if="item.type === \'el-radio\'" :label="item.name">\n        <el-radio-group v-model="args[item.val]">\n          <el-radio\n            v-for="radioVal of item.radioList"\n            :key="radioVal.label"\n            :label="radioVal.label"\n          />\n        </el-radio-group>\n      </el-form-item>\n      <el-form-item v-if="item.type === \'el-input-number\'" :label="item.name">\n        <el-input-number v-model="args[item.val]" :step="item.step" :min="item.min" :max="item.max" />\n      </el-form-item>\n      <el-form-item v-if="item.type === \'el-switch\'" :label="item.name">\n        <el-switch v-model="args[item.val]" />\n      </el-form-item>\n    </div>\n  </div>\n</template>\n<script>\nimport { Loading } from \'element-ui\'\n\nexport default {\n  name: \'DynamicForms\',\n  props: {\n    // 动态组件列表\n    dynamicComponentParameters: {\n      type: Array,\n      default() {\n        return []\n      }\n    },\n    // 动态组件绑定后传值的参数\n    // eslint-disable-next-line vue/require-default-prop\n    args: {\n      type: Object,\n      default() {\n        return {}\n      }\n    }\n  },\n  data() {\n    return {\n      // 默认参数值\n      defaultValues: {\n        \'string\': \'\',\n        \'number\': 0,\n        \'boolean\': false,\n        \'array\': [],\n        \'object\': {},\n        \'function\': function() {\n        }\n      },\n      // 加载状态\n      loadingInstance: null\n    }\n  },\n  computed: {\n    // 参数默认值列表\n    argList() {\n      // eslint-disable-next-line vue/no-async-in-computed-properties\n      return new Promise((resolve, reject) => {\n        this.loadingInstance = Loading.service({\n          fullscreen: true,\n          text: \'加载中,请稍等....\'\n        })\n        // 模拟接口异步\n        setTimeout(() => {\n          const argList = this.dynamicComponentParameters.map(item => {\n            return {\n              name: item.val,\n              type: item.valType\n            }\n          })\n          resolve(argList)\n        }, 1000)\n      })\n    },\n    // 更新后的ages参数\n    newArgs() {\n      const args = this.args\n      // eslint-disable-next-line vue/no-async-in-computed-properties\n      this.argList.then(res => {\n        res.forEach(list => {\n          console.log(this.defaultValues[list.type])\n          this.$set(args, list.name, this.defaultValues[list.type])\n        })\n        this.loadingInstance.close()\n      })\n      return args\n    }\n  },\n  mounted() {\n    this.init()\n  },\n  methods: {\n    init() {\n      /**\n       * 初始化的时候给动态组件绑定后传值的参数赋默认值\n       * 可根据后端传值的类型和字段赋默认值\n       * */\n      this.$emit(\'update:args\', this.newArgs)\n      console.log(this.args.length)\n    }\n  }\n}\n</script>\n<style scoped lang="scss">\n\n</style>\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `DynamicForms` 组件来创建一个动态表单。以下是 `DynamicForms` 组件的属性：\n\n- `dynamicComponentParameters`：动态组件列表，数组类型，默认值为 `[]`。每个元素是一个对象，包含以下属性：\n  - `type`：组件类型，例如 `\'el-input\'`、`\'el-select\'` 等。\n  - `name`：组件的标签。\n  - `val`：组件的值，将绑定到 `args` 对象的对应属性上。\n  - `selectList`、`checkList`、`radioList`：当组件类型为 `\'el-select\'`、`\'el-checkbox\'` 或 `\'el-radio\'` 时，这些属性包含了选项列表。\n  - `step`、`min`、`max`：当组件类型为 `\'el-input-number\'` 时，这些属性用于设置数字输入框的步长、最小值和最大值。\n\n- `args`：动态组件绑定后传值的参数，对象类型，默认值为 `{}`。对象的每个属性对应一个动态组件，属性名为组件的 `val`，属性值为组件的值。\n\n`DynamicForms` 组件还包含以下方法：\n\n- `init`：初始化的时候给动态组件绑定后传值的参数赋默认值，可根据后端传值的类型和字段赋默认值。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `DynamicForms` 组件的示例：\n\n```js\n<template>\n  <div>\n    <DynamicForms :dynamicComponentParameters="dynamicComponentParameters" :args.sync="args" />\n  </div>\n</template>\n\n<script>\nimport DynamicForms from \'./DynamicForms\'\n\nexport default {\n  components: {\n    DynamicForms\n  },\n  data() {\n    return {\n      dynamicComponentParameters: [\n        { type: \'el-input\', name: \'Input\', val: \'input\' },\n        { type: \'el-select\', name: \'Select\', val: \'select\', selectList: [{ label: \'Option1\', value: \'option1\' }, { label: \'Option2\', value: \'option2\' }] },\n        // 更多的动态组件参数...\n      ],\n      args: {\n        // 动态组件绑定后传值的参数\n      }\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，你需要提供你的动态组件参数列表 `dynamicComponentParameters` 和动态组件绑定后传值的参数 `args`。'
    },
    {
      'id': 13,
      'type': 'vue',
      'recommendationIndex': 4,
      'name': 'vue2播放hls视频流)',
      'content': '这是一个使用 `HLSPlay` 组件的 Vue.js 插件的使用说明文档。该插件允许你在 Vue.js 应用中全局使用 `HLSPlay` 组件。\n\n## 下载\n\n```js\nnpm install vue-video-player@5.0.2\nnpm install videojs-contrib-hls@5.14.1\n```\n\n## 代码\n\n```js\n<template>\n  <section class="HLSPlay-component">\n    <video-player\n      ref="videoPlayer"\n      class="video-player-box"\n      :options="playerOptions"\n      :playsinline="true"\n      custom-event-name="customstatechangedeventname"\n    />\n  </section>\n</template>\n<script>\nimport \'video.js/dist/video-js.css\'\nimport \'videojs-contrib-hls\'\nimport { videoPlayer } from \'vue-video-player\'\n\nexport default {\n  name: \'HLSPlay\',\n  components: {\n    videoPlayer\n  },\n  props: {\n    // eslint-disable-next-line vue/require-default-prop\n    src: {\n      type: String\n    },\n    // eslint-disable-next-line vue/prop-name-casing,vue/require-default-prop\n    cover_url: {\n      type: String\n    }\n  },\n  data() {\n    return {\n      playerOptions: {\n        autoplay: true,\n        muted: true,\n        preload: \'63:25\',\n        language: \'zh-CN\',\n        fluid: true,\n        // playbackRates: [0.7, 1.0, 1.5, 2.0],\n        sources: [\n          {\n            type: \'application/x-mpegURL\',\n            src: this.src // 路径\n            // src: \'https://cdn.theguardian.tv/webM/2015/07/20/150716YesMen_synd_768k_vp8.webm\'\n          }\n        ],\n        poster: this.cover_url, // 你的封面地址\n        notSupportedMessage: \'此视频暂无法播放，请稍后再试\'\n        // controlBar: {\n        //   timeDivider: true,\n        //   durationDisplay: true,\n        //   remainingTimeDisplay: false,\n        //   fullscreenToggle: true, // 全屏按钮\n        //   currentTimeDisplay: true, // 当前时间\n        //   volumeControl: false, // 声音控制键\n        //   playToggle: false, // 暂停和播放键\n        //   // progressControl: true // 进度条\n        // }\n      }\n    }\n  },\n  computed: {\n    player() {\n      return this.$refs.videoPlayer.player\n    }\n  },\n  mounted() {\n    // this.play()\n    // console.log(\'this is current player instance object\', this.player)\n  },\n  beforeDestroy() {\n    this.player && this.player.dispose()\n  },\n  methods: {\n    setSrc(src) {\n      this.player.src({ src: src, type: \'application/x-mpegURL\' })\n    },\n    play() {\n      try {\n        this.$nextTick(() => {\n          this.player.play().then(res => {\n            this.$message(\'获取视频成功\')\n          }).catch(e => {\n            console.log(e, \'失败\')\n          }) // 播放\n        })\n      } catch (e) {\n        console.log(e)\n      }\n      // 手动触发播放\n    }\n  }\n\n}\n</script>\n<style lang="scss" scoped>\n.HLSPlay-component{\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  ::v-deep.video-player-box{\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    #vjs_video_1{\n      height: 100%;\n    }\n   #vjs_video_3 {\n      height: inherit;\n      padding-top: 36.25% !important;\n    }\n  }\n}\n::v-deep.video-player {\n  //.vjs_video_3-dimensions {\n  //  width: 100%;\n  //  height: 96%;\n  //}\n\n  // 初始化，暂停按钮居中\n  .vjs-big-play-button {\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n\n  .video-js .vjs-tech {\n    object-fit: fill;\n    height: 100%;\n  }\n  .vjs-fluid{\n    padding-top: 2vw !important;\n    height: inherit;\n  }\n}\n</style>\n\n\n```\n\n\n\n## 使用\n\n在你的 Vue 组件中，你可以使用 `HLSPlay` 组件来创建一个 HLS 视频播放器。以下是 `HLSPlay` 组件的属性：\n\n- `src`：视频源的 URL，字符串类型。\n- `cover_url`：视频封面的 URL，字符串类型。\n\n`HLSPlay` 组件还包含以下方法：\n\n- `setSrc(src)`：设置新的视频源。\n- `play()`：播放视频。\n\n## 示例\n\n以下是一个如何在 Vue 组件中使用 `HLSPlay` 组件的示例：\n\n```vue\n<template>\n  <div>\n    <HLSPlay :src="videoSrc" :cover_url="coverUrl" ref="hlsPlayer" />\n    <button @click="changeVideo">Change Video</button>\n  </div>\n</template>\n\n<script>\nimport HLSPlay from \'./HLSPlay\'\n\nexport default {\n  components: {\n    HLSPlay\n  },\n  data() {\n    return {\n      videoSrc: \'https://path/to/your/video.m3u8\',\n      coverUrl: \'https://path/to/your/cover.jpg\'\n    }\n  },\n  methods: {\n    changeVideo() {\n      this.videoSrc = \'https://path/to/another/video.m3u8\'\n      this.$refs.hlsPlayer.setSrc(this.videoSrc)\n      this.$refs.hlsPlayer.play()\n    }\n  }\n}\n</script>\n```\n\n在这个示例中，`HLSPlay` 组件用于播放一个 HLS 视频。当你点击 “Change Video” 按钮时，视频源会被更改，新的视频会开始播放。希望这个文档能对你有所帮助！'
    }
  ]
}
